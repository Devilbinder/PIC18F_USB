Disassembly Listing for usb_tut
Generated From:
I:/pic_tutorial/projects/usb_tut.X/dist/default/production/usb_tut.X.production.elf
Jul 22, 2020 10:55:29 PM

---  I:/pic_tutorial/projects/usb_tut.X/mcc_generated_files/usb/usb_device_events.c  --------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /** INCLUDES *******************************************************/
23:            #include <stdbool.h>
24:            #include <stdint.h>
25:            #include "usb_device.h"
26:            #include "usb_device_cdc.h"
27:            
28:            /*******************************************************************
29:             * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
30:             *                        USB_EVENT event, void *pdata, uint16_t size)
31:             *
32:             * PreCondition:    None
33:             *
34:             * Input:           USB_EVENT event - the type of event
35:             *                  void *pdata - pointer to the event data
36:             *                  uint16_t size - size of the event data
37:             *
38:             * Output:          None
39:             *
40:             * Side Effects:    None
41:             *
42:             * Overview:        This function is called from the USB stack to
43:             *                  notify a user application that a USB event
44:             *                  occured.  This callback is in interrupt context
45:             *                  when the USB_INTERRUPT option is selected.
46:             *
47:             * Note:            None
48:             *******************************************************************/
49:            bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
50:            {
51:                switch( (int) event )
2282  EF4B     GOTO 0x2296
2284  F011     NOP
52:                {
53:                    case EVENT_TRANSFER:
54:                        break;
55:            
56:                    case EVENT_SOF:
57:                        break;
58:            
59:                    case EVENT_SUSPEND:
60:                        //Call the hardware platform specific handler for suspend events for
61:                        //possible further action (like optionally going reconfiguring the application
62:                        //for lower power states and going to sleep during the suspend event).  This
63:                        //would normally be done in USB compliant bus powered applications, although
64:                        //no further processing is needed for purely self powered applications that
65:                        //don't consume power from the host.
66:                        break;
67:            
68:                    case EVENT_RESUME:
69:                        //Call the hardware platform specific resume from suspend handler (ex: to
70:                        //restore I/O pins to higher power states if they were changed during the 
71:                        //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
72:                        //of the suspend condition.
73:                        break;
74:            
75:                    case EVENT_CONFIGURED:
76:                        CDCInitEP();
2286  ECBF     CALL 0x237E, 0
2288  F011     NOP
77:                        break;
228A  EF84     GOTO 0x2308
228C  F011     NOP
78:            
79:                    case EVENT_SET_DESCRIPTOR:
80:                        break;
81:            
82:                    case EVENT_EP0_REQUEST:
83:                        /* We have received a non-standard USB request.  The CDC driver
84:                         * needs to check to see if the request was for it. */
85:                        USBCheckCDCRequest();
228E  EC84     CALL 0x1D08, 0
2290  F00E     NOP
86:                        break;
2292  EF84     GOTO 0x2308
2294  F011     NOP
87:            
88:                    case EVENT_BUS_ERROR:
89:                        break;
90:            
91:                    case EVENT_TRANSFER_TERMINATED:
92:                        break;
93:            
94:                    default:
95:                        break;
96:                }
2296  C038     MOVFF USBDeviceInit, 0x3E
2298  F03E     NOP
229A  C039     MOVFF 0x39, 0x3F
229C  F03F     NOP
229E  503F     MOVF 0x3F, W, ACCESS
22A0  0A00     XORLW 0x0
22A2  B4D8     BTFSC STATUS, 2, ACCESS
22A4  EF5A     GOTO 0x22B4
22A6  F011     NOP
22A8  0A7F     XORLW 0x7F
22AA  B4D8     BTFSC STATUS, 2, ACCESS
22AC  EF7D     GOTO 0x22FA
22AE  F011     NOP
22B0  EF84     GOTO 0x2308
22B2  F011     NOP
22B4  503E     MOVF 0x3E, W, ACCESS
22B6  0A01     XORLW 0x1
22B8  B4D8     BTFSC STATUS, 2, ACCESS
22BA  EF43     GOTO 0x2286
22BC  F011     NOP
22BE  0A03     XORLW 0x3
22C0  B4D8     BTFSC STATUS, 2, ACCESS
22C2  EF84     GOTO 0x2308
22C4  F011     NOP
22C6  0A01     XORLW 0x1
22C8  B4D8     BTFSC STATUS, 2, ACCESS
22CA  EF47     GOTO 0x228E
22CC  F011     NOP
22CE  0A06     XORLW 0x6
22D0  B4D8     BTFSC STATUS, 2, ACCESS
22D2  EF84     GOTO 0x2308
22D4  F011     NOP
22D6  0A77     XORLW 0x77
22D8  B4D8     BTFSC STATUS, 2, ACCESS
22DA  EF84     GOTO 0x2308
22DC  F011     NOP
22DE  0A01     XORLW 0x1
22E0  B4D8     BTFSC STATUS, 2, ACCESS
22E2  EF84     GOTO 0x2308
22E4  F011     NOP
22E6  0A07     XORLW 0x7
22E8  B4D8     BTFSC STATUS, 2, ACCESS
22EA  EF84     GOTO 0x2308
22EC  F011     NOP
22EE  0A01     XORLW 0x1
22F0  B4D8     BTFSC STATUS, 2, ACCESS
22F2  EF84     GOTO 0x2308
22F4  F011     NOP
22F6  EF84     GOTO 0x2308
22F8  F011     NOP
22FA  503E     MOVF 0x3E, W, ACCESS
22FC  0AFF     XORLW 0xFF
22FE  B4D8     BTFSC STATUS, 2, ACCESS
2300  EF84     GOTO 0x2308
2302  F011     NOP
2304  EF84     GOTO 0x2308
2306  F011     NOP
97:                return true;
98:            }
2308  0012     RETURN 0
99:            
---  I:/pic_tutorial/projects/usb_tut.X/mcc_generated_files/usb/usb_device_cdc.c  -----------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /********************************************************************
23:             Change History:
24:              Rev    Description
25:              ----   -----------
26:              2.3    Deprecated the mUSBUSARTIsTxTrfReady() macro.  It is 
27:                     replaced by the USBUSARTIsTxTrfReady() function.
28:            
29:              2.6    Minor definition changes
30:            
31:              2.6a   No Changes
32:            
33:              2.7    Fixed error in the part support list of the variables section
34:                     where the address of the CDC variables are defined.  The 
35:                     PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
36:                     was incorrectly named PIC18F4458.
37:            
38:                     http://www.microchip.com/forums/fb.aspx?m=487397
39:            
40:              2.8    Minor change to CDCInitEP() to enhance ruggedness in
41:                     multi0-threaded usage scenarios.
42:              
43:              2.9b   Updated to implement optional support for DTS reporting.
44:            
45:            ********************************************************************/
46:            
47:            /** I N C L U D E S **********************************************************/
48:            #include "usb.h"
49:            #include "usb_device_cdc.h"
50:            
51:            #ifdef USB_USE_CDC
52:            
53:            #ifndef FIXED_ADDRESS_MEMORY
54:                #define IN_DATA_BUFFER_ADDRESS_TAG
55:                #define OUT_DATA_BUFFER_ADDRESS_TAG
56:                #define CONTROL_BUFFER_ADDRESS_TAG
57:                #define DRIVER_DATA_ADDRESS_TAG
58:            #endif
59:            
60:            #if !defined(IN_DATA_BUFFER_ADDRESS_TAG) || !defined(OUT_DATA_BUFFER_ADDRESS_TAG) || !defined(CONTROL_BUFFER_ADDRESS_TAG) || !defined(DRIVER_DATA_ADDRESS_TAG)
61:                #error "One of the fixed memory address definitions is not defined.  Please define the required address tags for the required buffers."
62:            #endif
63:            
64:            /** V A R I A B L E S ********************************************************/
65:            volatile unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;
66:            volatile unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;
67:            
68:            typedef union
69:            {
70:                LINE_CODING lineCoding;
71:                CDC_NOTICE cdcNotice;
72:            } CONTROL_BUFFER;
73:            
74:            //static CONTROL_BUFFER controlBuffer CONTROL_BUFFER_ADDRESS_TAG;
75:            
76:            LINE_CODING line_coding;    // Buffer to store line coding information
77:            CDC_NOTICE cdc_notice;
78:            
79:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
80:                SERIAL_STATE_NOTIFICATION SerialStatePacket DRIVER_DATA_ADDRESS_TAG;
81:            #endif
82:            
83:            uint8_t cdc_rx_len;            // total rx length
84:            uint8_t cdc_trf_state;         // States are defined cdc.h
85:            POINTER pCDCSrc;            // Dedicated source pointer
86:            POINTER pCDCDst;            // Dedicated destination pointer
87:            uint8_t cdc_tx_len;            // total tx length
88:            uint8_t cdc_mem_type;          // _ROM, _RAM
89:            
90:            USB_HANDLE CDCDataOutHandle;
91:            USB_HANDLE CDCDataInHandle;
92:            
93:            
94:            CONTROL_SIGNAL_BITMAP control_signal_bitmap;
95:            uint32_t BaudRateGen;			// BRG value calculated from baud rate
96:            
97:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
98:                BM_SERIAL_STATE SerialStateBitmap;
99:                BM_SERIAL_STATE OldSerialStateBitmap;
100:               USB_HANDLE CDCNotificationInHandle;
101:           #endif
102:           
103:           /**************************************************************************
104:             SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
105:             requests according to the CDC specification.
106:             However, it is not really being used here, therefore a dummy buffer is
107:             used for conformance.
108:            **************************************************************************/
109:           #define dummy_length    0x08
110:           uint8_t dummy_encapsulated_cmd_response[dummy_length];
111:           
112:           #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
113:           CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
114:           #endif
115:           
116:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
117:           void USBCDCSetLineCoding(void);
118:           
119:           /** D E C L A R A T I O N S **************************************************/
120:           //#pragma code
121:           
122:           /** C L A S S  S P E C I F I C  R E Q ****************************************/
123:           /******************************************************************************
124:            	Function:
125:            		void USBCheckCDCRequest(void)
126:            
127:            	Description:
128:            		This routine checks the most recently received SETUP data packet to 
129:            		see if the request is specific to the CDC class.  If the request was
130:            		a CDC specific request, this function will take care of handling the
131:            		request and responding appropriately.
132:            		
133:            	PreCondition:
134:            		This function should only be called after a control transfer SETUP
135:            		packet has arrived from the host.
136:           
137:           	Parameters:
138:           		None
139:           		
140:           	Return Values:
141:           		None
142:           		
143:           	Remarks:
144:           		This function does not change status or do anything if the SETUP packet
145:           		did not contain a CDC class specific request.		 
146:             *****************************************************************************/
147:           void USBCheckCDCRequest(void)
148:           {
149:               /*
150:                * If request recipient is not an interface then return
151:                */
152:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
1D08  0104     MOVLB 0x4
1D0A  5130     MOVF n, W, BANKED
1D0C  0B1F     ANDLW 0x1F
1D0E  06E8     DECF WREG, F, ACCESS
1D10  B4D8     BTFSC STATUS, 2, ACCESS
1D12  EF8D     GOTO 0x1D1A
1D14  F00E     NOP
1D16  EF8F     GOTO 0x1D1E
1D18  F00E     NOP
1D1A  EF91     GOTO 0x1D22
1D1C  F00E     NOP
1D1E  EF04     GOTO 0x1E08
1D20  F00F     NOP
153:           
154:               /*
155:                * If request type is not class-specific then return
156:                */
157:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
1D22  3930     SWAPF n, W, BANKED
1D24  32E8     RRCF WREG, F, ACCESS
1D26  0B03     ANDLW 0x3
1D28  06E8     DECF WREG, F, ACCESS
1D2A  B4D8     BTFSC STATUS, 2, ACCESS
1D2C  EF9A     GOTO 0x1D34
1D2E  F00E     NOP
1D30  EF9C     GOTO 0x1D38
1D32  F00E     NOP
1D34  EF9E     GOTO 0x1D3C
1D36  F00E     NOP
1D38  EF04     GOTO 0x1E08
1D3A  F00F     NOP
158:           
159:               /*
160:                * Interface ID must match interface numbers associated with
161:                * CDC class, else return
162:                */
163:               if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
1D3C  5134     MOVF ep, W, BANKED
1D3E  B4D8     BTFSC STATUS, 2, ACCESS
1D40  EFA4     GOTO 0x1D48
1D42  F00E     NOP
1D44  EFA6     GOTO 0x1D4C
1D46  F00E     NOP
1D48  EFE3     GOTO 0x1DC6
1D4A  F00E     NOP
1D4C  0534     DECF ep, W, BANKED
1D4E  B4D8     BTFSC STATUS, 2, ACCESS
1D50  EFAC     GOTO 0x1D58
1D52  F00E     NOP
1D54  EFAE     GOTO 0x1D5C
1D56  F00E     NOP
1D58  EFE3     GOTO 0x1DC6
1D5A  F00E     NOP
1D5C  EF04     GOTO 0x1E08
1D5E  F00F     NOP
164:                  (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
165:               
166:               switch(SetupPkt.bRequest)
167:               {
168:                   //****** These commands are required ******//
169:                   case SEND_ENCAPSULATED_COMMAND:
170:                    //send the packet
171:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response;
1D60  0ECC     MOVLW 0xCC
1D62  6E0F     MOVWF inPipes, ACCESS
1D64  0E00     MOVLW 0x0
1D66  6E10     MOVWF 0x10, ACCESS
172:                       inPipes[0].wCount.Val = dummy_length;
1D68  0E00     MOVLW 0x0
1D6A  6E14     MOVWF 0x14, ACCESS
1D6C  0E08     MOVLW 0x8
1D6E  6E13     MOVWF 0x13, ACCESS
173:                       inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
1D70  8012     BSF 0x12, 0, ACCESS
174:                       inPipes[0].info.bits.busy = 1;
1D72  8E12     BSF 0x12, 7, ACCESS
175:                       break;
1D74  EF04     GOTO 0x1E08
1D76  F00F     NOP
176:                   case GET_ENCAPSULATED_RESPONSE:
177:                       // Populate dummy_encapsulated_cmd_response first.
178:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response;
1D78  0ECC     MOVLW 0xCC
1D7A  6E0F     MOVWF inPipes, ACCESS
1D7C  0E00     MOVLW 0x0
1D7E  6E10     MOVWF 0x10, ACCESS
179:                       inPipes[0].info.bits.busy = 1;
1D80  8E12     BSF 0x12, 7, ACCESS
180:                       break;
1D82  EF04     GOTO 0x1E08
1D84  F00F     NOP
181:                   //****** End of required commands ******//
182:           
183:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
184:                   case SET_LINE_CODING:
185:                       outPipes[0].wCount.Val = SetupPkt.wLength;
1D86  C436     MOVFF 0x436, 0x5
1D88  F005     NOP
1D8A  C437     MOVFF 0x437, 0x6
1D8C  F006     NOP
186:                       outPipes[0].pDst.bRam = (uint8_t*)LINE_CODING_TARGET;
1D8E  0ED4     MOVLW 0xD4
1D90  6E01     MOVWF outPipes, ACCESS
1D92  0E00     MOVLW 0x0
1D94  6E02     MOVWF 0x2, ACCESS
187:                       outPipes[0].pFunc = LINE_CODING_PFUNC;
1D96  0E00     MOVLW 0x0
1D98  6E07     MOVWF 0x7, ACCESS
1D9A  0E00     MOVLW 0x0
1D9C  6E08     MOVWF 0x8, ACCESS
188:                       outPipes[0].info.bits.busy = 1;
1D9E  8E04     BSF 0x4, 7, ACCESS
189:                       break;
1DA0  EF04     GOTO 0x1E08
1DA2  F00F     NOP
190:                       
191:                   case GET_LINE_CODING:
192:                       USBEP0SendRAMPtr(
1DA4  0ED4     MOVLW 0xD4
1DA6  6E0F     MOVWF inPipes, ACCESS
1DA8  0E00     MOVLW 0x0
1DAA  6E10     MOVWF 0x10, ACCESS
1DAC  0E00     MOVLW 0x0
1DAE  6E14     MOVWF 0x14, ACCESS
1DB0  0E07     MOVLW 0x7
1DB2  6E13     MOVWF 0x13, ACCESS
1DB4  0EC1     MOVLW 0xC1
1DB6  6E12     MOVWF 0x12, ACCESS
193:                           (uint8_t*)&line_coding,
194:                           LINE_CODING_LENGTH,
195:                           USB_EP0_INCLUDE_ZERO);
196:                       break;
1DB8  EF04     GOTO 0x1E08
1DBA  F00F     NOP
197:           
198:                   case SET_CONTROL_LINE_STATE:
199:                       control_signal_bitmap._byte = (uint8_t)SetupPkt.wValue;
1DBC  C432     MOVFF 0x432, control_signal_bitmap
1DBE  F08A     NOP
200:                       //------------------------------------------------------------------            
201:                       //One way to control the RTS pin is to allow the USB host to decide the value
202:                       //that should be output on the RTS pin.  Although RTS and CTS pin functions
203:                       //are technically intended for UART hardware based flow control, some legacy
204:                       //UART devices use the RTS pin like a "general purpose" output pin 
205:                       //from the PC host.  In this usage model, the RTS pin is not related
206:                       //to flow control for RX/TX.
207:                       //In this scenario, the USB host would want to be able to control the RTS
208:                       //pin, and the below line of code should be uncommented.
209:                       //However, if the intention is to implement true RTS/CTS flow control
210:                       //for the RX/TX pair, then this application firmware should override
211:                       //the USB host's setting for RTS, and instead generate a real RTS signal,
212:                       //based on the amount of remaining buffer space available for the 
213:                       //actual hardware UART of this microcontroller.  In this case, the 
214:                       //below code should be left commented out, but instead RTS should be 
215:                       //controlled in the application firmware responsible for operating the 
216:                       //hardware UART of this microcontroller.
217:                       //---------            
218:                       //CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);  
219:                       //------------------------------------------------------------------            
220:                       
221:                       #if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
222:                           if(control_signal_bitmap.DTE_PRESENT == 1)
223:                           {
224:                               UART_DTR = USB_CDC_DTR_ACTIVE_LEVEL;
225:                           }
226:                           else
227:                           {
228:                               UART_DTR = (USB_CDC_DTR_ACTIVE_LEVEL ^ 1);
229:                           }        
230:                       #endif
231:                       inPipes[0].info.bits.busy = 1;
1DC0  8E12     BSF 0x12, 7, ACCESS
232:                       break;
1DC2  EF04     GOTO 0x1E08
1DC4  F00F     NOP
233:                   #endif
234:           
235:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
236:                   case SEND_BREAK:                        // Optional
237:                       inPipes[0].info.bits.busy = 1;
238:           			if (SetupPkt.wValue == 0xFFFF)  //0xFFFF means send break indefinitely until a new SEND_BREAK command is received
239:           			{
240:           				UART_Tx = 0;       // Prepare to drive TX low (for break signaling)
241:           				UART_TRISTx = 0;   // Make sure TX pin configured as an output
242:           				UART_ENABLE = 0;   // Turn off USART (to relinquish TX pin control)
243:           			}
244:           			else if (SetupPkt.wValue == 0x0000) //0x0000 means stop sending indefinite break 
245:           			{
246:               			UART_ENABLE = 1;   // turn on USART
247:           				UART_TRISTx = 1;   // Make TX pin an input
248:           			}
249:           			else
250:           			{
251:                           //Send break signaling on the pin for (SetupPkt.wValue) milliseconds
252:                           UART_SEND_BREAK();
253:           			}
254:                       break;
255:                   #endif
256:                   default:
257:                       break;
258:               }//end switch(SetupPkt.bRequest)
1DC6  5131     MOVF EPNum, W, BANKED
1DC8  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1DCA  6A2D     CLRF data, ACCESS
1DCC  502D     MOVF data, W, ACCESS
1DCE  0A00     XORLW 0x0
1DD0  B4D8     BTFSC STATUS, 2, ACCESS
1DD2  EFED     GOTO 0x1DDA
1DD4  F00E     NOP
1DD6  EF04     GOTO 0x1E08
1DD8  F00F     NOP
1DDA  502C     MOVF __pcstackCOMRAM, W, ACCESS
1DDC  0A00     XORLW 0x0
1DDE  B4D8     BTFSC STATUS, 2, ACCESS
1DE0  EFB0     GOTO 0x1D60
1DE2  F00E     NOP
1DE4  0A01     XORLW 0x1
1DE6  B4D8     BTFSC STATUS, 2, ACCESS
1DE8  EFBC     GOTO 0x1D78
1DEA  F00E     NOP
1DEC  0A21     XORLW 0x21
1DEE  B4D8     BTFSC STATUS, 2, ACCESS
1DF0  EFC3     GOTO 0x1D86
1DF2  F00E     NOP
1DF4  0A01     XORLW 0x1
1DF6  B4D8     BTFSC STATUS, 2, ACCESS
1DF8  EFD2     GOTO 0x1DA4
1DFA  F00E     NOP
1DFC  0A03     XORLW 0x3
1DFE  B4D8     BTFSC STATUS, 2, ACCESS
1E00  EFDE     GOTO 0x1DBC
1E02  F00E     NOP
1E04  EF04     GOTO 0x1E08
1E06  F00F     NOP
259:           
260:           }//end USBCheckCDCRequest
1E08  0012     RETURN 0
261:           
262:           /** U S E R  A P I ***********************************************************/
263:           
264:           /**************************************************************************
265:             Function:
266:                   void CDCInitEP(void)
267:               
268:             Summary:
269:               This function initializes the CDC function driver. This function should
270:               be called after the SET_CONFIGURATION command (ex: within the context of
271:               the USBCBInitEP() function).
272:             Description:
273:               This function initializes the CDC function driver. This function sets
274:               the default line coding (baud rate, bit parity, number of data bits,
275:               and format). This function also enables the endpoints and prepares for
276:               the first transfer from the host.
277:               
278:               This function should be called after the SET_CONFIGURATION command.
279:               This is most simply done by calling this function from the
280:               USBCBInitEP() function.
281:               
282:               Typical Usage:
283:               <code>
284:                   void USBCBInitEP(void)
285:                   {
286:                       CDCInitEP();
287:                   }
288:               </code>
289:             Conditions:
290:               None
291:             Remarks:
292:               None                                                                   
293:             **************************************************************************/
294:           void CDCInitEP(void)
295:           {
296:               //Abstract line coding information
297:               line_coding.dwDTERate   = 19200;      // baud rate
237E  0E00     MOVLW 0x0
2380  0100     MOVLB 0x0
2382  6FD4     MOVWF line_coding, BANKED
2384  0E4B     MOVLW 0x4B
2386  6FD5     MOVWF 0xD5, BANKED
2388  0E00     MOVLW 0x0
238A  6FD6     MOVWF 0xD6, BANKED
238C  0E00     MOVLW 0x0
238E  6FD7     MOVWF 0xD7, BANKED
298:               line_coding.bCharFormat = 0x00;             // 1 stop bit
2390  0E00     MOVLW 0x0
2392  6FD8     MOVWF 0xD8, BANKED
299:               line_coding.bParityType = 0x00;             // None
2394  0E00     MOVLW 0x0
2396  6FD9     MOVWF 0xD9, BANKED
300:               line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
2398  0E08     MOVLW 0x8
239A  6FDA     MOVWF 0xDA, BANKED
301:           
302:               cdc_rx_len = 0;
239C  0E00     MOVLW 0x0
239E  6E27     MOVWF cdc_rx_len, ACCESS
303:               
304:               /*
305:                * Do not have to init Cnt of IN pipes here.
306:                * Reason:  Number of BYTEs to send to the host
307:                *          varies from one transaction to
308:                *          another. Cnt should equal the exact
309:                *          number of BYTEs to transmit for
310:                *          a given IN transaction.
311:                *          This number of BYTEs will only
312:                *          be known right before the data is
313:                *          sent.
314:                */
315:               USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
23A0  0E1A     MOVLW 0x1A
23A2  6E34     MOVWF ep, ACCESS
23A4  0E01     MOVLW 0x1
23A6  EC49     CALL 0x2492, 0
23A8  F012     NOP
316:               USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
23AA  0E1E     MOVLW 0x1E
23AC  6E34     MOVWF ep, ACCESS
23AE  0E02     MOVLW 0x2
23B0  EC49     CALL 0x2492, 0
23B2  F012     NOP
317:           
318:               CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
23B4  0E00     MOVLW 0x0
23B6  6E2C     MOVWF __pcstackCOMRAM, ACCESS
23B8  0E40     MOVLW 0x40
23BA  6E2D     MOVWF data, ACCESS
23BC  0E05     MOVLW 0x5
23BE  6E2E     MOVWF p, ACCESS
23C0  0E40     MOVLW 0x40
23C2  6E2F     MOVWF len, ACCESS
23C4  0E02     MOVLW 0x2
23C6  ECCC     CALL 0x1798, 0
23C8  F00B     NOP
23CA  C02C     MOVFF __pcstackCOMRAM, CDCDataOutHandle
23CC  F019     NOP
23CE  C02D     MOVFF data, 0x1A
23D0  F01A     NOP
319:               CDCDataInHandle = NULL;
23D2  0E00     MOVLW 0x0
23D4  0100     MOVLB 0x0
23D6  6F86     MOVWF CDCDataInHandle, BANKED
23D8  0E00     MOVLW 0x0
23DA  6F87     MOVWF 0x87, BANKED
320:           
321:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
322:                 	CDCNotificationInHandle = NULL;
323:                   mInitDTSPin();  //Configure DTS as a digital input
324:                 	SerialStateBitmap.byte = 0x00;
325:                 	OldSerialStateBitmap.byte = !SerialStateBitmap.byte;    //To force firmware to send an initial serial state packet to the host.
326:                   //Prepare a SerialState notification element packet (contains info like DSR state)
327:                   SerialStatePacket.bmRequestType = 0xA1; //Always 0xA1 for this type of packet.
328:                   SerialStatePacket.bNotification = SERIAL_STATE;
329:                   SerialStatePacket.wValue = 0x0000;  //Always 0x0000 for this type of packet
330:                   SerialStatePacket.wIndex = CDC_COMM_INTF_ID;  //Interface number  
331:                   SerialStatePacket.SerialState.byte = 0x00;
332:                   SerialStatePacket.Reserved = 0x00;
333:                   SerialStatePacket.wLength = 0x02;   //Always 2 bytes for this type of packet    
334:                   CDCNotificationHandler();
335:             	#endif
336:             	
337:             	#if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
338:             	    mInitDTRPin();
339:             	#endif
340:             	
341:             	#if defined(USB_CDC_SUPPORT_HARDWARE_FLOW_CONTROL)
342:             	    mInitRTSPin();
343:             	    mInitCTSPin();
344:             	#endif
345:               
346:               cdc_trf_state = CDC_TX_READY;
23DC  0E00     MOVLW 0x0
23DE  6E28     MOVWF cdc_trf_state, ACCESS
347:           }//end CDCInitEP
23E0  0012     RETURN 0
348:           
349:           
350:           /**************************************************************************
351:             Function: void CDCNotificationHandler(void)
352:             Summary: Checks for changes in DSR status and reports them to the USB host.
353:             Description: Checks for changes in DSR pin state and reports any changes
354:                          to the USB host. 
355:             Conditions: CDCInitEP() must have been called previously, prior to calling
356:                         CDCNotificationHandler() for the first time.
357:             Remarks:
358:               This function is only implemented and needed when the 
359:               USB_CDC_SUPPORT_DSR_REPORTING option has been enabled.  If the function is
360:               enabled, it should be called periodically to sample the DSR pin and feed
361:               the information to the USB host.  This can be done by calling 
362:               CDCNotificationHandler() by itself, or, by calling CDCTxService() which
363:               also calls CDCNotificationHandler() internally, when appropriate.
364:             **************************************************************************/
365:           #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
366:           void CDCNotificationHandler(void)
367:           {
368:               //Check the DTS I/O pin and if a state change is detected, notify the 
369:               //USB host by sending a serial state notification element packet.
370:               if(UART_DTS == USB_CDC_DSR_ACTIVE_LEVEL) //UART_DTS must be defined to be an I/O pin in the hardware profile to use the DTS feature (ex: "PORTXbits.RXY")
371:               {
372:                   SerialStateBitmap.bits.DSR = 1;
373:               }  
374:               else
375:               {
376:                   SerialStateBitmap.bits.DSR = 0;
377:               }        
378:               
379:               //If the state has changed, and the endpoint is available, send a packet to
380:               //notify the hUSB host of the change.
381:               if((SerialStateBitmap.byte != OldSerialStateBitmap.byte) && (!USBHandleBusy(CDCNotificationInHandle)))
382:               {
383:                   //Copy the updated value into the USB packet buffer to send.
384:                   SerialStatePacket.SerialState.byte = SerialStateBitmap.byte;
385:                   //We don't need to write to the other bytes in the SerialStatePacket USB
386:                   //buffer, since they don't change and will always be the same as our
387:                   //initialized value.
388:           
389:                   //Send the packet over USB to the host.
390:                   CDCNotificationInHandle = USBTransferOnePacket(CDC_COMM_EP, IN_TO_HOST, (uint8_t*)&SerialStatePacket, sizeof(SERIAL_STATE_NOTIFICATION));
391:                   
392:                   //Save the old value, so we can detect changes later.
393:                   OldSerialStateBitmap.byte = SerialStateBitmap.byte;
394:               }    
395:           }//void CDCNotificationHandler(void)    
396:           #else
397:               #define CDCNotificationHandler() {}
398:           #endif
399:           
400:           
401:           /**********************************************************************************
402:             Function:
403:               bool USBCDCEventHandler(USB_EVENT event, void *pdata, uint16_t size)
404:               
405:             Summary:
406:               Handles events from the USB stack, which may have an effect on the CDC 
407:               endpoint(s).
408:           
409:             Description:
410:               Handles events from the USB stack.  This function should be called when 
411:               there is a USB event that needs to be processed by the CDC driver.
412:               
413:             Conditions:
414:               Value of input argument 'len' should be smaller than the maximum
415:               endpoint size responsible for receiving bulk data from USB host for CDC
416:               class. Input argument 'buffer' should point to a buffer area that is
417:               bigger or equal to the size specified by 'len'.
418:             Input:
419:               event - the type of event that occurred
420:               pdata - pointer to the data that caused the event
421:               size - the size of the data that is pointed to by pdata
422:                                                                                              
423:             **********************************************************************************/
424:           bool USBCDCEventHandler(USB_EVENT event, void *pdata, uint16_t size)
425:           {
426:               switch( (uint16_t)event )
427:               {  
428:                   case EVENT_TRANSFER_TERMINATED:
429:                       if(pdata == CDCDataOutHandle)
430:                       {
431:                           CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
432:                       }
433:                       if(pdata == CDCDataInHandle)
434:                       {
435:                           //flush all of the data in the CDC buffer
436:                           cdc_trf_state = CDC_TX_READY;
437:                           cdc_tx_len = 0;
438:                       }
439:                       break;
440:                   default:
441:                       return false;
442:               }      
443:               return true;
444:           }
445:           
446:           /**********************************************************************************
447:             Function:
448:                   uint8_t getsUSBUSART(char *buffer, uint8_t len)
449:               
450:             Summary:
451:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
452:               endpoint to a user's specified location. It is a non-blocking function.
453:               It does not wait for data if there is no data available. Instead it
454:               returns '0' to notify the caller that there is no data available.
455:           
456:             Description:
457:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
458:               endpoint to a user's specified location. It is a non-blocking function.
459:               It does not wait for data if there is no data available. Instead it
460:               returns '0' to notify the caller that there is no data available.
461:               
462:               Typical Usage:
463:               <code>
464:                   uint8_t numBytes;
465:                   uint8_t buffer[64]
466:               
467:                   numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
468:                   if(numBytes \> 0)
469:                   {
470:                       //we received numBytes bytes of data and they are copied into
471:                       //  the "buffer" variable.  We can do something with the data
472:                       //  here.
473:                   }
474:               </code>
475:             Conditions:
476:               Value of input argument 'len' should be smaller than the maximum
477:               endpoint size responsible for receiving bulk data from USB host for CDC
478:               class. Input argument 'buffer' should point to a buffer area that is
479:               bigger or equal to the size specified by 'len'.
480:             Input:
481:               buffer -  Pointer to where received BYTEs are to be stored
482:               len -     The number of BYTEs expected.
483:                                                                                              
484:             **********************************************************************************/
485:           uint8_t getsUSBUSART(uint8_t *buffer, uint8_t len)
486:           {
487:               cdc_rx_len = 0;
488:               
489:               if(!USBHandleBusy(CDCDataOutHandle))
490:               {
491:                   /*
492:                    * Adjust the expected number of BYTEs to equal
493:                    * the actual number of BYTEs received.
494:                    */
495:                   if(len > USBHandleGetLength(CDCDataOutHandle))
496:                       len = USBHandleGetLength(CDCDataOutHandle);
497:                   
498:                   /*
499:                    * Copy data from dual-ram buffer to user's buffer
500:                    */
501:                   for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
502:                       buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
503:           
504:                   /*
505:                    * Prepare dual-ram buffer for next OUT transaction
506:                    */
507:           
508:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
509:           
510:               }//end if
511:               
512:               return cdc_rx_len;
513:               
514:           }//end getsUSBUSART
515:           
516:           /******************************************************************************
517:             Function:
518:           	void putUSBUSART(char *data, uint8_t length)
519:           		
520:             Summary:
521:               putUSBUSART writes an array of data to the USB. Use this version, is
522:               capable of transferring 0x00 (what is typically a NULL character in any of
523:               the string transfer functions).
524:           
525:             Description:
526:               putUSBUSART writes an array of data to the USB. Use this version, is
527:               capable of transferring 0x00 (what is typically a NULL character in any of
528:               the string transfer functions).
529:               
530:               Typical Usage:
531:               <code>
532:                   if(USBUSARTIsTxTrfReady())
533:                   {
534:                       char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
535:                       putUSBUSART(data,5);
536:                   }
537:               </code>
538:               
539:               The transfer mechanism for device-to-host(put) is more flexible than
540:               host-to-device(get). It can handle a string of data larger than the
541:               maximum size of bulk IN endpoint. A state machine is used to transfer a
542:               \long string of data over multiple USB transactions. CDCTxService()
543:               must be called periodically to keep sending blocks of data to the host.
544:           
545:             Conditions:
546:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
547:               transfer is complete and is ready to receive a new block of data. The
548:               string of characters pointed to by 'data' must equal to or smaller than
549:               255 BYTEs.
550:           
551:             Input:
552:               char *data - pointer to a RAM array of data to be transfered to the host
553:               uint8_t length - the number of bytes to be transfered (must be less than 255).
554:           		
555:            *****************************************************************************/
556:           void putUSBUSART(uint8_t *data, uint8_t  length)
557:           {
558:               /*
559:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
560:                * before calling this function.
561:                * As a safety precaution, this function checks the state one more time
562:                * to make sure it does not override any pending transactions.
563:                *
564:                * Currently it just quits the routine without reporting any errors back
565:                * to the user.
566:                *
567:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
568:                *             before calling this function!
569:                * Example:
570:                * if(USBUSARTIsTxTrfReady())
571:                *     putUSBUSART(pData, Length);
572:                *
573:                * IMPORTANT: Never use the following blocking while loop to wait:
574:                * while(!USBUSARTIsTxTrfReady())
575:                *     putUSBUSART(pData, Length);
576:                *
577:                * The whole firmware framework is written based on cooperative
578:                * multi-tasking and a blocking code is not acceptable.
579:                * Use a state machine instead.
580:                */
581:               USBMaskInterrupts();
582:               if(cdc_trf_state == CDC_TX_READY)
583:               {
584:                   mUSBUSARTTxRam((uint8_t*)data, length);     // See cdc.h
585:               }
586:               USBUnmaskInterrupts();
587:           }//end putUSBUSART
588:           
589:           /******************************************************************************
590:           	Function:
591:           		void putsUSBUSART(char *data)
592:           		
593:             Summary:
594:               putsUSBUSART writes a string of data to the USB including the null
595:               character. Use this version, 'puts', to transfer data from a RAM buffer.
596:           
597:             Description:
598:               putsUSBUSART writes a string of data to the USB including the null
599:               character. Use this version, 'puts', to transfer data from a RAM buffer.
600:               
601:               Typical Usage:
602:               <code>
603:                   if(USBUSARTIsTxTrfReady())
604:                   {
605:                       char data[] = "Hello World";
606:                       putsUSBUSART(data);
607:                   }
608:               </code>
609:               
610:               The transfer mechanism for device-to-host(put) is more flexible than
611:               host-to-device(get). It can handle a string of data larger than the
612:               maximum size of bulk IN endpoint. A state machine is used to transfer a
613:               \long string of data over multiple USB transactions. CDCTxService()
614:               must be called periodically to keep sending blocks of data to the host.
615:           
616:             Conditions:
617:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
618:               transfer is complete and is ready to receive a new block of data. The
619:               string of characters pointed to by 'data' must equal to or smaller than
620:               255 BYTEs.
621:           
622:             Input:
623:               char *data -  null\-terminated string of constant data. If a
624:                                       null character is not found, 255 BYTEs of data
625:                                       will be transferred to the host.
626:           		
627:            *****************************************************************************/
628:            
629:           void putsUSBUSART(char *data)
630:           {
631:               uint8_t len;
632:               char *pData;
633:           
634:               /*
635:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
636:                * before calling this function.
637:                * As a safety precaution, this function checks the state one more time
638:                * to make sure it does not override any pending transactions.
639:                *
640:                * Currently it just quits the routine without reporting any errors back
641:                * to the user.
642:                *
643:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
644:                *             before calling this function!
645:                * Example:
646:                * if(USBUSARTIsTxTrfReady())
647:                *     putsUSBUSART(pData, Length);
648:                *
649:                * IMPORTANT: Never use the following blocking while loop to wait:
650:                * while(!USBUSARTIsTxTrfReady())
651:                *     putsUSBUSART(pData);
652:                *
653:                * The whole firmware framework is written based on cooperative
654:                * multi-tasking and a blocking code is not acceptable.
655:                * Use a state machine instead.
656:                */
657:               USBMaskInterrupts();
658:               if(cdc_trf_state != CDC_TX_READY)
659:               {
660:                   USBUnmaskInterrupts();
661:                   return;
662:               }
663:               
664:               /*
665:                * While loop counts the number of BYTEs to send including the
666:                * null character.
667:                */
668:               len = 0;
669:               pData = data;
670:               do
671:               {
672:                   len++;
673:                   if(len == 255) break;       // Break loop once max len is reached.
674:               }while(*pData++);
675:               
676:               /*
677:                * Second piece of information (length of data to send) is ready.
678:                * Call mUSBUSARTTxRam to setup the transfer.
679:                * The actual transfer process will be handled by CDCTxService(),
680:                * which should be called once per Main Program loop.
681:                */
682:               mUSBUSARTTxRam((uint8_t*)data, len);     // See cdc.h
683:               USBUnmaskInterrupts();
684:           }//end putsUSBUSART
685:           
686:           /**************************************************************************
687:             Function:
688:                   void putrsUSBUSART(const char *data)
689:               
690:             Summary:
691:               putrsUSBUSART writes a string of data to the USB including the null
692:               character. Use this version, 'putrs', to transfer data literals and
693:               data located in program memory.
694:           
695:             Description:
696:               putrsUSBUSART writes a string of data to the USB including the null
697:               character. Use this version, 'putrs', to transfer data literals and
698:               data located in program memory.
699:               
700:               Typical Usage:
701:               <code>
702:                   if(USBUSARTIsTxTrfReady())
703:                   {
704:                       putrsUSBUSART("Hello World");
705:                   }
706:               </code>
707:               
708:               The transfer mechanism for device-to-host(put) is more flexible than
709:               host-to-device(get). It can handle a string of data larger than the
710:               maximum size of bulk IN endpoint. A state machine is used to transfer a
711:               \long string of data over multiple USB transactions. CDCTxService()
712:               must be called periodically to keep sending blocks of data to the host.
713:           
714:             Conditions:
715:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
716:               transfer is complete and is ready to receive a new block of data. The
717:               string of characters pointed to by 'data' must equal to or smaller than
718:               255 BYTEs.
719:           
720:             Input:
721:               const char *data -      null\-terminated string of constant data. If a
722:                                       null character is not found, 255 uint8_ts of data
723:                                       will be transferred to the host.
724:                                                                                      
725:             **************************************************************************/
726:           void putrsUSBUSART(const char *data)
727:           {
728:               uint8_t len;
729:               const char *pData;
730:           
731:               /*
732:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
733:                * before calling this function.
734:                * As a safety precaution, this function checks the state one more time
735:                * to make sure it does not override any pending transactions.
736:                *
737:                * Currently it just quits the routine without reporting any errors back
738:                * to the user.
739:                *
740:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()
741:                *             before calling this function!
742:                * Example:
743:                * if(USBUSARTIsTxTrfReady())
744:                *     putsUSBUSART(pData);
745:                *
746:                * IMPORTANT: Never use the following blocking while loop to wait:
747:                * while(cdc_trf_state != CDC_TX_READY)
748:                *     putsUSBUSART(pData);
749:                *
750:                * The whole firmware framework is written based on cooperative
751:                * multi-tasking and a blocking code is not acceptable.
752:                * Use a state machine instead.
753:                */
754:               USBMaskInterrupts();
755:               if(cdc_trf_state != CDC_TX_READY)
756:               {
757:                   USBUnmaskInterrupts();
758:                   return;
759:               }
760:               
761:               /*
762:                * While loop counts the number of BYTEs to send including the
763:                * null character.
764:                */
765:               len = 0;
766:               pData = data;
767:               do
768:               {
769:                   len++;
770:                   if(len == 255) break;       // Break loop once max len is reached.
771:               }while(*pData++);
772:               
773:               /*
774:                * Second piece of information (length of data to send) is ready.
775:                * Call mUSBUSARTTxRom to setup the transfer.
776:                * The actual transfer process will be handled by CDCTxService(),
777:                * which should be called once per Main Program loop.
778:                */
779:           
780:               mUSBUSARTTxRom((const uint8_t*)data,len); // See cdc.h
781:               USBUnmaskInterrupts();
782:           
783:           }//end putrsUSBUSART
784:           
785:           /************************************************************************
786:             Function:
787:                   void CDCTxService(void)
788:               
789:             Summary:
790:               CDCTxService handles device-to-host transaction(s). This function
791:               should be called once per Main Program loop after the device reaches
792:               the configured state.
793:             Description:
794:               CDCTxService handles device-to-host transaction(s). This function
795:               should be called once per Main Program loop after the device reaches
796:               the configured state (after the CDCIniEP() function has already executed).
797:               This function is needed, in order to advance the internal software state 
798:               machine that takes care of sending multiple transactions worth of IN USB
799:               data to the host, associated with CDC serial data.  Failure to call 
800:               CDCTxService() periodically will prevent data from being sent to the
801:               USB host, over the CDC serial data interface.
802:               
803:               Typical Usage:
804:               <code>
805:               void main(void)
806:               {
807:                   USBDeviceInit();
808:                   while(1)
809:                   {
810:                       USBDeviceTasks();
811:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
812:                          (USBIsDeviceSuspended() == true))
813:                       {
814:                           //Either the device is not configured or we are suspended
815:                           //  so we don't want to do execute any application code
816:                           continue;   //go back to the top of the while loop
817:                       }
818:                       else
819:                       {
820:                           //Keep trying to send data to the PC as required
821:                           CDCTxService();
822:               
823:                           //Run application code.
824:                           UserApplication();
825:                       }
826:                   }
827:               }
828:               </code>
829:             Conditions:
830:               CDCIniEP() function should have already executed/the device should be
831:               in the CONFIGURED_STATE.
832:             Remarks:
833:               None                                                                 
834:             ************************************************************************/
835:            
836:           void CDCTxService(void)
837:           {
838:               uint8_t byte_to_send;
839:               uint8_t i;
840:               
841:               USBMaskInterrupts();
842:               
843:               CDCNotificationHandler();
844:               
845:               if(USBHandleBusy(CDCDataInHandle)) 
846:               {
847:                   USBUnmaskInterrupts();
848:                   return;
849:               }
850:           
851:               /*
852:                * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
853:                * By having this stage, user can always check cdc_trf_state,
854:                * and not having to call mCDCUsartTxIsBusy() directly.
855:                */
856:               if(cdc_trf_state == CDC_TX_COMPLETING)
857:                   cdc_trf_state = CDC_TX_READY;
858:               
859:               /*
860:                * If CDC_TX_READY state, nothing to do, just return.
861:                */
862:               if(cdc_trf_state == CDC_TX_READY)
863:               {
864:                   USBUnmaskInterrupts();
865:                   return;
866:               }
867:               
868:               /*
869:                * If CDC_TX_BUSY_ZLP state, send zero length packet
870:                */
871:               if(cdc_trf_state == CDC_TX_BUSY_ZLP)
872:               {
873:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
874:                   //CDC_DATA_BD_IN.CNT = 0;
875:                   cdc_trf_state = CDC_TX_COMPLETING;
876:               }
877:               else if(cdc_trf_state == CDC_TX_BUSY)
878:               {
879:                   /*
880:                    * First, have to figure out how many byte of data to send.
881:                    */
882:               	if(cdc_tx_len > sizeof(cdc_data_tx))
883:               	    byte_to_send = sizeof(cdc_data_tx);
884:               	else
885:               	    byte_to_send = cdc_tx_len;
886:           
887:                   /*
888:                    * Subtract the number of bytes just about to be sent from the total.
889:                    */
890:               	cdc_tx_len = cdc_tx_len - byte_to_send;
891:               	  
892:                   pCDCDst.bRam = (uint8_t*)&cdc_data_tx; // Set destination pointer
893:                   
894:                   i = byte_to_send;
895:                   if(cdc_mem_type == USB_EP0_ROM)            // Determine type of memory source
896:                   {
897:                       while(i)
898:                       {
899:                           *pCDCDst.bRam = *pCDCSrc.bRom;
900:                           pCDCDst.bRam++;
901:                           pCDCSrc.bRom++;
902:                           i--;
903:                       }//end while(byte_to_send)
904:                   }
905:                   else
906:                   {
907:                       while(i)
908:                       {
909:                           *pCDCDst.bRam = *pCDCSrc.bRam;
910:                           pCDCDst.bRam++;
911:                           pCDCSrc.bRam++;
912:                           i--;
913:                       }
914:                   }
915:                   
916:                   /*
917:                    * Lastly, determine if a zero length packet state is necessary.
918:                    * See explanation in USB Specification 2.0: Section 5.8.3
919:                    */
920:                   if(cdc_tx_len == 0)
921:                   {
922:                       if(byte_to_send == CDC_DATA_IN_EP_SIZE)
923:                           cdc_trf_state = CDC_TX_BUSY_ZLP;
924:                       else
925:                           cdc_trf_state = CDC_TX_COMPLETING;
926:                   }//end if(cdc_tx_len...)
927:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_tx,byte_to_send);
928:           
929:               }//end if(cdc_tx_sate == CDC_TX_BUSY)
930:               
931:               USBUnmaskInterrupts();
932:           }//end CDCTxService
933:           
934:           #endif //USB_USE_CDC
935:           
936:           /** EOF cdc.c ****************************************************************/
---  I:/pic_tutorial/projects/usb_tut.X/mcc_generated_files/usb/usb_device.c  ---------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <xc.h>
46:            
47:            #include <stdint.h>
48:            #include <stddef.h>
49:            #include <string.h>
50:            
51:            #include "usb_device_config.h"
52:            
53:            #include "usb.h"
54:            #include "usb_ch9.h"
55:            #include "usb_device.h"
56:            #include "usb_device_local.h"
57:            
58:            #ifndef uintptr_t
59:                #if  defined(__XC8__) || defined(__XC16__)
60:                    #define uintptr_t uint16_t
61:                #elif defined (__XC32__)
62:                    #define uintptr_t uint32_t
63:                #endif
64:            #endif
65:            
66:            #if defined(USB_USE_MSD)
67:                #include "usb_device_msd.h"
68:            #endif
69:            
70:            // *****************************************************************************
71:            // *****************************************************************************
72:            // Section: File Scope or Global Constants
73:            // *****************************************************************************
74:            // *****************************************************************************
75:            #if !defined(USE_USB_BUS_SENSE_IO)
76:                //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                //been properly defined elsewhere in the project.
79:                #undef USB_BUS_SENSE
80:                #define USB_BUS_SENSE 1
81:            #endif
82:            
83:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                #define _DTS_CHECKING_ENABLED 0
85:            #else
86:                #define _DTS_CHECKING_ENABLED _DTSEN
87:            #endif
88:            
89:            #if !defined(self_power)
90:                //Assume the application is always bus powered, unless self_power has been
91:                //defined elsewhere in the project
92:                #define self_power 0    //0 = bus powered
93:            #endif
94:            
95:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                //Assume the application only implements one configuration descriptor,
97:                //unless otherwise specified elsewhere in the project
98:                #define USB_MAX_NUM_CONFIG_DSC      1
99:            #endif
100:           
101:           #if defined(__XC8)
102:               //Suppress expected/harmless compiler warning message about unused RAM variables
103:               //and certain function pointer usage.
104:               //Certain variables and function pointers are not used if you don't use all
105:               //of the USB stack APIs.  However, these variables should not be
106:               //removed (since they are still used/needed in some applications, and this
107:               //is a common file shared by many projects, some of which rely on the "unused"
108:               //variables/function pointers).
109:               #pragma warning disable 1090
110:               #if __XC8_VERSION > 1300
111:                   #pragma warning disable 1471
112:               #endif
113:           #endif
114:           
115:           // *****************************************************************************
116:           // *****************************************************************************
117:           // Section: File Scope Data Types
118:           // *****************************************************************************
119:           // *****************************************************************************
120:           typedef union
121:           {
122:               uint8_t Val;
123:               struct __PACKED
124:               {
125:                   unsigned b0:1;
126:                   unsigned b1:1;
127:                   unsigned b2:1;
128:                   unsigned b3:1;
129:                   unsigned b4:1;
130:                   unsigned b5:1;
131:                   unsigned b6:1;
132:                   unsigned b7:1;
133:               } bits;
134:           } uint8_t_VAL, uint8_t_BITS;
135:           
136:           // *****************************************************************************
137:           // *****************************************************************************
138:           // Section: Variables
139:           // *****************************************************************************
140:           // *****************************************************************************
141:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:           USB_VOLATILE uint8_t USBActiveConfiguration;
143:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:           USB_VOLATILE uint8_t shortPacketStatus;
149:           USB_VOLATILE uint8_t controlTransferState;
150:           USB_VOLATILE IN_PIPE inPipes[1];
151:           USB_VOLATILE OUT_PIPE outPipes[1];
152:           USB_VOLATILE uint8_t *pDst;
153:           USB_VOLATILE bool RemoteWakeup;
154:           USB_VOLATILE bool USBBusIsSuspended;
155:           USB_VOLATILE USTAT_FIELDS USTATcopy;
156:           USB_VOLATILE uint8_t endpoint_number;
157:           USB_VOLATILE bool BothEP0OutUOWNsSet;
158:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:           volatile bool USBDeferStatusStagePacket;
162:           volatile bool USBStatusStageEnabledFlag1;
163:           volatile bool USBStatusStageEnabledFlag2;
164:           volatile bool USBDeferINDataStagePackets;
165:           volatile bool USBDeferOUTDataStagePackets;
166:           USB_VOLATILE uint32_t USB1msTickCount;
167:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:           
169:           /** USB FIXED LOCATION VARIABLES ***********************************/
170:           #if defined(COMPILER_MPLAB_C18)
171:               #pragma udata USB_BDT=USB_BDT_ADDRESS
172:           #endif
173:           
174:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:           
176:           /********************************************************************
177:            * EP0 Buffer Space
178:            *******************************************************************/
179:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:           
182:           /********************************************************************
183:            * non-EP0 Buffer Space
184:            *******************************************************************/
185:           #if defined(USB_USE_MSD)
186:               //Check if the MSD application specific USB endpoint buffer placement address 
187:               //macros have already been defined or not (ex: in a processor specific header)
188:               //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:               //must be at a certain address range on certain microcontrollers).
190:               #if !defined(MSD_CBW_ADDR_TAG)
191:                   //Not previously defined.  Assume in this case all microcontroller RAM is
192:                   //USB module accessible, and therefore, no specific address tag value is needed.
193:                   #define MSD_CBW_ADDR_TAG
194:                   #define MSD_CSW_ADDR_TAG
195:               #endif
196:           	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:           	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:           
199:               #if defined(__18CXX) || defined(__XC8)
200:                   #if(__XC8_VERSION < 2000)
201:                       volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
202:                   #else
203:                       volatile char msd_buffer[512] __at(MSD_BUFFER_ADDRESS);
204:                   #endif
205:               #else
206:                   volatile char msd_buffer[512];
207:           	#endif
208:           #endif
209:           
210:           //Depricated in v2.2 - will be removed in a future revision
211:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
212:               //Device descriptor
213:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
214:           #else
215:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
216:           #endif
217:           
218:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
219:               //Array of configuration descriptors
220:               extern const uint8_t *const USB_CD_Ptr[];
221:           #else
222:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
223:           #endif
224:           
225:           extern const uint8_t *const USB_SD_Ptr[];
226:           
227:           
228:           // *****************************************************************************
229:           // *****************************************************************************
230:           // Section: Private and External Prototypes
231:           // *****************************************************************************
232:           // *****************************************************************************
233:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
234:           
235:           static void USBCtrlEPService(void);
236:           static void USBCtrlTrfSetupHandler(void);
237:           static void USBCtrlTrfInHandler(void);
238:           static void USBCheckStdRequest(void);
239:           static void USBStdGetDscHandler(void);
240:           static void USBCtrlEPServiceComplete(void);
241:           static void USBCtrlTrfTxService(void);
242:           static void USBCtrlTrfRxService(void);
243:           static void USBStdSetCfgHandler(void);
244:           static void USBStdGetStatusHandler(void);
245:           static void USBStdFeatureReqHandler(void);
246:           static void USBCtrlTrfOutHandler(void);
247:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
248:           static void USBWakeFromSuspend(void);
249:           static void USBSuspend(void);
250:           static void USBStallHandler(void);
251:           
252:           // *****************************************************************************
253:           // *****************************************************************************
254:           // Section: Macros or Functions
255:           // *****************************************************************************
256:           // *****************************************************************************
257:           
258:           /**************************************************************************
259:               Function:
260:                   void USBDeviceInit(void)
261:               
262:               Description:
263:                   This function initializes the device stack it in the default state. The
264:                   USB module will be completely reset including all of the internal
265:                   variables, registers, and interrupt flags.
266:                           
267:               Precondition:
268:                   This function must be called before any of the other USB Device
269:                   functions can be called, including USBDeviceTasks().
270:                   
271:               Parameters:
272:                   None
273:                
274:               Return Values:
275:                   None
276:                   
277:               Remarks:
278:                   None
279:                                                                     
280:             ***************************************************************************/
281:           void USBDeviceInit(void)
282:           {
283:               uint8_t i;
284:           
285:               USBDisableInterrupts();
127C  94A3     BCF PIE3, 2, ACCESS
13CA  94A3     BCF PIE3, 2, ACCESS
286:           
287:               //Make sure that if a GPIO output driver exists on VBUS, that it is 
288:               //tri-stated to avoid potential contention with the host
289:               USB_HAL_VBUSTristate();
290:               
291:               // Clear all USB error flags
292:               USBClearInterruptRegister(U1EIR);  
127E  0E00     MOVLW 0x0
1280  6E67     MOVWF UEIR, ACCESS
13CC  0E00     MOVLW 0x0
13CE  6E67     MOVWF UEIR, ACCESS
293:                  
294:               // Clears all USB interrupts          
295:               USBClearInterruptRegister(U1IR); 
1282  0E00     MOVLW 0x0
1284  6E65     MOVWF UIR, ACCESS
13D0  0E00     MOVLW 0x0
13D2  6E65     MOVWF UIR, ACCESS
296:           
297:               //Clear all of the endpoint control registers
298:               U1EP0 = 0;
1286  0E00     MOVLW 0x0
1288  6E6A     MOVWF UEP0, ACCESS
13D4  0E00     MOVLW 0x0
13D6  6E6A     MOVWF UEP0, ACCESS
299:               
300:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
128A  0E6B     MOVLW 0x6B
128C  0100     MOVLB 0x0
128E  6FDD     MOVWF __pcstackBANK0, BANKED
1290  0E0F     MOVLW 0xF
1292  6FDE     MOVWF 0xDE, BANKED
1294  0E00     MOVLW 0x0
1296  6FE0     MOVWF 0xE0, BANKED
1298  0E00     MOVLW 0x0
129A  6FDF     MOVWF c, BANKED
129C  0E00     MOVLW 0x0
129E  6FE2     MOVWF 0xE2, BANKED
12A0  0E02     MOVLW 0x2
12A2  6FE1     MOVWF n, BANKED
12A4  EC17     CALL 0xE2E, 0
12A6  F007     NOP
13D8  0E6B     MOVLW 0x6B
13DA  6E2C     MOVWF __pcstackCOMRAM, ACCESS
13DC  0E0F     MOVLW 0xF
13DE  6E2D     MOVWF data, ACCESS
13E0  0E00     MOVLW 0x0
13E2  6E2F     MOVWF len, ACCESS
13E4  0E00     MOVLW 0x0
13E6  6E2E     MOVWF p, ACCESS
13E8  0E00     MOVLW 0x0
13EA  6E31     MOVWF EPNum, ACCESS
13EC  0E02     MOVLW 0x2
13EE  6E30     MOVWF n, ACCESS
13F0  ECD3     CALL 0xFA6, 0
13F2  F007     NOP
301:           
302:               SetConfigurationOptions();
12A8  0E16     MOVLW 0x16
12AA  6E62     MOVWF UCFG, ACCESS
12AC  0E9F     MOVLW 0x9F
12AE  6E66     MOVWF UEIE, ACCESS
12B0  0E7B     MOVLW 0x7B
12B2  6E64     MOVWF UIE, ACCESS
13F4  0E16     MOVLW 0x16
13F6  6E62     MOVWF UCFG, ACCESS
13F8  0E9F     MOVLW 0x9F
13FA  6E66     MOVWF UEIE, ACCESS
13FC  0E7B     MOVLW 0x7B
13FE  6E64     MOVWF UIE, ACCESS
303:           
304:               //power up the module (if not already powered)
305:               USBPowerModule();
306:           
307:               //set the address of the BDT (if applicable)
308:               USBSetBDTAddress(BDT);
309:           
310:               //Clear all of the BDT entries
311:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
12B4  0E00     MOVLW 0x0
12B6  0100     MOVLB 0x0
12B8  6FE9     MOVWF i, BANKED
1400  0E00     MOVLW 0x0
1402  6E38     MOVWF USBDeviceInit, ACCESS
312:               {
313:                   BDT[i].Val = 0x00;
12BA  51E9     MOVF i, W, BANKED
12BC  0D04     MULLW 0x4
12BE  0E00     MOVLW 0x0
12C0  24F3     ADDWF PROD, W, ACCESS
12C2  6ED9     MOVWF FSR2, ACCESS
12C4  0E04     MOVLW 0x4
12C6  20F4     ADDWFC PRODH, W, ACCESS
12C8  6EDA     MOVWF FSR2H, ACCESS
12CA  6ADE     CLRF POSTINC2, ACCESS
12CC  6ADE     CLRF POSTINC2, ACCESS
12CE  6ADE     CLRF POSTINC2, ACCESS
12D0  6ADD     CLRF POSTDEC2, ACCESS
1404  5038     MOVF USBDeviceInit, W, ACCESS
1406  0D04     MULLW 0x4
1408  0E00     MOVLW 0x0
140A  24F3     ADDWF PROD, W, ACCESS
140C  6ED9     MOVWF FSR2, ACCESS
140E  0E04     MOVLW 0x4
1410  20F4     ADDWFC PRODH, W, ACCESS
1412  6EDA     MOVWF FSR2H, ACCESS
1414  6ADE     CLRF POSTINC2, ACCESS
1416  6ADE     CLRF POSTINC2, ACCESS
1418  6ADE     CLRF POSTINC2, ACCESS
141A  6ADD     CLRF POSTDEC2, ACCESS
314:               }
12D2  2BE9     INCF i, F, BANKED
12D4  0E0B     MOVLW 0xB
12D6  65E9     CPFSGT i, BANKED
12D8  EF70     GOTO 0x12E0
12DA  F009     NOP
12DC  EF72     GOTO 0x12E4
12DE  F009     NOP
12E0  EF5D     GOTO 0x12BA
12E2  F009     NOP
141C  2A38     INCF USBDeviceInit, F, ACCESS
141E  0E0B     MOVLW 0xB
1420  6438     CPFSGT USBDeviceInit, ACCESS
1422  EF15     GOTO 0x142A
1424  F00A     NOP
1426  EF17     GOTO 0x142E
1428  F00A     NOP
142A  EF02     GOTO 0x1404
142C  F00A     NOP
315:           
316:               // Assert reset request to all of the Ping Pong buffer pointers
317:               USBPingPongBufferReset = 1;                    
12E4  8C60     BSF UCON, 6, ACCESS
142E  8C60     BSF UCON, 6, ACCESS
318:           
319:               // Reset to default address
320:               U1ADDR = 0x00;                   
12E6  0E00     MOVLW 0x0
12E8  6E63     MOVWF UADDR, ACCESS
1430  0E00     MOVLW 0x0
1432  6E63     MOVWF UADDR, ACCESS
321:           
322:               // Make sure packet processing is enabled
323:               USBPacketDisable = 0;           
12EA  9860     BCF UCON, 4, ACCESS
1434  9860     BCF UCON, 4, ACCESS
324:           
325:               //Stop trying to reset ping pong buffer pointers
326:               USBPingPongBufferReset = 0;
12EC  9C60     BCF UCON, 6, ACCESS
1436  9C60     BCF UCON, 6, ACCESS
327:           
328:               // Flush any pending transactions
329:               do
330:               {
331:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
12EE  9665     BCF UIR, 3, ACCESS
1438  9665     BCF UIR, 3, ACCESS
332:                   //Initialize USB stack software state variables
333:                   inPipes[0].info.Val = 0;
12F0  0E00     MOVLW 0x0
12F2  6E12     MOVWF 0x12, ACCESS
143A  0E00     MOVLW 0x0
143C  6E12     MOVWF 0x12, ACCESS
334:                   outPipes[0].info.Val = 0;
12F4  0E00     MOVLW 0x0
12F6  6E04     MOVWF 0x4, ACCESS
143E  0E00     MOVLW 0x0
1440  6E04     MOVWF 0x4, ACCESS
335:                   outPipes[0].wCount.Val = 0;
12F8  0E00     MOVLW 0x0
12FA  6E06     MOVWF 0x6, ACCESS
12FC  0E00     MOVLW 0x0
12FE  6E05     MOVWF 0x5, ACCESS
1442  0E00     MOVLW 0x0
1444  6E06     MOVWF 0x6, ACCESS
1446  0E00     MOVLW 0x0
1448  6E05     MOVWF 0x5, ACCESS
336:               }while(USBTransactionCompleteIF == 1);
1300  B665     BTFSC UIR, 3, ACCESS
1302  EF85     GOTO 0x130A
1304  F009     NOP
1306  EF87     GOTO 0x130E
1308  F009     NOP
130A  EF77     GOTO 0x12EE
130C  F009     NOP
144A  B665     BTFSC UIR, 3, ACCESS
144C  EF2A     GOTO 0x1454
144E  F00A     NOP
1450  EF2C     GOTO 0x1458
1452  F00A     NOP
1454  EF1C     GOTO 0x1438
1456  F00A     NOP
337:           
338:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
339:               //try and arm a status stage, even before the first control transfer starts.
340:               USBStatusStageEnabledFlag1 = true;
130E  0E01     MOVLW 0x1
1310  6E1D     MOVWF USBStatusStageEnabledFlag1, ACCESS
1458  0E01     MOVLW 0x1
145A  6E1D     MOVWF USBStatusStageEnabledFlag1, ACCESS
341:               USBStatusStageEnabledFlag2 = true;
1312  0E01     MOVLW 0x1
1314  6E1C     MOVWF USBStatusStageEnabledFlag2, ACCESS
145C  0E01     MOVLW 0x1
145E  6E1C     MOVWF USBStatusStageEnabledFlag2, ACCESS
342:               //Initialize other flags
343:               USBDeferINDataStagePackets = false;
1316  0E00     MOVLW 0x0
1318  6E1B     MOVWF USBDeferINDataStagePackets, ACCESS
1460  0E00     MOVLW 0x0
1462  6E1B     MOVWF USBDeferINDataStagePackets, ACCESS
344:               USBDeferOUTDataStagePackets = false;
131A  0E00     MOVLW 0x0
131C  0100     MOVLB 0x0
131E  6F89     MOVWF USBDeferOUTDataStagePackets, BANKED
1464  0E00     MOVLW 0x0
1466  0100     MOVLB 0x0
1468  6F89     MOVWF USBDeferOUTDataStagePackets, BANKED
345:               USBBusIsSuspended = false;
1320  0E00     MOVLW 0x0
1322  6E22     MOVWF USBBusIsSuspended, ACCESS
146A  0E00     MOVLW 0x0
146C  6E22     MOVWF USBBusIsSuspended, ACCESS
346:           
347:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
348:               //pointers to NULL, so they don't get used inadvertently.
349:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
1324  0E00     MOVLW 0x0
1326  6FE9     MOVWF i, BANKED
146E  0E00     MOVLW 0x0
1470  6E38     MOVWF USBDeviceInit, ACCESS
350:               {
351:                   pBDTEntryIn[i] = 0u;
1328  51E9     MOVF i, W, BANKED
132A  0D02     MULLW 0x2
132C  0E09     MOVLW 0x9
132E  24F3     ADDWF PROD, W, ACCESS
1330  6ED9     MOVWF FSR2, ACCESS
1332  0E00     MOVLW 0x0
1334  20F4     ADDWFC PRODH, W, ACCESS
1336  6EDA     MOVWF FSR2H, ACCESS
1338  0E00     MOVLW 0x0
133A  6EDE     MOVWF POSTINC2, ACCESS
133C  0E00     MOVLW 0x0
133E  6EDD     MOVWF POSTDEC2, ACCESS
1472  5038     MOVF USBDeviceInit, W, ACCESS
1474  0D02     MULLW 0x2
1476  0E09     MOVLW 0x9
1478  24F3     ADDWF PROD, W, ACCESS
147A  6ED9     MOVWF FSR2, ACCESS
147C  0E00     MOVLW 0x0
147E  20F4     ADDWFC PRODH, W, ACCESS
1480  6EDA     MOVWF FSR2H, ACCESS
1482  0E00     MOVLW 0x0
1484  6EDE     MOVWF POSTINC2, ACCESS
1486  0E00     MOVLW 0x0
1488  6EDD     MOVWF POSTDEC2, ACCESS
352:                   pBDTEntryOut[i] = 0u;
1340  51E9     MOVF i, W, BANKED
1342  0D02     MULLW 0x2
1344  0E6A     MOVLW 0x6A
1346  24F3     ADDWF PROD, W, ACCESS
1348  6ED9     MOVWF FSR2, ACCESS
134A  0E00     MOVLW 0x0
134C  20F4     ADDWFC PRODH, W, ACCESS
134E  6EDA     MOVWF FSR2H, ACCESS
1350  0E00     MOVLW 0x0
1352  6EDE     MOVWF POSTINC2, ACCESS
1354  0E00     MOVLW 0x0
1356  6EDD     MOVWF POSTDEC2, ACCESS
148A  5038     MOVF USBDeviceInit, W, ACCESS
148C  0D02     MULLW 0x2
148E  0E6A     MOVLW 0x6A
1490  24F3     ADDWF PROD, W, ACCESS
1492  6ED9     MOVWF FSR2, ACCESS
1494  0E00     MOVLW 0x0
1496  20F4     ADDWFC PRODH, W, ACCESS
1498  6EDA     MOVWF FSR2H, ACCESS
149A  0E00     MOVLW 0x0
149C  6EDE     MOVWF POSTINC2, ACCESS
149E  0E00     MOVLW 0x0
14A0  6EDD     MOVWF POSTDEC2, ACCESS
353:                   ep_data_in[i].Val = 0u;
1358  0E7B     MOVLW 0x7B
135A  25E9     ADDWF i, W, BANKED
135C  6ED9     MOVWF FSR2, ACCESS
135E  6ADA     CLRF FSR2H, ACCESS
1360  0E00     MOVLW 0x0
1362  22DA     ADDWFC FSR2H, F, ACCESS
1364  0E00     MOVLW 0x0
1366  6EDF     MOVWF INDF2, ACCESS
14A2  0E7B     MOVLW 0x7B
14A4  2438     ADDWF USBDeviceInit, W, ACCESS
14A6  6ED9     MOVWF FSR2, ACCESS
14A8  6ADA     CLRF FSR2H, ACCESS
14AA  0E00     MOVLW 0x0
14AC  22DA     ADDWFC FSR2H, F, ACCESS
14AE  0E00     MOVLW 0x0
14B0  6EDF     MOVWF INDF2, ACCESS
354:                   ep_data_out[i].Val = 0u;
1368  0E78     MOVLW 0x78
136A  25E9     ADDWF i, W, BANKED
136C  6ED9     MOVWF FSR2, ACCESS
136E  6ADA     CLRF FSR2H, ACCESS
1370  0E00     MOVLW 0x0
1372  22DA     ADDWFC FSR2H, F, ACCESS
1374  0E00     MOVLW 0x0
1376  6EDF     MOVWF INDF2, ACCESS
14B2  0E78     MOVLW 0x78
14B4  2438     ADDWF USBDeviceInit, W, ACCESS
14B6  6ED9     MOVWF FSR2, ACCESS
14B8  6ADA     CLRF FSR2H, ACCESS
14BA  0E00     MOVLW 0x0
14BC  22DA     ADDWFC FSR2H, F, ACCESS
14BE  0E00     MOVLW 0x0
14C0  6EDF     MOVWF INDF2, ACCESS
355:               }
1378  2BE9     INCF i, F, BANKED
137A  0E02     MOVLW 0x2
137C  65E9     CPFSGT i, BANKED
137E  EFC3     GOTO 0x1386
1380  F009     NOP
1382  EFC5     GOTO 0x138A
1384  F009     NOP
1386  EF94     GOTO 0x1328
1388  F009     NOP
14C2  2A38     INCF USBDeviceInit, F, ACCESS
14C4  0E02     MOVLW 0x2
14C6  6438     CPFSGT USBDeviceInit, ACCESS
14C8  EF68     GOTO 0x14D0
14CA  F00A     NOP
14CC  EF6A     GOTO 0x14D4
14CE  F00A     NOP
14D0  EF39     GOTO 0x1472
14D2  F00A     NOP
356:           
357:               //Get ready for the first packet
358:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
138A  0E08     MOVLW 0x8
138C  6E09     MOVWF pBDTEntryIn, ACCESS
138E  0E04     MOVLW 0x4
1390  6E0A     MOVWF 0xA, ACCESS
14D4  0E08     MOVLW 0x8
14D6  6E09     MOVWF pBDTEntryIn, ACCESS
14D8  0E04     MOVLW 0x4
14DA  6E0A     MOVWF 0xA, ACCESS
359:               // Initialize EP0 as a Ctrl EP
360:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
1392  0E16     MOVLW 0x16
1394  6E6A     MOVWF UEP0, ACCESS
14DC  0E16     MOVLW 0x16
14DE  6E6A     MOVWF UEP0, ACCESS
361:           	//Prepare for the first SETUP on EP0 OUT
362:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
1396  0E04     MOVLW 0x4
1398  0104     MOVLB 0x4
139A  6F03     MOVWF 0x3, BANKED
139C  0E30     MOVLW 0x30
139E  6F02     MOVWF 0x2, BANKED
14E0  0E04     MOVLW 0x4
14E2  0104     MOVLB 0x4
14E4  6F03     MOVWF 0x3, BANKED
14E6  0E30     MOVLW 0x30
14E8  6F02     MOVWF 0x2, BANKED
363:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
13A0  0E08     MOVLW 0x8
13A2  6F01     MOVWF outPipes, BANKED
14EA  0E08     MOVLW 0x8
14EC  6F01     MOVWF outPipes, BANKED
364:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
13A4  0E04     MOVLW 0x4
13A6  6F00     MOVWF ep, BANKED
14EE  0E04     MOVLW 0x4
14F0  6F00     MOVWF ep, BANKED
365:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
13A8  8F00     BSF ep, 7, BANKED
14F2  8F00     BSF ep, 7, BANKED
366:           
367:               // Clear active configuration
368:               USBActiveConfiguration = 0;     
13AA  0E00     MOVLW 0x0
13AC  6E2B     MOVWF USBActiveConfiguration, ACCESS
14F4  0E00     MOVLW 0x0
14F6  6E2B     MOVWF USBActiveConfiguration, ACCESS
369:           
370:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
13AE  0E00     MOVLW 0x0
13B0  0100     MOVLB 0x0
13B2  6F70     MOVWF USB1msTickCount, BANKED
13B4  0E00     MOVLW 0x0
13B6  6F71     MOVWF 0x71, BANKED
13B8  0E00     MOVLW 0x0
13BA  6F72     MOVWF 0x72, BANKED
13BC  0E00     MOVLW 0x0
13BE  6F73     MOVWF 0x73, BANKED
14F8  0E00     MOVLW 0x0
14FA  0100     MOVLB 0x0
14FC  6F70     MOVWF USB1msTickCount, BANKED
14FE  0E00     MOVLW 0x0
1500  6F71     MOVWF 0x71, BANKED
1502  0E00     MOVLW 0x0
1504  6F72     MOVWF 0x72, BANKED
1506  0E00     MOVLW 0x0
1508  6F73     MOVWF 0x73, BANKED
371:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
13C0  0E00     MOVLW 0x0
13C2  6F88     MOVWF USBTicksSinceSuspendEnd, BANKED
150A  0E00     MOVLW 0x0
150C  6F88     MOVWF USBTicksSinceSuspendEnd, BANKED
372:           
373:               //Indicate that we are now in the detached state
374:               USBDeviceState = DETACHED_STATE;
13C4  0E00     MOVLW 0x0
13C6  6E29     MOVWF USBDeviceState, ACCESS
150E  0E00     MOVLW 0x0
1510  6E29     MOVWF USBDeviceState, ACCESS
375:           }
13C8  0012     RETURN 0
1512  0012     RETURN 0
376:           
377:           
378:           
379:           /**************************************************************************
380:             Function:
381:                   void USBDeviceTasks(void)
382:               
383:             Summary:
384:               This function is the main state machine/transaction handler of the USB 
385:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
386:               (usb_device_config.h user option) the USBDeviceTasks() function should be called 
387:               periodically to receive and transmit packets through the stack. This 
388:               function also takes care of control transfers associated with the USB 
389:               enumeration process, and detecting various USB events (such as suspend).  
390:               This function should be called at least once every 1.8ms during the USB 
391:               enumeration process. After the enumeration process is complete (which can 
392:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
393:               USBDeviceTasks() handler may be called the faster of: either once 
394:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
395:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
396:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
397:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
398:               near the top of usb_device.c for more details about minimum timing 
399:               requirements when calling USBDeviceTasks().
400:               
401:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
402:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
403:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
404:               interrupt occurs, and therefore only needs to be called from the interrupt 
405:               context.
406:           
407:             Description:
408:               This function is the main state machine/transaction handler of the USB 
409:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
410:               (usb_device_config.h user option) the USBDeviceTasks() function should be called 
411:               periodically to receive and transmit packets through the stack. This 
412:               function also takes care of control transfers associated with the USB 
413:               enumeration process, and detecting various USB events (such as suspend).  
414:               This function should be called at least once every 1.8ms during the USB 
415:               enumeration process. After the enumeration process is complete (which can 
416:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
417:               USBDeviceTasks() handler may be called the faster of: either once 
418:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
419:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
420:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
421:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
422:               near the top of usb_device.c for more details about minimum timing 
423:               requirements when calling USBDeviceTasks().
424:               
425:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
426:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
427:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
428:               interrupt occurs, and therefore only needs to be called from the interrupt 
429:               context.
430:           
431:               Typical usage:
432:               <code>
433:               void main(void)
434:               {
435:                   USBDeviceInit();
436:                   while(1)
437:                   {
438:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
439:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
440:                          (USBIsDeviceSuspended() == true))
441:                       {
442:                           //Either the device is not configured or we are suspended,
443:                           // so we don't want to execute any USB related application code
444:                           continue;   //go back to the top of the while loop
445:                       }
446:                       else
447:                       {
448:                           //Otherwise we are free to run USB and non-USB related user 
449:                           //application code.
450:                           UserApplication();
451:                       }
452:                   }
453:               }
454:               </code>
455:           
456:             Precondition:
457:               Make sure the USBDeviceInit() function has been called prior to calling
458:               USBDeviceTasks() for the first time.
459:             Remarks:
460:               USBDeviceTasks() does not need to be called while in the USB suspend mode, 
461:               if the user application firmware in the USBCBSuspend() callback function
462:               enables the ACTVIF USB interrupt source and put the microcontroller into 
463:               sleep mode.  If the application firmware decides not to sleep the 
464:               microcontroller core during USB suspend (ex: continues running at full 
465:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
466:               function must still be called periodically, at a rate frequent enough to 
467:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
468:               a worst case primary oscillator and PLL start up time of less than 5ms, then
469:               USBDeviceTasks() should be called once every 5ms in this scenario.
470:              
471:               When the USB cable is detached, or the USB host is not actively powering 
472:               the VBUS line to +5V nominal, the application firmware does not always have 
473:               to call USBDeviceTasks() frequently, as no USB activity will be taking 
474:               place.  However, if USBDeviceTasks() is not called regularly, some 
475:               alternative means of promptly detecting when VBUS is powered (indicating 
476:               host attachment), or not powered (host powered down or USB cable unplugged)
477:               is still needed.  For self or dual self/bus powered USB applications, see 
478:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
479:               considerations.
480:               ***************************************************************************/
481:           void USBDeviceTasks(void)
482:           {
483:               uint8_t i;
484:           
485:               #ifdef USB_SUPPORT_OTG
486:                   //SRP Time Out Check
487:                   if (USBOTGSRPIsReady())
488:                   {
489:                       if (USBT1MSECIF && USBT1MSECIE)
490:                       {
491:                           if (USBOTGGetSRPTimeOutFlag())
492:                           {
493:                               if (USBOTGIsSRPTimeOutExpired())
494:                               {
495:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
496:                               }
497:                           }
498:           
499:                           //Clear Interrupt Flag
500:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
501:                       }
502:                   }
503:               #endif
504:           
505:               #if defined(USB_POLLING)
506:               //If the interrupt option is selected then the customer is required
507:               //  to notify the stack when the device is attached or removed from the
508:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
509:               if (USB_BUS_SENSE != 1)
510:               {
511:                    // Disable module & detach from bus
512:                    U1CON = 0;             
513:           
514:                    // Mask all USB interrupts              
515:                    U1IE = 0;          
516:           
517:                    //Move to the detached state                  
518:                    USBDeviceState = DETACHED_STATE;
519:           
520:                    #ifdef  USB_SUPPORT_OTG    
521:                        //Disable D+ Pullup
522:                        U1OTGCONbits.DPPULUP = 0;
523:           
524:                        //Disable HNP
525:                        USBOTGDisableHnp();
526:           
527:                        //Deactivate HNP
528:                        USBOTGDeactivateHnp();
529:                        
530:                        //If ID Pin Changed State
531:                        if (USBIDIF && USBIDIE)
532:                        {  
533:                            //Re-detect & Initialize
534:                             USBOTGInitialize();
535:           
536:                             //Clear ID Interrupt Flag
537:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
538:                        }
539:                    #endif
540:           
541:                    #if defined __C30__ || defined __XC16__
542:                        //USBClearInterruptFlag(U1OTGIR, 3); 
543:                    #endif
544:                       //return so that we don't go through the rest of 
545:                       //the state machine
546:                    USBClearUSBInterrupt();
547:                    return;
548:               }
549:           
550:           	#ifdef USB_SUPPORT_OTG
551:               //If Session Is Started Then
552:               else
553:           	{
554:                   //If SRP Is Ready
555:                   if (USBOTGSRPIsReady())
556:                   {   
557:                       //Clear SRPReady
558:                       USBOTGClearSRPReady();
559:           
560:                       //Clear SRP Timeout Flag
561:                       USBOTGClearSRPTimeOutFlag();
562:           
563:                       //Indicate Session Started
564:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
565:                   }
566:               }
567:           	#endif	//#ifdef USB_SUPPORT_OTG
568:           
569:               //if we are in the detached state
570:               if(USBDeviceState == DETACHED_STATE)
571:               {
572:           	    //Initialize register to known value
573:                   U1CON = 0;                          
574:           
575:                   // Mask all USB interrupts
576:                   U1IE = 0;                                
577:           
578:                   //Enable/set things like: pull ups, full/low-speed mode, 
579:                   //set the ping pong mode, and set internal transceiver
580:                   SetConfigurationOptions();
581:           
582:                   // Enable module & attach to bus
583:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
584:           
585:                   //moved to the attached state
586:                   USBDeviceState = ATTACHED_STATE;
587:           
588:                   #ifdef  USB_SUPPORT_OTG
589:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
590:                   #endif
591:               }
592:           	#endif  //#if defined(USB_POLLING)
593:           
594:               if(USBDeviceState == ATTACHED_STATE)
0C06  0429     DECF USBDeviceState, W, ACCESS
0C08  A4D8     BTFSS STATUS, 2, ACCESS
0C0A  EF09     GOTO 0xC12
0C0C  F006     NOP
0C0E  EF0B     GOTO 0xC16
0C10  F006     NOP
0C12  EF18     GOTO 0xC30
0C14  F006     NOP
595:               {
596:                   /*
597:                    * After enabling the USB module, it takes some time for the
598:                    * voltage on the D+ or D- line to rise high enough to get out
599:                    * of the SE0 condition. The USB Reset interrupt should not be
600:                    * unmasked until the SE0 condition is cleared. This helps
601:                    * prevent the firmware from misinterpreting this unique event
602:                    * as a USB bus reset from the USB host.
603:                    */
604:           
605:                   if(!USBSE0Event)
0C16  BA60     BTFSC UCON, 5, ACCESS
0C18  EF10     GOTO 0xC20
0C1A  F006     NOP
0C1C  EF12     GOTO 0xC24
0C1E  F006     NOP
0C20  EF18     GOTO 0xC30
0C22  F006     NOP
606:                   {
607:                       //We recently attached, make sure we are in a clean state
608:                       #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
609:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
610:                                           //during attach de-bounce interval
611:                       #else
612:                           USBClearInterruptRegister(U1IR);
0C24  0E00     MOVLW 0x0
0C26  6E65     MOVWF UIR, ACCESS
613:                       #endif
614:           
615:                       #if defined(USB_POLLING)
616:                           U1IE=0;                        // Mask all USB interrupts
617:                       #endif
618:                       USBResetIE = 1;             // Unmask RESET interrupt
0C28  8064     BSF UIE, 0, ACCESS
619:                       USBIdleIE = 1;             // Unmask IDLE interrupt
0C2A  8864     BSF UIE, 4, ACCESS
620:                       USBDeviceState = POWERED_STATE;
0C2C  0E02     MOVLW 0x2
0C2E  6E29     MOVWF USBDeviceState, ACCESS
621:                   }
622:               }
623:           
624:               #ifdef  USB_SUPPORT_OTG
625:                   //If ID Pin Changed State
626:                   if (USBIDIF && USBIDIE)
627:                   {  
628:                       //Re-detect & Initialize
629:                       USBOTGInitialize();
630:           
631:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
632:                   }
633:               #endif
634:           
635:               /*
636:                * Task A: Service USB Activity Interrupt
637:                */
638:               if(USBActivityIF && USBActivityIE)
0C30  A465     BTFSS UIR, 2, ACCESS
0C32  EF1D     GOTO 0xC3A
0C34  F006     NOP
0C36  EF1F     GOTO 0xC3E
0C38  F006     NOP
0C3A  EF29     GOTO 0xC52
0C3C  F006     NOP
0C3E  A464     BTFSS UIE, 2, ACCESS
0C40  EF24     GOTO 0xC48
0C42  F006     NOP
0C44  EF26     GOTO 0xC4C
0C46  F006     NOP
0C48  EF29     GOTO 0xC52
0C4A  F006     NOP
639:               {
640:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0C4C  9465     BCF UIR, 2, ACCESS
641:                   #if defined(USB_SUPPORT_OTG)
642:                       U1OTGIR = 0x10;        
643:                   #else
644:                       USBWakeFromSuspend();
0C4E  EC90     CALL 0x2520, 0
0C50  F012     NOP
645:                   #endif
646:               }
647:           
648:               /*
649:                * Pointless to continue servicing if the device is in suspend mode.
650:                */
651:               if(USBSuspendControl==1)
0C52  A260     BTFSS UCON, 1, ACCESS
0C54  EF2E     GOTO 0xC5C
0C56  F006     NOP
0C58  EF30     GOTO 0xC60
0C5A  F006     NOP
0C5C  EF33     GOTO 0xC66
0C5E  F006     NOP
652:               {
653:                   USBClearUSBInterrupt();
0C60  94A4     BCF PIR3, 2, ACCESS
654:                   return;
0C62  EF16     GOTO 0xE2C
0C64  F007     NOP
655:               }
656:           
657:               /*
658:                * Task B: Service USB Bus Reset Interrupt.
659:                * When bus reset is received during suspend, ACTVIF will be set first,
660:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
661:                * This is why URSTIF is checked after ACTVIF.
662:                *
663:                * The USB reset flag is masked when the USB state is in
664:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
665:                * cause a USB reset event during these two states.
666:                */
667:               if(USBResetIF && USBResetIE)
0C66  A065     BTFSS UIR, 0, ACCESS
0C68  EF38     GOTO 0xC70
0C6A  F006     NOP
0C6C  EF3A     GOTO 0xC74
0C6E  F006     NOP
0C70  EF47     GOTO 0xC8E
0C72  F006     NOP
0C74  A064     BTFSS UIE, 0, ACCESS
0C76  EF3F     GOTO 0xC7E
0C78  F006     NOP
0C7A  EF41     GOTO 0xC82
0C7C  F006     NOP
0C7E  EF47     GOTO 0xC8E
0C80  F006     NOP
668:               {
669:                   USBDeviceInit();
0C82  ECE5     CALL 0x13CA, 0
0C84  F009     NOP
670:           
671:                   //Re-enable the interrupts since the USBDeviceInit() function will
672:                   //  disable them.  This will do nothing in a polling setup
673:                   USBUnmaskInterrupts();
0C86  84A3     BSF PIE3, 2, ACCESS
674:           
675:                   USBDeviceState = DEFAULT_STATE;
0C88  0E04     MOVLW 0x4
0C8A  6E29     MOVWF USBDeviceState, ACCESS
676:           
677:                   #ifdef USB_SUPPORT_OTG
678:                        //Disable HNP
679:                        USBOTGDisableHnp();
680:           
681:                        //Deactivate HNP
682:                        USBOTGDeactivateHnp();
683:                   #endif
684:           
685:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
0C8C  9065     BCF UIR, 0, ACCESS
686:               }
687:           
688:               /*
689:                * Task C: Service other USB interrupts
690:                */
691:               if(USBIdleIF && USBIdleIE)
0C8E  A865     BTFSS UIR, 4, ACCESS
0C90  EF4C     GOTO 0xC98
0C92  F006     NOP
0C94  EF4E     GOTO 0xC9C
0C96  F006     NOP
0C98  EF57     GOTO 0xCAE
0C9A  F006     NOP
0C9C  A864     BTFSS UIE, 4, ACCESS
0C9E  EF53     GOTO 0xCA6
0CA0  F006     NOP
0CA2  EF55     GOTO 0xCAA
0CA4  F006     NOP
0CA6  EF57     GOTO 0xCAE
0CA8  F006     NOP
692:               { 
693:                   #ifdef  USB_SUPPORT_OTG 
694:                       //If Suspended, Try to switch to Host
695:                       USBOTGSelectRole(ROLE_HOST);
696:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
697:                   #else
698:                       USBSuspend();
0CAA  EC02     CALL 0x2604, 0
0CAC  F013     NOP
699:                   #endif
700:               }
701:           
702:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
703:                   //Check if a 1ms interval has elapsed.	
704:                   if(USBT1MSECIF)
705:                   {
706:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
707:                       USBIncrement1msInternalTimers();
708:                   }
709:               #endif
710:           
711:               //Start-of-Frame Interrupt
712:               if(USBSOFIF)
0CAE  AC65     BTFSS UIR, 6, ACCESS
0CB0  EF5C     GOTO 0xCB8
0CB2  F006     NOP
0CB4  EF5E     GOTO 0xCBC
0CB6  F006     NOP
0CB8  EF89     GOTO 0xD12
0CBA  F006     NOP
713:               {
714:                   //Call the user SOF event callback if enabled.
715:                   if(USBSOFIE)
0CBC  AC64     BTFSS UIE, 6, ACCESS
0CBE  EF63     GOTO 0xCC6
0CC0  F006     NOP
0CC2  EF65     GOTO 0xCCA
0CC4  F006     NOP
0CC6  EF73     GOTO 0xCE6
0CC8  F006     NOP
716:                   {
717:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
0CCA  0E00     MOVLW 0x0
0CCC  6E39     MOVWF 0x39, ACCESS
0CCE  0E73     MOVLW 0x73
0CD0  6E38     MOVWF USBDeviceInit, ACCESS
0CD2  0E00     MOVLW 0x0
0CD4  6E3A     MOVWF pdata, ACCESS
0CD6  0E00     MOVLW 0x0
0CD8  6E3B     MOVWF 0x3B, ACCESS
0CDA  0E00     MOVLW 0x0
0CDC  6E3D     MOVWF 0x3D, ACCESS
0CDE  0E01     MOVLW 0x1
0CE0  6E3C     MOVWF size, ACCESS
0CE2  EC41     CALL 0x2282, 0
0CE4  F011     NOP
718:                   }    
719:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
0CE6  9C65     BCF UIR, 6, ACCESS
720:           
721:                   #if defined(__XC8__) || defined(__C18__)
722:                       USBIncrement1msInternalTimers();
0CE8  ECCF     CALL 0x259E, 0
0CEA  F012     NOP
723:                   #endif
724:           
725:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
726:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
727:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
728:                           #warning "Double click this message.  See inline code comments."
729:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
730:                           //not strictly needed in all applications (ex: those that never call 
731:                           //USBDeferStatusStage() and don't use host to device (OUT) control
732:                           //transfers with data stage).  
733:                           //However, if this feature is enabled and used in a low speed application,
734:                           //it is required for the application code to periodically call the
735:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
736:                       #endif
737:                       
738:                       //Decrement our status stage counter.
739:                       if(USBStatusStageTimeoutCounter != 0u)
0CEC  501F     MOVF USBStatusStageTimeoutCounter, W, ACCESS
0CEE  B4D8     BTFSC STATUS, 2, ACCESS
0CF0  EF7C     GOTO 0xCF8
0CF2  F006     NOP
0CF4  EF7E     GOTO 0xCFC
0CF6  F006     NOP
0CF8  EF7F     GOTO 0xCFE
0CFA  F006     NOP
740:                       {
741:                           USBStatusStageTimeoutCounter--;
0CFC  061F     DECF USBStatusStageTimeoutCounter, F, ACCESS
742:                       }
743:                       //Check if too much time has elapsed since progress was made in 
744:                       //processing the control transfer, without arming the status stage.  
745:                       //If so, auto-arm the status stage to ensure that the control 
746:                       //transfer can [eventually] complete, within the timing limits
747:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
748:                       if(USBStatusStageTimeoutCounter == 0)
0CFE  501F     MOVF USBStatusStageTimeoutCounter, W, ACCESS
0D00  A4D8     BTFSS STATUS, 2, ACCESS
0D02  EF85     GOTO 0xD0A
0D04  F006     NOP
0D06  EF87     GOTO 0xD0E
0D08  F006     NOP
0D0A  EF89     GOTO 0xD12
0D0C  F006     NOP
749:                       {
750:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
0D0E  EC05     CALL 0x1E0A, 0
0D10  F00F     NOP
751:                       } 
752:                   #endif
753:               }
754:           
755:               if(USBStallIF && USBStallIE)
0D12  AA65     BTFSS UIR, 5, ACCESS
0D14  EF8E     GOTO 0xD1C
0D16  F006     NOP
0D18  EF90     GOTO 0xD20
0D1A  F006     NOP
0D1C  EF99     GOTO 0xD32
0D1E  F006     NOP
0D20  AA64     BTFSS UIE, 5, ACCESS
0D22  EF95     GOTO 0xD2A
0D24  F006     NOP
0D26  EF97     GOTO 0xD2E
0D28  F006     NOP
0D2A  EF99     GOTO 0xD32
0D2C  F006     NOP
756:               {
757:                   USBStallHandler();
0D2E  ECF1     CALL 0x23E2, 0
0D30  F011     NOP
758:               }
759:           
760:               if(USBErrorIF && USBErrorIE)
0D32  A265     BTFSS UIR, 1, ACCESS
0D34  EF9E     GOTO 0xD3C
0D36  F006     NOP
0D38  EFA0     GOTO 0xD40
0D3A  F006     NOP
0D3C  EFB6     GOTO 0xD6C
0D3E  F006     NOP
0D40  A264     BTFSS UIE, 1, ACCESS
0D42  EFA5     GOTO 0xD4A
0D44  F006     NOP
0D46  EFA7     GOTO 0xD4E
0D48  F006     NOP
0D4A  EFB6     GOTO 0xD6C
0D4C  F006     NOP
761:               {
762:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
0D4E  0E7F     MOVLW 0x7F
0D50  6E39     MOVWF 0x39, ACCESS
0D52  6838     SETF USBDeviceInit, ACCESS
0D54  0E00     MOVLW 0x0
0D56  6E3A     MOVWF pdata, ACCESS
0D58  0E00     MOVLW 0x0
0D5A  6E3B     MOVWF 0x3B, ACCESS
0D5C  0E00     MOVLW 0x0
0D5E  6E3D     MOVWF 0x3D, ACCESS
0D60  0E01     MOVLW 0x1
0D62  6E3C     MOVWF size, ACCESS
0D64  EC41     CALL 0x2282, 0
0D66  F011     NOP
763:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
0D68  0E00     MOVLW 0x0
0D6A  6E67     MOVWF UEIR, ACCESS
764:           
765:                   //On PIC18, clearing the source of the error will automatically clear
766:                   //  the interrupt flag.  On other devices the interrupt flag must be 
767:                   //  manually cleared. 
768:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
769:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
770:                   #endif
771:               }
772:           
773:               /*
774:                * Pointless to continue servicing if the host has not sent a bus reset.
775:                * Once bus reset is received, the device transitions into the DEFAULT
776:                * state and is ready for communication.
777:                */
778:               if(USBDeviceState < DEFAULT_STATE)
0D6C  0E04     MOVLW 0x4
0D6E  6029     CPFSLT USBDeviceState, ACCESS
0D70  EFBC     GOTO 0xD78
0D72  F006     NOP
0D74  EFBE     GOTO 0xD7C
0D76  F006     NOP
0D78  EFC1     GOTO 0xD82
0D7A  F006     NOP
779:               {
780:                   USBClearUSBInterrupt();
0D7C  94A4     BCF PIR3, 2, ACCESS
781:                   return;
0D7E  EF16     GOTO 0xE2C
0D80  F007     NOP
782:               }  
783:           
784:               /*
785:                * Task D: Servicing USB Transaction Complete Interrupt
786:                */
787:               if(USBTransactionCompleteIE)
0D82  A664     BTFSS UIE, 3, ACCESS
0D84  EFC6     GOTO 0xD8C
0D86  F006     NOP
0D88  EFC8     GOTO 0xD90
0D8A  F006     NOP
0D8C  EF15     GOTO 0xE2A
0D8E  F007     NOP
788:               {
789:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
0D90  0E00     MOVLW 0x0
0D92  6E4A     MOVWF i, ACCESS
790:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
791:                       if(USBTransactionCompleteIF)
0D94  A665     BTFSS UIR, 3, ACCESS
0D96  EFCF     GOTO 0xD9E
0D98  F006     NOP
0D9A  EFD1     GOTO 0xDA2
0D9C  F006     NOP
0D9E  EF15     GOTO 0xE2A
0DA0  F007     NOP
792:                       {
793:                           //Save and extract USTAT register info.  Will use this info later.
794:                           USTATcopy.Val = U1STAT;
0DA2  CF61     MOVFF USTAT, USTATcopy
0DA4  F02A     NOP
795:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
0DA6  302A     RRCF USTATcopy, W, ACCESS
0DA8  32E8     RRCF WREG, F, ACCESS
0DAA  32E8     RRCF WREG, F, ACCESS
0DAC  0B0F     ANDLW 0xF
0DAE  6E21     MOVWF endpoint_number, ACCESS
796:           
797:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0DB0  9665     BCF UIR, 3, ACCESS
798:           
799:                           //Keep track of the hardware ping pong state for endpoints other
800:                           //than EP0, if ping pong buffering is enabled.
801:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
802:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
0DB2  B42A     BTFSC USTATcopy, 2, ACCESS
0DB4  EFDE     GOTO 0xDBC
0DB6  F006     NOP
0DB8  EFE0     GOTO 0xDC0
0DBA  F006     NOP
0DBC  EFEA     GOTO 0xDD4
0DBE  F006     NOP
803:                           {
804:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
0DC0  0E78     MOVLW 0x78
0DC2  2421     ADDWF endpoint_number, W, ACCESS
0DC4  6ED9     MOVWF FSR2, ACCESS
0DC6  6ADA     CLRF FSR2H, ACCESS
0DC8  0E00     MOVLW 0x0
0DCA  22DA     ADDWFC FSR2H, F, ACCESS
0DCC  0100     MOVLB 0x0
0DCE  70DF     BTG INDF2, 0, ACCESS
805:                           }
0DD0  EFF2     GOTO 0xDE4
0DD2  F006     NOP
806:                           else
807:                           {
808:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
0DD4  0E7B     MOVLW 0x7B
0DD6  2421     ADDWF endpoint_number, W, ACCESS
0DD8  6ED9     MOVWF FSR2, ACCESS
0DDA  6ADA     CLRF FSR2H, ACCESS
0DDC  0E00     MOVLW 0x0
0DDE  22DA     ADDWFC FSR2H, F, ACCESS
0DE0  0100     MOVLB 0x0
0DE2  70DF     BTG INDF2, 0, ACCESS
809:                           }
810:                           #endif
811:           
812:                           //USBCtrlEPService only services transactions over EP0.
813:                           //It ignores all other EP transactions.
814:                           if(endpoint_number == 0)
0DE4  5021     MOVF endpoint_number, W, ACCESS
0DE6  A4D8     BTFSS STATUS, 2, ACCESS
0DE8  EFF8     GOTO 0xDF0
0DEA  F006     NOP
0DEC  EFFA     GOTO 0xDF4
0DEE  F006     NOP
0DF0  EFFE     GOTO 0xDFC
0DF2  F006     NOP
815:                           {
816:                               USBCtrlEPService();
0DF4  ECF0     CALL 0x1FE0, 0
0DF6  F00F     NOP
817:                           }
0DF8  EF0C     GOTO 0xE18
0DFA  F007     NOP
818:                           else
819:                           {
820:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
0DFC  0E00     MOVLW 0x0
0DFE  6E39     MOVWF 0x39, ACCESS
0E00  0E72     MOVLW 0x72
0E02  6E38     MOVWF USBDeviceInit, ACCESS
0E04  0E2A     MOVLW 0x2A
0E06  6E3A     MOVWF pdata, ACCESS
0E08  0E00     MOVLW 0x0
0E0A  6E3B     MOVWF 0x3B, ACCESS
0E0C  0E00     MOVLW 0x0
0E0E  6E3D     MOVWF 0x3D, ACCESS
0E10  0E00     MOVLW 0x0
0E12  6E3C     MOVWF size, ACCESS
0E14  EC41     CALL 0x2282, 0
0E16  F011     NOP
821:                           }
822:                       }//end if(USBTransactionCompleteIF)
823:                       else
824:                       {
825:                           break;	//USTAT FIFO must be empty.
826:                       }
827:                   }//end for()
0E18  2A4A     INCF i, F, ACCESS
0E1A  0E03     MOVLW 0x3
0E1C  644A     CPFSGT i, ACCESS
0E1E  EF13     GOTO 0xE26
0E20  F007     NOP
0E22  EF15     GOTO 0xE2A
0E24  F007     NOP
0E26  EFCA     GOTO 0xD94
0E28  F006     NOP
828:               }//end if(USBTransactionCompleteIE)
829:           
830:               USBClearUSBInterrupt();
0E2A  94A4     BCF PIR3, 2, ACCESS
831:           }//end of USBDeviceTasks()
0E2C  0012     RETURN 0
832:           
833:           /*******************************************************************************
834:             Function:
835:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
836:               
837:             Summary:
838:               This function will enable the specified endpoint with the specified
839:               options
840:             Description:
841:               This function will enable the specified endpoint with the specified
842:               options.
843:               
844:               Typical Usage:
845:               <code>
846:               void USBCBInitEP(void)
847:               {
848:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
849:                   USBMSDInit();
850:               }
851:               </code>
852:               
853:               In the above example endpoint number MSD_DATA_IN_EP is being configured
854:               for both IN and OUT traffic with handshaking enabled. Also since
855:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
856:               explicitly disable SETUP packets on this endpoint.
857:             Conditions:
858:               None
859:             Input:
860:               uint8_t ep -       the endpoint to be configured
861:               uint8_t options -  optional settings for the endpoint. The options should
862:                               be ORed together to form a single options string. The
863:                               available optional settings for the endpoint. The
864:                               options should be ORed together to form a single options
865:                               string. The available options are the following\:
866:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
867:                                 NAK)
868:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
869:                                 NAK)
870:                               * USB_OUT_ENABLED enables the out direction
871:                               * USB_OUT_DISABLED disables the out direction
872:                               * USB_IN_ENABLED enables the in direction
873:                               * USB_IN_DISABLED disables the in direction
874:                               * USB_ALLOW_SETUP enables control transfers
875:                               * USB_DISALLOW_SETUP disables control transfers
876:                               * USB_STALL_ENDPOINT STALLs this endpoint
877:             Return:
878:               None
879:             Remarks:
880:               None                                                                                                          
881:             *****************************************************************************/
882:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
2492  6E37     MOVWF ep, ACCESS
883:           {
884:               unsigned char* p;
885:                   
886:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
887:               //starting DTS state in the BDT entry.
888:               if(options & USB_OUT_ENABLED)
2494  A434     BTFSS ep, 2, ACCESS
2496  EF4F     GOTO 0x249E
2498  F012     NOP
249A  EF51     GOTO 0x24A2
249C  F012     NOP
249E  EF56     GOTO 0x24AC
24A0  F012     NOP
889:               {
890:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
24A2  0E00     MOVLW 0x0
24A4  6E2C     MOVWF __pcstackCOMRAM, ACCESS
24A6  5037     MOVF ep, W, ACCESS
24A8  ECA3     CALL 0x2146, 0
24AA  F010     NOP
891:               }
892:               if(options & USB_IN_ENABLED)
24AC  A234     BTFSS ep, 1, ACCESS
24AE  EF5B     GOTO 0x24B6
24B0  F012     NOP
24B2  EF5D     GOTO 0x24BA
24B4  F012     NOP
24B6  EF62     GOTO 0x24C4
24B8  F012     NOP
893:               {
894:                   USBConfigureEndpoint(ep, IN_TO_HOST);
24BA  0E01     MOVLW 0x1
24BC  6E2C     MOVWF __pcstackCOMRAM, ACCESS
24BE  5037     MOVF ep, W, ACCESS
24C0  ECA3     CALL 0x2146, 0
24C2  F010     NOP
895:               }
896:           
897:               //Update the relevant UEPx register to actually enable the endpoint with
898:               //the specified options (ex: handshaking enabled, control transfers allowed,
899:               //etc.)
900:               #if defined(__C32__)
901:                   p = (unsigned char*)(&U1EP0+(4*ep));
902:               #else
903:                   p = (unsigned char*)(&U1EP0+ep);
24C4  0E6A     MOVLW 0x6A
24C6  2437     ADDWF ep, W, ACCESS
24C8  6E35     MOVWF handle, ACCESS
24CA  6A36     CLRF tmp, ACCESS
24CC  0E0F     MOVLW 0xF
24CE  2236     ADDWFC tmp, F, ACCESS
904:               #endif
905:               *p = options;
24D0  C035     MOVFF handle, FSR2
24D2  FFD9     NOP
24D4  C036     MOVFF tmp, FSR2H
24D6  FFDA     NOP
24D8  C034     MOVFF ep, INDF2
24DA  FFDF     NOP
906:           }
24DC  0012     RETURN 0
907:           
908:           
909:           /*************************************************************************
910:             Function:
911:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
912:               
913:             Summary:
914:               Transfers a single packet (one transaction) of data on the USB bus.
915:           
916:             Description:
917:               The USBTransferOnePacket() function prepares a USB endpoint
918:               so that it may send data to the host (an IN transaction), or 
919:               receive data from the host (an OUT transaction).  The 
920:               USBTransferOnePacket() function can be used both to receive	and 
921:               send data to the host.  This function is the primary API function 
922:               provided by the USB stack firmware for sending or receiving application 
923:               data over the USB port.  
924:           
925:               The USBTransferOnePacket() is intended for use with all application 
926:               endpoints.  It is not used for sending or receiving application data 
927:               through endpoint 0 by using control transfers.  Separate API 
928:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
929:               USBEP0SendROMPtr() are provided for this purpose.
930:           
931:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
932:               entry associated with an endpoint buffer, and sets the UOWN bit, which 
933:               prepares the USB hardware to allow the transaction to complete.  The 
934:               application firmware can use the USBHandleBusy() macro to check the 
935:               status of the transaction, to see if the data has been successfully 
936:               transmitted yet.
937:           
938:           
939:               Typical Usage
940:               <code>
941:               //make sure that the we are in the configured state
942:               if(USBGetDeviceState() == CONFIGURED_STATE)
943:               {
944:                   //make sure that the last transaction isn't busy by checking the handle
945:                   if(!USBHandleBusy(USBInHandle))
946:                   {
947:           	        //Write the new data that we wish to send to the host to the INPacket[] array
948:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
949:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
950:           	        //INPacket[2] = ... (fill in the rest of the packet data)
951:           	      
952:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
953:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
954:                   }
955:               }
956:               </code>
957:           
958:             Conditions:
959:               Before calling USBTransferOnePacket(), the following should be true.
960:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
961:               2.  A transaction is not already pending on the specified endpoint.  This
962:                   is done by checking the previous request using the USBHandleBusy() 
963:                   macro (see the typical usage example).
964:               3.  The host has already sent a set configuration request and the 
965:                   enumeration process is complete.
966:                   This can be checked by verifying that the USBGetDeviceState() 
967:                   macro returns "CONFIGURED_STATE", prior to calling 
968:                   USBTransferOnePacket().
969:            					
970:             Input:
971:               uint8_t ep - The endpoint number that the data will be transmitted or
972:           	          received on
973:               uint8_t dir - The direction of the transfer
974:                          This value is either OUT_FROM_HOST or IN_TO_HOST
975:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
976:                            the data to be sent to the host.  For OUT transactions: pointer
977:                            to the RAM buffer that the received data should get written to.
978:              uint8_t len - Length of the data needing to be sent (for IN transactions).
979:                         For OUT transactions, the len parameter should normally be set
980:                         to the endpoint size specified in the endpoint descriptor.    
981:           
982:             Return Values:
983:               USB_HANDLE - handle to the transfer.  The handle is a pointer to 
984:                            the BDT entry associated with this transaction.  The
985:                            status of the transaction (ex: if it is complete or still
986:                            pending) can be checked using the USBHandleBusy() macro
987:                            and supplying the USB_HANDLE provided by
988:                            USBTransferOnePacket().
989:           
990:             Remarks:
991:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
992:               callback function, the set configuration is still being processed and the
993:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
994:               the USBTransferOnePacket() may still be called, but make sure that the 
995:               endpoint has been enabled and initialized by the USBEnableEndpoint() 
996:               function first.  
997:               
998:             *************************************************************************/
999:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
1798  6E34     MOVWF ep, ACCESS
1000:          {
1001:              volatile BDT_ENTRY* handle;
1002:          
1003:              //If the direction is IN
1004:              if(dir != 0)
179A  502C     MOVF __pcstackCOMRAM, W, ACCESS
179C  B4D8     BTFSC STATUS, 2, ACCESS
179E  EFD3     GOTO 0x17A6
17A0  F00B     NOP
17A2  EFD5     GOTO 0x17AA
17A4  F00B     NOP
17A6  EFE3     GOTO 0x17C6
17A8  F00B     NOP
1005:              {
1006:                  //point to the IN BDT of the specified endpoint
1007:                  handle = pBDTEntryIn[ep];
17AA  5034     MOVF ep, W, ACCESS
17AC  0D02     MULLW 0x2
17AE  0E09     MOVLW 0x9
17B0  24F3     ADDWF PROD, W, ACCESS
17B2  6ED9     MOVWF FSR2, ACCESS
17B4  0E00     MOVLW 0x0
17B6  20F4     ADDWFC PRODH, W, ACCESS
17B8  6EDA     MOVWF FSR2H, ACCESS
17BA  CFDE     MOVFF POSTINC2, handle
17BC  F035     NOP
17BE  CFDD     MOVFF POSTDEC2, tmp
17C0  F036     NOP
1008:              }
17C2  EFEF     GOTO 0x17DE
17C4  F00B     NOP
1009:              else
1010:              {
1011:                  //else point to the OUT BDT of the specified endpoint
1012:                  handle = pBDTEntryOut[ep];
17C6  5034     MOVF ep, W, ACCESS
17C8  0D02     MULLW 0x2
17CA  0E6A     MOVLW 0x6A
17CC  24F3     ADDWF PROD, W, ACCESS
17CE  6ED9     MOVWF FSR2, ACCESS
17D0  0E00     MOVLW 0x0
17D2  20F4     ADDWFC PRODH, W, ACCESS
17D4  6EDA     MOVWF FSR2H, ACCESS
17D6  CFDE     MOVFF POSTINC2, handle
17D8  F035     NOP
17DA  CFDD     MOVFF POSTDEC2, tmp
17DC  F036     NOP
1013:              }
1014:              
1015:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1016:              //pBDTEntryOut[ep]) is initialized before using it.
1017:              if(handle == 0)
17DE  5035     MOVF handle, W, ACCESS
17E0  1036     IORWF tmp, W, ACCESS
17E2  A4D8     BTFSS STATUS, 2, ACCESS
17E4  EFF6     GOTO 0x17EC
17E6  F00B     NOP
17E8  EFF8     GOTO 0x17F0
17EA  F00B     NOP
17EC  EFFE     GOTO 0x17FC
17EE  F00B     NOP
1018:              {
1019:                  return 0;
17F0  0E00     MOVLW 0x0
17F2  6E2C     MOVWF __pcstackCOMRAM, ACCESS
17F4  0E00     MOVLW 0x0
17F6  6E2D     MOVWF data, ACCESS
17F8  EF6A     GOTO 0x18D4
17FA  F00C     NOP
1020:              }
1021:          
1022:              //Toggle the DTS bit if required
1023:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1024:                  handle->STAT.Val ^= _DTSMASK;
1025:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1026:                  if(ep != 0)
1027:                  {
1028:                      handle->STAT.Val ^= _DTSMASK;
1029:                  }
1030:              #endif
1031:          
1032:              //Set the data pointer, data length, and enable the endpoint
1033:              handle->ADR = ConvertToPhysicalAddress(data);
17FC  EE20     LFSR 2, 0x2
17FE  F002     NOP
1800  5035     MOVF handle, W, ACCESS
1802  26D9     ADDWF FSR2, F, ACCESS
1804  5036     MOVF tmp, W, ACCESS
1806  22DA     ADDWFC FSR2H, F, ACCESS
1808  C02D     MOVFF data, POSTINC2
180A  FFDE     NOP
180C  C02E     MOVFF p, POSTDEC2
180E  FFDD     NOP
1034:              handle->CNT = len;
1810  EE20     LFSR 2, 0x1
1812  F001     NOP
1814  5035     MOVF handle, W, ACCESS
1816  26D9     ADDWF FSR2, F, ACCESS
1818  5036     MOVF tmp, W, ACCESS
181A  22DA     ADDWFC FSR2H, F, ACCESS
181C  C02F     MOVFF len, INDF2
181E  FFDF     NOP
1035:              handle->STAT.Val &= _DTSMASK;
1820  C035     MOVFF handle, FSR2
1822  FFD9     NOP
1824  C036     MOVFF tmp, FSR2H
1826  FFDA     NOP
1828  0E40     MOVLW 0x40
182A  16DF     ANDWF INDF2, F, ACCESS
1036:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
182C  C035     MOVFF handle, FSR2
182E  FFD9     NOP
1830  C036     MOVFF tmp, FSR2H
1832  FFDA     NOP
1834  0E00     MOVLW 0x0
1836  86DB     BSF PLUSW2, 3, ACCESS
1037:              handle->STAT.Val |= _USIE;
1838  C035     MOVFF handle, FSR2
183A  FFD9     NOP
183C  C036     MOVFF tmp, FSR2H
183E  FFDA     NOP
1840  0E00     MOVLW 0x0
1842  8EDB     BSF PLUSW2, 7, ACCESS
1038:          
1039:              //Point to the next buffer for ping pong purposes.
1040:              if(dir != OUT_FROM_HOST)
1844  502C     MOVF __pcstackCOMRAM, W, ACCESS
1846  B4D8     BTFSC STATUS, 2, ACCESS
1848  EF28     GOTO 0x1850
184A  F00C     NOP
184C  EF2A     GOTO 0x1854
184E  F00C     NOP
1850  EF49     GOTO 0x1892
1852  F00C     NOP
1041:              {
1042:                  //toggle over the to the next buffer for an IN endpoint
1043:                  pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
1854  5034     MOVF ep, W, ACCESS
1856  0D02     MULLW 0x2
1858  0E09     MOVLW 0x9
185A  24F3     ADDWF PROD, W, ACCESS
185C  6ED9     MOVWF FSR2, ACCESS
185E  0E00     MOVLW 0x0
1860  20F4     ADDWFC PRODH, W, ACCESS
1862  6EDA     MOVWF FSR2H, ACCESS
1864  CFDE     MOVFF POSTINC2, n
1866  F030     NOP
1868  CFDD     MOVFF POSTDEC2, EPNum
186A  F031     NOP
186C  0E04     MOVLW 0x4
186E  1830     XORWF n, W, ACCESS
1870  6E32     MOVWF handle, ACCESS
1872  5031     MOVF EPNum, W, ACCESS
1874  6E33     MOVWF 0x33, ACCESS
1876  5034     MOVF ep, W, ACCESS
1878  0D02     MULLW 0x2
187A  0E09     MOVLW 0x9
187C  24F3     ADDWF PROD, W, ACCESS
187E  6ED9     MOVWF FSR2, ACCESS
1880  0E00     MOVLW 0x0
1882  20F4     ADDWFC PRODH, W, ACCESS
1884  6EDA     MOVWF FSR2H, ACCESS
1886  C032     MOVFF handle, POSTINC2
1888  FFDE     NOP
188A  C033     MOVFF 0x33, POSTDEC2
188C  FFDD     NOP
1044:              }
188E  EF66     GOTO 0x18CC
1890  F00C     NOP
1045:              else
1046:              {
1047:                  //toggle over the to the next buffer for an OUT endpoint
1048:                  pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
1892  5034     MOVF ep, W, ACCESS
1894  0D02     MULLW 0x2
1896  0E6A     MOVLW 0x6A
1898  24F3     ADDWF PROD, W, ACCESS
189A  6ED9     MOVWF FSR2, ACCESS
189C  0E00     MOVLW 0x0
189E  20F4     ADDWFC PRODH, W, ACCESS
18A0  6EDA     MOVWF FSR2H, ACCESS
18A2  CFDE     MOVFF POSTINC2, n
18A4  F030     NOP
18A6  CFDD     MOVFF POSTDEC2, EPNum
18A8  F031     NOP
18AA  0E04     MOVLW 0x4
18AC  1830     XORWF n, W, ACCESS
18AE  6E32     MOVWF handle, ACCESS
18B0  5031     MOVF EPNum, W, ACCESS
18B2  6E33     MOVWF 0x33, ACCESS
18B4  5034     MOVF ep, W, ACCESS
18B6  0D02     MULLW 0x2
18B8  0E6A     MOVLW 0x6A
18BA  24F3     ADDWF PROD, W, ACCESS
18BC  6ED9     MOVWF FSR2, ACCESS
18BE  0E00     MOVLW 0x0
18C0  20F4     ADDWFC PRODH, W, ACCESS
18C2  6EDA     MOVWF FSR2H, ACCESS
18C4  C032     MOVFF handle, POSTINC2
18C6  FFDE     NOP
18C8  C033     MOVFF 0x33, POSTDEC2
18CA  FFDD     NOP
1049:              }
1050:              return (USB_HANDLE)handle;
18CC  C035     MOVFF handle, __pcstackCOMRAM
18CE  F02C     NOP
18D0  C036     MOVFF tmp, data
18D2  F02D     NOP
1051:          }
18D4  0012     RETURN 0
1052:          
1053:          
1054:          /********************************************************************
1055:              Function:
1056:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1057:                  
1058:              Summary:
1059:                   Configures the specified endpoint to send STALL to the host, the next
1060:                   time the host tries to access the endpoint.
1061:              
1062:              PreCondition:
1063:                  None
1064:                  
1065:              Parameters:
1066:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1067:                  uint8_t dir - The direction of the endpoint to STALL, either
1068:                             IN_TO_HOST or OUT_FROM_HOST.
1069:                  
1070:              Return Values:
1071:                  None
1072:                  
1073:              Remarks:
1074:                  None
1075:          
1076:           *******************************************************************/
1077:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
1078:          {
1079:              BDT_ENTRY *p;
1080:          
1081:              if(ep == 0)
1082:              {
1083:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1084:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1085:                  //packet that will arrive.
1086:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1087:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1088:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1089:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1090:                  pBDTEntryIn[0]->STAT.Val = _BSTALL; 
1091:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1092:                         
1093:              }
1094:              else
1095:              {
1096:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1097:                  p->STAT.Val |= _BSTALL;
1098:                  p->STAT.Val |= _USIE;
1099:              
1100:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1101:                  //then stall that entry as well
1102:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1103:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1104:                  p->STAT.Val |= _BSTALL;
1105:                  p->STAT.Val |= _USIE;
1106:                  #endif
1107:              }
1108:          }
1109:          
1110:          /**************************************************************************
1111:              Function:
1112:                  void USBCancelIO(uint8_t endpoint)
1113:              
1114:              Description:
1115:                  This function cancels the transfers pending on the specified endpoint.
1116:                  This function can only be used after a SETUP packet is received and 
1117:                  before that setup packet is handled.  This is the time period in which
1118:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1119:                  returns to the stack.
1120:          
1121:              Precondition:
1122:            
1123:              Parameters:
1124:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1125:               
1126:              Return Values:
1127:                  None
1128:                  
1129:              Remarks:
1130:                  None
1131:                                                                    
1132:            **************************************************************************/
1133:          void USBCancelIO(uint8_t endpoint)
1134:          {
1135:              if(USBPacketDisable == 1)
1136:              {
1137:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1138:              	//to mess with the BDT right now.
1139:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1140:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1141:              	
1142:              	//Need to do additional handling if ping-pong buffering is being used
1143:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1144:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1145:                  //(either due to SIE clearing it after a transaction, or the firmware
1146:                  //clearing it) makes hardware ping pong pointer advance.
1147:                  pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
1148:                  
1149:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1150:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1151:                  #endif
1152:              }
1153:          }
1154:          
1155:          /**************************************************************************
1156:              Function:
1157:                  void USBDeviceDetach(void)
1158:             
1159:              Summary:
1160:                  This function configures the USB module to "soft detach" itself from
1161:                  the USB host.
1162:                  
1163:              Description:
1164:                  This function configures the USB module to perform a "soft detach"
1165:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1166:                  lets the host know the device is present and attached.  This will make
1167:                  the host think that the device has been unplugged.  This is potentially
1168:                  useful, as it allows the USB device to force the host to re-enumerate
1169:                  the device (on the firmware has re-enabled the USB module/pull up, by
1170:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1171:                  
1172:              Precondition:
1173:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1174:                  section if USB_POLLING mode option is being used (usb_device_config.h option).
1175:          
1176:                  Additionally, this function should only be called from the main() loop 
1177:                  context.  Do not call this function from within an interrupt handler, as 
1178:                  this function may modify global interrupt enable bits and settings.
1179:                  
1180:              Parameters:
1181:                  None
1182:               
1183:              Return Values:
1184:                  None
1185:                  
1186:              Remarks:
1187:                  If the application firmware calls USBDeviceDetach(), it is strongly
1188:                  recommended that the firmware wait at least >= 80ms before calling
1189:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1190:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1191:                  hosts may interpret this as an unexpected "glitch" rather than as a
1192:                  physical removal/re-attachment of the USB device.  In this case the host
1193:                  may simply ignore the event without re-enumerating the device.  To 
1194:                  ensure that the host properly detects and processes the device soft
1195:                  detach/re-attach, it is recommended to make sure the device remains 
1196:                  detached long enough to mimic a real human controlled USB 
1197:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1198:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1199:                  
1200:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1201:                  or take long to execute.  It is the application firmwares 
1202:                  responsibility for adding the 80+ms delay, when using these API 
1203:                  functions.
1204:                  
1205:                  Note: The Windows plug and play event handler processing is fairly 
1206:                  slow, especially in certain versions of Windows, and for certain USB
1207:                  device classes.  It has been observed that some device classes need to
1208:                  provide even more USB detach dwell interval (before calling 
1209:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1210:                  If the USB device is a CDC class device, it is recommended to wait
1211:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1212:                  to provide the plug and play event handler enough time to finish 
1213:                  processing the removal event, before the re-attach occurs.
1214:                  
1215:                  If the application is using the USB_POLLING mode option, then the 
1216:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1217:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1218:                  and "#define USB_BUS_SENSE" options in the 
1219:                  HardwareProfile ?? [platform name].h file. 
1220:          
1221:                  When using the USB_POLLING mode option, and the 
1222:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1223:                  the USB stack assumes that it should always enable the USB module at 
1224:                  pretty much all times.  Basically, anytime the application firmware 
1225:                  calls USBDeviceTasks(), the firmware will automatically enable the USB 
1226:                  module.  This mode would typically be selected if the application was 
1227:                  designed to be a purely bus powered device.  In this case, the 
1228:                  application is powered from the +5V VBUS supply from the USB port, so 
1229:                  it is correct and sensible in this type of application to power up and 
1230:                  turn on the USB module, at anytime that the microcontroller is 
1231:                  powered (which implies the USB cable is attached and the host is also 
1232:                  powered).
1233:          
1234:                  In a self powered application, the USB stack is designed with the 
1235:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1236:                  option in the HardwareProfile ?? [platform name].h file.  When this 
1237:                  option is defined, then the USBDeviceTasks() function will automatically 
1238:                  check the I/O pin port value of the designated pin (based on the 
1239:                  #define USB_BUS_SENSE option in the HardwareProfile ?? [platform name].h 
1240:                  file), every time the application calls USBDeviceTasks().  If the 
1241:                  USBDeviceTasks() function is executed and finds that the pin defined by 
1242:                  the #define USB_BUS_SENSE is in a logic low state, then it will 
1243:                  automatically disable the USB module and tri-state the D+ and D- pins.  
1244:                  If however the USBDeviceTasks() function is executed and finds the pin 
1245:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1246:                  will automatically enable the USB module, if it has not already been 
1247:                  enabled.        
1248:                                                                    
1249:            **************************************************************************/
1250:          #if defined(USB_INTERRUPT)
1251:          void USBDeviceDetach(void)
1252:          {
1253:              //If the interrupt option is selected then the customer is required
1254:              //  to notify the stack when the device is attached or removed from the
1255:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1256:          #ifdef USB_SUPPORT_OTG
1257:              if (USB_BUS_SENSE != 1)
1258:          #endif
1259:              {
1260:                   // Disable module & detach from bus
1261:                   U1CON = 0;             
1262:          
1263:                   // Mask all USB interrupts              
1264:                   U1IE = 0;          
1265:          
1266:                   //Move to the detached state                  
1267:                   USBDeviceState = DETACHED_STATE;
1268:          
1269:                   #ifdef  USB_SUPPORT_OTG    
1270:                       //Disable D+ Pull-up
1271:                       U1OTGCONbits.DPPULUP = 0;
1272:          
1273:                       //Disable HNP
1274:                       USBOTGDisableHnp();
1275:          
1276:                       //Deactivate HNP
1277:                       USBOTGDeactivateHnp();
1278:                       
1279:                       //If ID Pin Changed State
1280:                       if (USBIDIF && USBIDIE)
1281:                       {  
1282:                           //Re-detect & Initialize
1283:                            USBOTGInitialize();
1284:          
1285:                            //Clear ID Interrupt Flag
1286:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1287:                       }
1288:                   #endif
1289:          
1290:                   #if defined __C30__ || defined __XC16__
1291:                       //USBClearInterruptFlag(U1OTGIR, 3); 
1292:                   #endif
1293:                      //return so that we don't go through the rest of 
1294:                      //the state machine
1295:                    return;
1296:              }
1297:          
1298:          #ifdef USB_SUPPORT_OTG
1299:              //If Session Is Started Then
1300:             else
1301:             {
1302:                  //If SRP Is Ready
1303:                  if (USBOTGSRPIsReady())
1304:                  {   
1305:                      //Clear SRPReady
1306:                      USBOTGClearSRPReady();
1307:          
1308:                      //Clear SRP Timeout Flag
1309:                      USBOTGClearSRPTimeOutFlag();
1310:          
1311:                      //Indicate Session Started
1312:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1313:                  }
1314:              }
1315:          #endif
1316:          }
1317:          #endif  //#if defined(USB_INTERRUPT)
1318:          /**************************************************************************
1319:              Function:
1320:                  void USBDeviceAttach(void)
1321:              
1322:              Summary:
1323:                  Checks if VBUS is present, and that the USB module is not already 
1324:                  initialized, and if so, enables the USB module so as to signal device 
1325:                  attachment to the USB host.   
1326:          
1327:              Description:
1328:                  This function indicates to the USB host that the USB device has been
1329:                  attached to the bus.  This function needs to be called in order for the
1330:                  device to start to enumerate on the bus.
1331:                          
1332:              Precondition:
1333:                  Should only be called when USB_INTERRUPT is defined.  Also, should only 
1334:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1335:                  from within an interrupt handler, as the USBDeviceAttach() function
1336:                  may modify global interrupt enable bits and settings.
1337:          
1338:                  For normal USB devices:
1339:                  Make sure that if the module was previously on, that it has been turned off 
1340:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1341:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1342:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1343:                  reject this event, since no human could ever unplug and re-attach a USB device in a 
1344:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1345:                  of glitch and ignore the event altogether.  
1346:              Parameters:
1347:                  None
1348:               
1349:              Return Values:
1350:                  None       
1351:              
1352:              Remarks: 
1353:          		See also the USBDeviceDetach() API function documentation.                                                 
1354:          ****************************************************************************/
1355:          #if defined(USB_INTERRUPT)
1356:          void USBDeviceAttach(void)
1357:          {
1358:              //if we are in the detached state
1359:              if(USBDeviceState == DETACHED_STATE)
24DE  5029     MOVF USBDeviceState, W, ACCESS
24E0  A4D8     BTFSS STATUS, 2, ACCESS
24E2  EF75     GOTO 0x24EA
24E4  F012     NOP
24E6  EF77     GOTO 0x24EE
24E8  F012     NOP
24EA  EF8F     GOTO 0x251E
24EC  F012     NOP
1360:              {
1361:                  if(USB_BUS_SENSE == 1)
1362:                  {
1363:              	    //Initialize registers to known states.
1364:                      U1CON = 0;          
24EE  0E00     MOVLW 0x0
24F0  6E60     MOVWF UCON, ACCESS
1365:              
1366:                      // Mask all USB interrupts
1367:                      U1IE = 0;                                
24F2  0E00     MOVLW 0x0
24F4  6E64     MOVWF UIE, ACCESS
1368:              
1369:                      //Configure things like: pull ups, full/low-speed mode, 
1370:                      //set the ping pong mode, and set internal transceiver
1371:                      SetConfigurationOptions();
24F6  0E16     MOVLW 0x16
24F8  6E62     MOVWF UCFG, ACCESS
24FA  0E9F     MOVLW 0x9F
24FC  6E66     MOVWF UEIE, ACCESS
24FE  0E7B     MOVLW 0x7B
2500  6E64     MOVWF UIE, ACCESS
1372:              
1373:                      USBEnableInterrupts();
2502  84A5     BSF IPR3, 2, ACCESS
2504  84A3     BSF PIE3, 2, ACCESS
1374:              
1375:                      // Enable module & attach to bus
1376:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
2506  EF86     GOTO 0x250C
2508  F012     NOP
250A  8660     BSF UCON, 3, ACCESS
250C  A660     BTFSS UCON, 3, ACCESS
250E  EF8B     GOTO 0x2516
2510  F012     NOP
2512  EF8D     GOTO 0x251A
2514  F012     NOP
2516  EF85     GOTO 0x250A
2518  F012     NOP
1377:              
1378:                      //moved to the attached state
1379:                      USBDeviceState = ATTACHED_STATE;
251A  0E01     MOVLW 0x1
251C  6E29     MOVWF USBDeviceState, ACCESS
1380:              
1381:                      #ifdef  USB_SUPPORT_OTG
1382:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1383:                      #endif
1384:                  }
1385:              }
1386:          }
251E  0012     RETURN 0
1387:          #endif  //#if defined(USB_INTERRUPT)
1388:          
1389:          
1390:          /*******************************************************************************
1391:            Function: void USBCtrlEPAllowStatusStage(void);
1392:          
1393:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1394:                      (based on the controlTransferState) to allow the status stage packet
1395:                      of a control transfer to complete.  This function gets used
1396:                      internally by the USB stack itself, but it may also be called from
1397:                      the application firmware, IF the application firmware called
1398:                      the USBDeferStatusStage() function during the initial processing
1399:                      of the control transfer request.  In this case, the application
1400:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1401:                      completed processing and handling the data stage portion of the
1402:                      request.
1403:          
1404:                      If the application firmware has no need for delaying control
1405:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1406:                      application firmware should not call USBCtrlEPAllowStatusStage().
1407:          
1408:            Description:
1409:          
1410:            Conditions:
1411:              None
1412:          
1413:            Input:
1414:          
1415:            Return:
1416:          
1417:            Remarks:
1418:              None
1419:            *****************************************************************************/
1420:          void USBCtrlEPAllowStatusStage(void)
1421:          {
1422:              //Check and set two flags, prior to actually modifying any BDT entries.
1423:              //This double checking is necessary to make certain that 
1424:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1425:              //in main loop context, while simultaneously getting an interrupt which 
1426:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1427:              if(USBStatusStageEnabledFlag1 == false)
1E0A  501D     MOVF USBStatusStageEnabledFlag1, W, ACCESS
1E0C  A4D8     BTFSS STATUS, 2, ACCESS
1E0E  EF0B     GOTO 0x1E16
1E10  F00F     NOP
1E12  EF0D     GOTO 0x1E1A
1E14  F00F     NOP
1E16  EF7C     GOTO 0x1EF8
1E18  F00F     NOP
1428:              {
1429:                  USBStatusStageEnabledFlag1 = true;
1E1A  0E01     MOVLW 0x1
1E1C  6E1D     MOVWF USBStatusStageEnabledFlag1, ACCESS
1430:                  if(USBStatusStageEnabledFlag2 == false)
1E1E  501C     MOVF USBStatusStageEnabledFlag2, W, ACCESS
1E20  A4D8     BTFSS STATUS, 2, ACCESS
1E22  EF15     GOTO 0x1E2A
1E24  F00F     NOP
1E26  EF17     GOTO 0x1E2E
1E28  F00F     NOP
1E2A  EF7C     GOTO 0x1EF8
1E2C  F00F     NOP
1431:                  {
1432:                      USBStatusStageEnabledFlag2 = true;
1E2E  0E01     MOVLW 0x1
1E30  6E1C     MOVWF USBStatusStageEnabledFlag2, ACCESS
1433:                  
1434:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1435:                      //stage), based on the type of control transfer currently pending.
1436:                      if(controlTransferState == CTRL_TRF_RX)
1E32  0E02     MOVLW 0x2
1E34  1824     XORWF controlTransferState, W, ACCESS
1E36  A4D8     BTFSS STATUS, 2, ACCESS
1E38  EF20     GOTO 0x1E40
1E3A  F00F     NOP
1E3C  EF22     GOTO 0x1E44
1E3E  F00F     NOP
1E40  EF38     GOTO 0x1E70
1E42  F00F     NOP
1437:                      {
1438:                          pBDTEntryIn[0]->CNT = 0;
1E44  EE20     LFSR 2, 0x1
1E46  F001     NOP
1E48  5009     MOVF pBDTEntryIn, W, ACCESS
1E4A  26D9     ADDWF FSR2, F, ACCESS
1E4C  500A     MOVF 0xA, W, ACCESS
1E4E  22DA     ADDWFC FSR2H, F, ACCESS
1E50  0E00     MOVLW 0x0
1E52  6EDF     MOVWF INDF2, ACCESS
1439:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
1E54  C009     MOVFF pBDTEntryIn, FSR2
1E56  FFD9     NOP
1E58  C00A     MOVFF 0xA, FSR2H
1E5A  FFDA     NOP
1E5C  0E48     MOVLW 0x48
1E5E  6EDF     MOVWF INDF2, ACCESS
1440:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
1E60  C009     MOVFF pBDTEntryIn, FSR2
1E62  FFD9     NOP
1E64  C00A     MOVFF 0xA, FSR2H
1E66  FFDA     NOP
1E68  0E00     MOVLW 0x0
1E6A  8EDB     BSF PLUSW2, 7, ACCESS
1441:                      }
1E6C  EF7C     GOTO 0x1EF8
1E6E  F00F     NOP
1442:                      else if(controlTransferState == CTRL_TRF_TX)
1E70  0424     DECF controlTransferState, W, ACCESS
1E72  A4D8     BTFSS STATUS, 2, ACCESS
1E74  EF3E     GOTO 0x1E7C
1E76  F00F     NOP
1E78  EF40     GOTO 0x1E80
1E7A  F00F     NOP
1E7C  EF7C     GOTO 0x1EF8
1E7E  F00F     NOP
1443:                      {
1444:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
1E80  0E00     MOVLW 0x0
1E82  6E20     MOVWF BothEP0OutUOWNsSet, ACCESS
1445:          
1446:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1447:                          //next SETUP packet.
1448:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1449:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
1E84  EE20     LFSR 2, 0x1
1E86  F001     NOP
1E88  5017     MOVF pBDTEntryEP0OutCurrent, W, ACCESS
1E8A  26D9     ADDWF FSR2, F, ACCESS
1E8C  5018     MOVF 0x18, W, ACCESS
1E8E  22DA     ADDWFC FSR2H, F, ACCESS
1E90  0E08     MOVLW 0x8
1E92  6EDF     MOVWF INDF2, ACCESS
1450:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
1E94  EE20     LFSR 2, 0x2
1E96  F002     NOP
1E98  5017     MOVF pBDTEntryEP0OutCurrent, W, ACCESS
1E9A  26D9     ADDWF FSR2, F, ACCESS
1E9C  5018     MOVF 0x18, W, ACCESS
1E9E  22DA     ADDWFC FSR2H, F, ACCESS
1EA0  0E30     MOVLW 0x30
1EA2  6EDE     MOVWF POSTINC2, ACCESS
1EA4  0E04     MOVLW 0x4
1EA6  6EDD     MOVWF POSTDEC2, ACCESS
1451:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
1EA8  C017     MOVFF pBDTEntryEP0OutCurrent, FSR2
1EAA  FFD9     NOP
1EAC  C018     MOVFF 0x18, FSR2H
1EAE  FFDA     NOP
1EB0  0E04     MOVLW 0x4
1EB2  6EDF     MOVWF INDF2, ACCESS
1452:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
1EB4  C017     MOVFF pBDTEntryEP0OutCurrent, FSR2
1EB6  FFD9     NOP
1EB8  C018     MOVFF 0x18, FSR2H
1EBA  FFDA     NOP
1EBC  0E00     MOVLW 0x0
1EBE  8EDB     BSF PLUSW2, 7, ACCESS
1453:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
1EC0  0E01     MOVLW 0x1
1EC2  6E20     MOVWF BothEP0OutUOWNsSet, ACCESS
1454:                          #endif
1455:          
1456:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1457:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1EC4  EE20     LFSR 2, 0x1
1EC6  F001     NOP
1EC8  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
1ECA  26D9     ADDWF FSR2, F, ACCESS
1ECC  5016     MOVF 0x16, W, ACCESS
1ECE  22DA     ADDWFC FSR2H, F, ACCESS
1ED0  0E08     MOVLW 0x8
1ED2  6EDF     MOVWF INDF2, ACCESS
1458:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1ED4  EE20     LFSR 2, 0x2
1ED6  F002     NOP
1ED8  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
1EDA  26D9     ADDWF FSR2, F, ACCESS
1EDC  5016     MOVF 0x16, W, ACCESS
1EDE  22DA     ADDWFC FSR2H, F, ACCESS
1EE0  0E30     MOVLW 0x30
1EE2  6EDE     MOVWF POSTINC2, ACCESS
1EE4  0E04     MOVLW 0x4
1EE6  6EDD     MOVWF POSTDEC2, ACCESS
1459:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
1EE8  C015     MOVFF pBDTEntryEP0OutNext, FSR2
1EEA  FFD9     NOP
1EEC  C016     MOVFF 0x16, FSR2H
1EEE  FFDA     NOP
1EF0  0E80     MOVLW 0x80
1EF2  6EDF     MOVWF INDF2, ACCESS
1EF4  EF7C     GOTO 0x1EF8
1EF6  F00F     NOP
1460:                      }
1461:                  }    
1462:              }
1463:          }   
1EF8  0012     RETURN 0
1464:          
1465:          
1466:          /*******************************************************************************
1467:            Function: void USBCtrlEPAllowDataStage(void);
1468:              
1469:            Summary: This function allows the data stage of either a host-to-device or
1470:                      device-to-host control transfer (with data stage) to complete.
1471:                      This function is meant to be used in conjunction with either the
1472:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1473:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1474:                      then the firmware does not need to manually call 
1475:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1476:                      instead.
1477:               
1478:            Description:
1479:              
1480:            Conditions: A control transfer (with data stage) should already be pending, 
1481:                          if the firmware calls this function.  Additionally, the firmware
1482:                          should have called either USBDeferOUTDataStage() or 
1483:                          USBDeferINDataStage() at the start of the control transfer, if
1484:                          the firmware will be calling this function manually.
1485:          
1486:            Input:
1487:          
1488:            Return:
1489:          
1490:            Remarks: 
1491:            *****************************************************************************/
1492:          void USBCtrlEPAllowDataStage(void)
1493:          {
1494:              USBDeferINDataStagePackets = false;
2098  0E00     MOVLW 0x0
209A  6E1B     MOVWF USBDeferINDataStagePackets, ACCESS
1495:              USBDeferOUTDataStagePackets = false;
209C  0E00     MOVLW 0x0
209E  0100     MOVLB 0x0
20A0  6F89     MOVWF USBDeferOUTDataStagePackets, BANKED
1496:          
1497:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
20A2  0E02     MOVLW 0x2
20A4  1824     XORWF controlTransferState, W, ACCESS
20A6  A4D8     BTFSS STATUS, 2, ACCESS
20A8  EF58     GOTO 0x20B0
20AA  F010     NOP
20AC  EF5A     GOTO 0x20B4
20AE  F010     NOP
20B0  EF7A     GOTO 0x20F4
20B2  F010     NOP
1498:              {
1499:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1500:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
20B4  EE20     LFSR 2, 0x1
20B6  F001     NOP
20B8  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
20BA  26D9     ADDWF FSR2, F, ACCESS
20BC  5016     MOVF 0x16, W, ACCESS
20BE  22DA     ADDWFC FSR2H, F, ACCESS
20C0  0E08     MOVLW 0x8
20C2  6EDF     MOVWF INDF2, ACCESS
1501:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
20C4  EE20     LFSR 2, 0x2
20C6  F002     NOP
20C8  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
20CA  26D9     ADDWF FSR2, F, ACCESS
20CC  5016     MOVF 0x16, W, ACCESS
20CE  22DA     ADDWFC FSR2H, F, ACCESS
20D0  0E38     MOVLW 0x38
20D2  6EDE     MOVWF POSTINC2, ACCESS
20D4  0E04     MOVLW 0x4
20D6  6EDD     MOVWF POSTDEC2, ACCESS
1502:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
20D8  C015     MOVFF pBDTEntryEP0OutNext, FSR2
20DA  FFD9     NOP
20DC  C016     MOVFF 0x16, FSR2H
20DE  FFDA     NOP
20E0  0E48     MOVLW 0x48
20E2  6EDF     MOVWF INDF2, ACCESS
1503:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
20E4  C015     MOVFF pBDTEntryEP0OutNext, FSR2
20E6  FFD9     NOP
20E8  C016     MOVFF 0x16, FSR2H
20EA  FFDA     NOP
20EC  0E00     MOVLW 0x0
20EE  8EDB     BSF PLUSW2, 7, ACCESS
1504:              }   
20F0  EFA2     GOTO 0x2144
20F2  F010     NOP
1505:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1506:              {
1507:                  //Error check the data stage byte count.  Make sure the user specified
1508:                  //value was no greater than the number of bytes the host requested.
1509:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
20F4  5013     MOVF 0x13, W, ACCESS
20F6  0104     MOVLB 0x4
20F8  5D36     SUBWF tmp, W, BANKED
20FA  5014     MOVF 0x14, W, ACCESS
20FC  5937     SUBWFB ep, W, BANKED
20FE  B0D8     BTFSC STATUS, 0, ACCESS
2100  EF84     GOTO 0x2108
2102  F010     NOP
2104  EF86     GOTO 0x210C
2106  F010     NOP
2108  EF8A     GOTO 0x2114
210A  F010     NOP
1510:          		{
1511:          			inPipes[0].wCount.Val = SetupPkt.wLength;
210C  C436     MOVFF 0x436, 0x13
210E  F013     NOP
2110  C437     MOVFF 0x437, 0x14
2112  F014     NOP
1512:          		}
1513:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
2114  ECF9     CALL 0x19F2, 0
2116  F00C     NOP
1514:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1515:          
1516:          	    //Cnt should have been initialized by responsible request owner (ex: by
1517:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1518:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
2118  EE20     LFSR 2, 0x2
211A  F002     NOP
211C  5009     MOVF pBDTEntryIn, W, ACCESS
211E  26D9     ADDWF FSR2, F, ACCESS
2120  500A     MOVF 0xA, W, ACCESS
2122  22DA     ADDWFC FSR2H, F, ACCESS
2124  0E38     MOVLW 0x38
2126  6EDE     MOVWF POSTINC2, ACCESS
2128  0E04     MOVLW 0x4
212A  6EDD     MOVWF POSTDEC2, ACCESS
1519:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
212C  C009     MOVFF pBDTEntryIn, FSR2
212E  FFD9     NOP
2130  C00A     MOVFF 0xA, FSR2H
2132  FFDA     NOP
2134  0E48     MOVLW 0x48
2136  6EDF     MOVWF INDF2, ACCESS
1520:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
2138  C009     MOVFF pBDTEntryIn, FSR2
213A  FFD9     NOP
213C  C00A     MOVFF 0xA, FSR2H
213E  FFDA     NOP
2140  0E00     MOVLW 0x0
2142  8EDB     BSF PLUSW2, 7, ACCESS
1521:              }     
1522:          }    
2144  0012     RETURN 0
1523:          
1524:          
1525:          /******************************************************************************/
1526:          /** Internal Functions *********************************************************/
1527:          /******************************************************************************/
1528:          
1529:          /********************************************************************
1530:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1531:           *
1532:           * PreCondition:    None
1533:           *
1534:           * Input:           uint8_t EPNum - the endpoint to be configured
1535:           *                  uint8_t direction - the direction to be configured
1536:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1537:           *
1538:           * Output:          None
1539:           *
1540:           * Side Effects:    None
1541:           *
1542:           * Overview:        This function will configure the specified 
1543:           *                  endpoint
1544:           *
1545:           * Note:            None
1546:           *******************************************************************/
1547:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
2146  6E31     MOVWF EPNum, ACCESS
1548:          {
1549:              volatile BDT_ENTRY* handle;
1550:          
1551:              //Compute a pointer to the even BDT entry corresponding to the
1552:              //EPNum and direction values passed to this function.
1553:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
2148  0E00     MOVLW 0x0
214A  6E32     MOVWF handle, ACCESS
214C  0E04     MOVLW 0x4
214E  6E33     MOVWF 0x33, ACCESS
1554:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
2150  502C     MOVF __pcstackCOMRAM, W, ACCESS
2152  6E2D     MOVWF data, ACCESS
2154  6A2E     CLRF p, ACCESS
2156  90D8     BCF STATUS, 0, ACCESS
2158  362D     RLCF data, F, ACCESS
215A  362E     RLCF p, F, ACCESS
215C  5031     MOVF EPNum, W, ACCESS
215E  6E2F     MOVWF len, ACCESS
2160  6A30     CLRF n, ACCESS
2162  90D8     BCF STATUS, 0, ACCESS
2164  362F     RLCF len, F, ACCESS
2166  3630     RLCF n, F, ACCESS
2168  90D8     BCF STATUS, 0, ACCESS
216A  362F     RLCF len, F, ACCESS
216C  3630     RLCF n, F, ACCESS
216E  502D     MOVF data, W, ACCESS
2170  262F     ADDWF len, F, ACCESS
2172  502E     MOVF p, W, ACCESS
2174  2230     ADDWFC n, F, ACCESS
2176  90D8     BCF STATUS, 0, ACCESS
2178  362F     RLCF len, F, ACCESS
217A  3630     RLCF n, F, ACCESS
217C  90D8     BCF STATUS, 0, ACCESS
217E  362F     RLCF len, F, ACCESS
2180  3630     RLCF n, F, ACCESS
2182  502F     MOVF len, W, ACCESS
2184  2632     ADDWF handle, F, ACCESS
2186  5030     MOVF n, W, ACCESS
2188  2233     ADDWFC 0x33, F, ACCESS
1555:              
1556:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
218A  C032     MOVFF handle, FSR2
218C  FFD9     NOP
218E  C033     MOVFF 0x33, FSR2H
2190  FFDA     NOP
2192  9EDF     BCF INDF2, 7, ACCESS
1557:              //already cleared the entire BDT table
1558:          
1559:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1560:              //for USBTransferOnePacket() API calls.
1561:              if(direction == OUT_FROM_HOST)
2194  502C     MOVF __pcstackCOMRAM, W, ACCESS
2196  A4D8     BTFSS STATUS, 2, ACCESS
2198  EFD0     GOTO 0x21A0
219A  F010     NOP
219C  EFD2     GOTO 0x21A4
219E  F010     NOP
21A0  EFE0     GOTO 0x21C0
21A2  F010     NOP
1562:              {
1563:                  pBDTEntryOut[EPNum] = handle;
21A4  5031     MOVF EPNum, W, ACCESS
21A6  0D02     MULLW 0x2
21A8  0E6A     MOVLW 0x6A
21AA  24F3     ADDWF PROD, W, ACCESS
21AC  6ED9     MOVWF FSR2, ACCESS
21AE  0E00     MOVLW 0x0
21B0  20F4     ADDWFC PRODH, W, ACCESS
21B2  6EDA     MOVWF FSR2H, ACCESS
21B4  C032     MOVFF handle, POSTINC2
21B6  FFDE     NOP
21B8  C033     MOVFF 0x33, POSTDEC2
21BA  FFDD     NOP
1564:              }
21BC  EFEC     GOTO 0x21D8
21BE  F010     NOP
1565:              else
1566:              {
1567:                  pBDTEntryIn[EPNum] = handle;
21C0  5031     MOVF EPNum, W, ACCESS
21C2  0D02     MULLW 0x2
21C4  0E09     MOVLW 0x9
21C6  24F3     ADDWF PROD, W, ACCESS
21C8  6ED9     MOVWF FSR2, ACCESS
21CA  0E00     MOVLW 0x0
21CC  20F4     ADDWFC PRODH, W, ACCESS
21CE  6EDA     MOVWF FSR2H, ACCESS
21D0  C032     MOVFF handle, POSTINC2
21D2  FFDE     NOP
21D4  C033     MOVFF 0x33, POSTDEC2
21D6  FFDD     NOP
1568:              }
1569:          
1570:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1571:                  handle->STAT.DTS = 0;
21D8  C032     MOVFF handle, FSR2
21DA  FFD9     NOP
21DC  C033     MOVFF 0x33, FSR2H
21DE  FFDA     NOP
21E0  9CDF     BCF INDF2, 6, ACCESS
1572:                  (handle+1)->STAT.DTS = 1;
21E2  EE20     LFSR 2, 0x4
21E4  F004     NOP
21E6  5032     MOVF handle, W, ACCESS
21E8  26D9     ADDWF FSR2, F, ACCESS
21EA  5033     MOVF 0x33, W, ACCESS
21EC  22DA     ADDWFC FSR2H, F, ACCESS
21EE  8CDF     BSF INDF2, 6, ACCESS
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1574:                  //Set DTS to one because the first thing we will do
1575:                  //when transmitting is toggle the bit
1576:                  handle->STAT.DTS = 1;
1577:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1578:                  if(EPNum != 0)
1579:                  {
1580:                      handle->STAT.DTS = 1;
1581:                  }
1582:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1583:                  if(EPNum != 0)
1584:                  {
1585:                      handle->STAT.DTS = 0;
1586:                      (handle+1)->STAT.DTS = 1;
1587:                  }
1588:              #endif
1589:          }
21F0  0012     RETURN 0
1590:          
1591:          
1592:          /******************************************************************************
1593:           * Function:        void USBCtrlEPServiceComplete(void)
1594:           *
1595:           * PreCondition:    None
1596:           *
1597:           * Input:           None
1598:           *
1599:           * Output:          None
1600:           *
1601:           * Side Effects:    None
1602:           *
1603:           * Overview:        This routine wrap up the remaining tasks in servicing
1604:           *                  a Setup Request. Its main task is to set the endpoint
1605:           *                  controls appropriately for a given situation. See code
1606:           *                  below.
1607:           *                  There are three main scenarios:
1608:           *                  a) There was no handler for the Request, in this case
1609:           *                     a STALL should be sent out.
1610:           *                  b) The host has requested a read control transfer,
1611:           *                     endpoints are required to be setup in a specific way.
1612:           *                  c) The host has requested a write control transfer, or
1613:           *                     a control data stage is not required, endpoints are
1614:           *                     required to be setup in a specific way.
1615:           *
1616:           *                  Packet processing is resumed by clearing PKTDIS bit.
1617:           *
1618:           * Note:            None
1619:           *****************************************************************************/
1620:          static void USBCtrlEPServiceComplete(void)
1621:          {
1622:              /*
1623:               * PKTDIS bit is set when a Setup Transaction is received.
1624:               * Clear to resume packet processing.
1625:               */
1626:              USBPacketDisable = 0;
1514  9860     BCF UCON, 4, ACCESS
1627:          
1628:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1629:          	//control transfer is currently in progress.  We need to know the type of control
1630:          	//transfer that is currently pending, in order to know how to properly arm the 
1631:          	//EP0 IN and EP0 OUT endpoints.
1632:              if(inPipes[0].info.bits.busy == 0)
1516  BE12     BTFSC 0x12, 7, ACCESS
1518  EF90     GOTO 0x1520
151A  F00A     NOP
151C  EF92     GOTO 0x1524
151E  F00A     NOP
1520  EFD8     GOTO 0x15B0
1522  F00A     NOP
1633:              {
1634:                  if(outPipes[0].info.bits.busy == 1)
1524  AE04     BTFSS 0x4, 7, ACCESS
1526  EF97     GOTO 0x152E
1528  F00A     NOP
152A  EF99     GOTO 0x1532
152C  F00A     NOP
152E  EFAC     GOTO 0x1558
1530  F00A     NOP
1635:                  {
1636:                      controlTransferState = CTRL_TRF_RX;
1532  0E02     MOVLW 0x2
1534  6E24     MOVWF controlTransferState, ACCESS
1637:                      /*
1638:                       * Control Write:
1639:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1640:                       */
1641:          
1642:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1643:                      //   function decided to defer the data stage (ex: because the intended
1644:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1645:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1646:                      //   once it is ready to begin receiving the data.
1647:                      if(USBDeferOUTDataStagePackets == false)
1536  0100     MOVLB 0x0
1538  5189     MOVF USBDeferOUTDataStagePackets, W, BANKED
153A  A4D8     BTFSS STATUS, 2, ACCESS
153C  EFA2     GOTO 0x1544
153E  F00A     NOP
1540  EFA4     GOTO 0x1548
1542  F00A     NOP
1544  EFA6     GOTO 0x154C
1546  F00A     NOP
1648:                      {
1649:                          USBCtrlEPAllowDataStage();
1548  EC4C     CALL 0x2098, 0
154A  F010     NOP
1650:                      }
1651:                      
1652:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1653:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1654:                      USBStatusStageEnabledFlag2 = false;
154C  0E00     MOVLW 0x0
154E  6E1C     MOVWF USBStatusStageEnabledFlag2, ACCESS
1655:                      USBStatusStageEnabledFlag1 = false;
1550  0E00     MOVLW 0x0
1552  6E1D     MOVWF USBStatusStageEnabledFlag1, ACCESS
1656:                  }
1554  EF2A     GOTO 0x1654
1556  F00B     NOP
1657:                  else
1658:                  {
1659:                      /*
1660:                       * If no one knows how to service this request then stall.
1661:                       * Must also prepare EP0 to receive the next SETUP transaction.
1662:                       */
1663:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1558  EE20     LFSR 2, 0x1
155A  F001     NOP
155C  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
155E  26D9     ADDWF FSR2, F, ACCESS
1560  5016     MOVF 0x16, W, ACCESS
1562  22DA     ADDWFC FSR2H, F, ACCESS
1564  0E08     MOVLW 0x8
1566  6EDF     MOVWF INDF2, ACCESS
1664:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1568  EE20     LFSR 2, 0x2
156A  F002     NOP
156C  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
156E  26D9     ADDWF FSR2, F, ACCESS
1570  5016     MOVF 0x16, W, ACCESS
1572  22DA     ADDWFC FSR2H, F, ACCESS
1574  0E30     MOVLW 0x30
1576  6EDE     MOVWF POSTINC2, ACCESS
1578  0E04     MOVLW 0x4
157A  6EDD     MOVWF POSTDEC2, ACCESS
1665:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
157C  C015     MOVFF pBDTEntryEP0OutNext, FSR2
157E  FFD9     NOP
1580  C016     MOVFF 0x16, FSR2H
1582  FFDA     NOP
1584  0E0C     MOVLW 0xC
1586  6EDF     MOVWF INDF2, ACCESS
1666:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1588  C015     MOVFF pBDTEntryEP0OutNext, FSR2
158A  FFD9     NOP
158C  C016     MOVFF 0x16, FSR2H
158E  FFDA     NOP
1590  0E00     MOVLW 0x0
1592  8EDB     BSF PLUSW2, 7, ACCESS
1667:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
1594  C009     MOVFF pBDTEntryIn, FSR2
1596  FFD9     NOP
1598  C00A     MOVFF 0xA, FSR2H
159A  FFDA     NOP
159C  0E04     MOVLW 0x4
159E  6EDF     MOVWF INDF2, ACCESS
1668:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
15A0  C009     MOVFF pBDTEntryIn, FSR2
15A2  FFD9     NOP
15A4  C00A     MOVFF 0xA, FSR2H
15A6  FFDA     NOP
15A8  0E00     MOVLW 0x0
15AA  8EDB     BSF PLUSW2, 7, ACCESS
15AC  EF2A     GOTO 0x1654
15AE  F00B     NOP
1669:                  }
1670:              }
1671:              else    // A module has claimed ownership of the control transfer session.
1672:              {
1673:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
15B0  0104     MOVLB 0x4
15B2  AF30     BTFSS n, 7, BANKED
15B4  EFDE     GOTO 0x15BC
15B6  F00A     NOP
15B8  EFE0     GOTO 0x15C0
15BA  F00A     NOP
15BC  EFFC     GOTO 0x15F8
15BE  F00A     NOP
1674:          		{
1675:          			controlTransferState = CTRL_TRF_TX;
15C0  0E01     MOVLW 0x1
15C2  6E24     MOVWF controlTransferState, ACCESS
1676:          			/*
1677:          			 * Control Read:
1678:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1679:          			 *
1680:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1681:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1682:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1683:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1684:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1685:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1686:          			 *    is ready to begin sending the data, it should then call the 
1687:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1688:          			 */
1689:          			if(USBDeferINDataStagePackets == false)
15C4  501B     MOVF USBDeferINDataStagePackets, W, ACCESS
15C6  A4D8     BTFSS STATUS, 2, ACCESS
15C8  EFE8     GOTO 0x15D0
15CA  F00A     NOP
15CC  EFEA     GOTO 0x15D4
15CE  F00A     NOP
15D0  EFEC     GOTO 0x15D8
15D2  F00A     NOP
1690:                      {
1691:                          USBCtrlEPAllowDataStage();
15D4  EC4C     CALL 0x2098, 0
15D6  F010     NOP
1692:          			}
1693:          
1694:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1695:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1696:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1697:                      //    is ready.  If the class request handler does this, it needs to be careful to
1698:                      //    be written so that it can handle the early termination scenario.
1699:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1700:                      //    1.  The desired total number of bytes were sent to the host.
1701:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1702:                      //        started the control transfer) has been reached.
1703:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1704:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1705:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1706:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_device_config.h
1707:                      //        option can take care of this for you.
1708:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1709:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1710:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1711:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1712:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1713:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1714:                      USBStatusStageEnabledFlag2 = false;
15D8  0E00     MOVLW 0x0
15DA  6E1C     MOVWF USBStatusStageEnabledFlag2, ACCESS
1715:                      USBStatusStageEnabledFlag1 = false;
15DC  0E00     MOVLW 0x0
15DE  6E1D     MOVWF USBStatusStageEnabledFlag1, ACCESS
1716:                      if(USBDeferStatusStagePacket == false)
15E0  501E     MOVF USBDeferStatusStagePacket, W, ACCESS
15E2  A4D8     BTFSS STATUS, 2, ACCESS
15E4  EFF6     GOTO 0x15EC
15E6  F00A     NOP
15E8  EFF8     GOTO 0x15F0
15EA  F00A     NOP
15EC  EF2A     GOTO 0x1654
15EE  F00B     NOP
1717:                      {
1718:                          USBCtrlEPAllowStatusStage();
15F0  EC05     CALL 0x1E0A, 0
15F2  F00F     NOP
15F4  EF2A     GOTO 0x1654
15F6  F00B     NOP
1719:                      } 
1720:          		}
1721:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1722:          		{
1723:          			//This situation occurs for special types of control transfers,
1724:          			//such as that which occurs when the host sends a SET_ADDRESS
1725:          			//control transfer.  Ex:
1726:          			//
1727:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1728:          				
1729:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1730:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1731:          			//an IN status stage.
1732:          
1733:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
15F8  0E02     MOVLW 0x2
15FA  6E24     MOVWF controlTransferState, ACCESS
1734:          			
1735:          			//1. Prepare OUT EP to receive the next SETUP packet.
1736:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
15FC  EE20     LFSR 2, 0x1
15FE  F001     NOP
1600  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
1602  26D9     ADDWF FSR2, F, ACCESS
1604  5016     MOVF 0x16, W, ACCESS
1606  22DA     ADDWFC FSR2H, F, ACCESS
1608  0E08     MOVLW 0x8
160A  6EDF     MOVWF INDF2, ACCESS
1737:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
160C  EE20     LFSR 2, 0x2
160E  F002     NOP
1610  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
1612  26D9     ADDWF FSR2, F, ACCESS
1614  5016     MOVF 0x16, W, ACCESS
1616  22DA     ADDWFC FSR2H, F, ACCESS
1618  0E30     MOVLW 0x30
161A  6EDE     MOVWF POSTINC2, ACCESS
161C  0E04     MOVLW 0x4
161E  6EDD     MOVWF POSTDEC2, ACCESS
1738:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
1620  C015     MOVFF pBDTEntryEP0OutNext, FSR2
1622  FFD9     NOP
1624  C016     MOVFF 0x16, FSR2H
1626  FFDA     NOP
1628  0E04     MOVLW 0x4
162A  6EDF     MOVWF INDF2, ACCESS
1739:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
162C  C015     MOVFF pBDTEntryEP0OutNext, FSR2
162E  FFD9     NOP
1630  C016     MOVFF 0x16, FSR2H
1632  FFDA     NOP
1634  0E00     MOVLW 0x0
1636  8EDB     BSF PLUSW2, 7, ACCESS
1740:          				
1741:          			//2. Prepare for IN status stage of the control transfer
1742:                      USBStatusStageEnabledFlag2 = false;
1638  0E00     MOVLW 0x0
163A  6E1C     MOVWF USBStatusStageEnabledFlag2, ACCESS
1743:                      USBStatusStageEnabledFlag1 = false;
163C  0E00     MOVLW 0x0
163E  6E1D     MOVWF USBStatusStageEnabledFlag1, ACCESS
1744:          			if(USBDeferStatusStagePacket == false)
1640  501E     MOVF USBDeferStatusStagePacket, W, ACCESS
1642  A4D8     BTFSS STATUS, 2, ACCESS
1644  EF26     GOTO 0x164C
1646  F00B     NOP
1648  EF28     GOTO 0x1650
164A  F00B     NOP
164C  EF2A     GOTO 0x1654
164E  F00B     NOP
1650  EFF8     GOTO 0x15F0
1652  F00A     NOP
1745:                      {
1746:                          USBCtrlEPAllowStatusStage();
1747:                      } 
1748:          		}
1749:          
1750:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1751:          
1752:          }//end USBCtrlEPServiceComplete
1654  0012     RETURN 0
1753:          
1754:          
1755:          /******************************************************************************
1756:           * Function:        void USBCtrlTrfTxService(void)
1757:           *
1758:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1759:           *
1760:           * Input:           None
1761:           *
1762:           * Output:          None
1763:           *
1764:           * Side Effects:    None
1765:           *
1766:           * Overview:        This routine is used for device to host control transfers 
1767:           *					(IN transactions).  This function takes care of managing a
1768:           *                  transfer over multiple USB transactions.
1769:           *					This routine should be called from only two places.
1770:           *                  One from USBCtrlEPServiceComplete() and one from
1771:           *                  USBCtrlTrfInHandler().
1772:           *
1773:           * Note:            
1774:           *****************************************************************************/
1775:          static void USBCtrlTrfTxService(void)
1776:          {
1777:              uint8_t byteToSend;
1778:          
1779:              //Figure out how many bytes of data to send in the next IN transaction.
1780:              //Assume a full size packet, unless otherwise determined below.
1781:              byteToSend = USB_EP0_BUFF_SIZE;         
19F2  0E08     MOVLW 0x8
19F4  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1782:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
19F6  5014     MOVF 0x14, W, ACCESS
19F8  E107     BNZ 0x1A08
19FA  0E08     MOVLW 0x8
19FC  5C13     SUBWF 0x13, W, ACCESS
19FE  B0D8     BTFSC STATUS, 0, ACCESS
1A00  EF04     GOTO 0x1A08
1A02  F00D     NOP
1A04  EF06     GOTO 0x1A0C
1A06  F00D     NOP
1A08  EF1E     GOTO 0x1A3C
1A0A  F00D     NOP
1783:              {
1784:                  byteToSend = inPipes[0].wCount.Val;
1A0C  C013     MOVFF 0x13, __pcstackCOMRAM
1A0E  F02C     NOP
1785:          
1786:                  //Keep track of whether or not we have sent a "short packet" yet.
1787:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1788:                  //after we have sent all of the intended data.  This makes sure the
1789:                  //hardware STALLs if the host erroneously tries to send more IN token 
1790:                  //packets, requesting more data than intended in the control transfer.
1791:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
1A10  5025     MOVF shortPacketStatus, W, ACCESS
1A12  A4D8     BTFSS STATUS, 2, ACCESS
1A14  EF0E     GOTO 0x1A1C
1A16  F00D     NOP
1A18  EF10     GOTO 0x1A20
1A1A  F00D     NOP
1A1C  EF14     GOTO 0x1A28
1A1E  F00D     NOP
1792:                  {
1793:                      shortPacketStatus = SHORT_PKT_PENDING;
1A20  0E01     MOVLW 0x1
1A22  6E25     MOVWF shortPacketStatus, ACCESS
1794:                  }
1A24  EF1E     GOTO 0x1A3C
1A26  F00D     NOP
1795:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
1A28  0425     DECF shortPacketStatus, W, ACCESS
1A2A  A4D8     BTFSS STATUS, 2, ACCESS
1A2C  EF1A     GOTO 0x1A34
1A2E  F00D     NOP
1A30  EF1C     GOTO 0x1A38
1A32  F00D     NOP
1A34  EF1E     GOTO 0x1A3C
1A36  F00D     NOP
1796:                  {
1797:                      shortPacketStatus = SHORT_PKT_SENT;
1A38  0E02     MOVLW 0x2
1A3A  6E25     MOVWF shortPacketStatus, ACCESS
1798:                  }
1799:              }
1800:          
1801:              //Keep track of how many bytes remain to be sent in the transfer, by
1802:              //subtracting the number of bytes about to be sent from the total.
1803:              inPipes[0].wCount.Val -= byteToSend;
1A3C  502C     MOVF __pcstackCOMRAM, W, ACCESS
1A3E  5E13     SUBWF 0x13, F, ACCESS
1A40  0E00     MOVLW 0x0
1A42  5A14     SUBWFB 0x14, F, ACCESS
1804:              
1805:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1806:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1807:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1808:              pBDTEntryIn[0]->CNT = byteToSend;
1A44  EE20     LFSR 2, 0x1
1A46  F001     NOP
1A48  5009     MOVF pBDTEntryIn, W, ACCESS
1A4A  26D9     ADDWF FSR2, F, ACCESS
1A4C  500A     MOVF 0xA, W, ACCESS
1A4E  22DA     ADDWFC FSR2H, F, ACCESS
1A50  C02C     MOVFF __pcstackCOMRAM, INDF2
1A52  FFDF     NOP
1809:          
1810:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1811:              //which we will send to the host.
1812:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
1A54  0E38     MOVLW 0x38
1A56  0100     MOVLB 0x0
1A58  6F84     MOVWF pDst, BANKED
1A5A  0E04     MOVLW 0x4
1A5C  6F85     MOVWF 0x85, BANKED
1813:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
1A5E  B012     BTFSC 0x12, 0, ACCESS
1A60  EF34     GOTO 0x1A68
1A62  F00D     NOP
1A64  EF36     GOTO 0x1A6C
1A66  F00D     NOP
1A68  EF78     GOTO 0x1AF0
1A6A  F00D     NOP
1A6C  EF53     GOTO 0x1AA6
1A6E  F00D     NOP
1814:              {
1815:                  while(byteToSend)
1AA6  502C     MOVF __pcstackCOMRAM, W, ACCESS
1AA8  A4D8     BTFSS STATUS, 2, ACCESS
1AAA  EF59     GOTO 0x1AB2
1AAC  F00D     NOP
1AAE  EF5B     GOTO 0x1AB6
1AB0  F00D     NOP
1AB2  EF38     GOTO 0x1A70
1AB4  F00D     NOP
1AB6  EF80     GOTO 0x1B00
1AB8  F00D     NOP
1816:                  {
1817:                      *pDst++ = *inPipes[0].pSrc.bRom++;
1A70  C00F     MOVFF inPipes, TBLPTR
1A72  FFF6     NOP
1A74  C010     MOVFF 0x10, TBLPTRH
1A76  FFF7     NOP
1A78  6AF8     CLRF TBLPTRU, ACCESS
1A7A  C084     MOVFF pDst, FSR2
1A7C  FFD9     NOP
1A7E  C085     MOVFF 0x85, FSR2H
1A80  FFDA     NOP
1A82  0E07     MOVLW 0x7
1A84  64F7     CPFSGT TBLPTRH, ACCESS
1A86  D003     BRA 0x1A8E
1A88  0008     TBLRD*
1A8A  50F5     MOVF TABLAT, W, ACCESS
1A8C  D005     BRA 0x1A98
1A8E  CFF6     MOVFF TBLPTR, FSR0
1A90  FFE9     NOP
1A92  CFF7     MOVFF TBLPTRH, FSR0H
1A94  FFEA     NOP
1A96  50EF     MOVF INDF0, W, ACCESS
1A98  6EDF     MOVWF INDF2, ACCESS
1A9A  4A0F     INFSNZ inPipes, F, ACCESS
1A9C  2A10     INCF 0x10, F, ACCESS
1A9E  0100     MOVLB 0x0
1AA0  4B84     INFSNZ pDst, F, BANKED
1AA2  2B85     INCF 0x85, F, BANKED
1818:                      byteToSend--;
1AA4  062C     DECF __pcstackCOMRAM, F, ACCESS
1819:                  }//end while(byte_to_send.Val)
1820:              }
1821:              else  // RAM
1822:              {
1823:                  while(byteToSend)
1AF0  502C     MOVF __pcstackCOMRAM, W, ACCESS
1AF2  A4D8     BTFSS STATUS, 2, ACCESS
1AF4  EF7E     GOTO 0x1AFC
1AF6  F00D     NOP
1AF8  EF80     GOTO 0x1B00
1AFA  F00D     NOP
1AFC  EF5D     GOTO 0x1ABA
1AFE  F00D     NOP
1824:                  {
1825:                      *pDst++ = *inPipes[0].pSrc.bRam++;
1ABA  C00F     MOVFF inPipes, TBLPTR
1ABC  FFF6     NOP
1ABE  C010     MOVFF 0x10, TBLPTRH
1AC0  FFF7     NOP
1AC2  6AF8     CLRF TBLPTRU, ACCESS
1AC4  C084     MOVFF pDst, FSR2
1AC6  FFD9     NOP
1AC8  C085     MOVFF 0x85, FSR2H
1ACA  FFDA     NOP
1ACC  0E07     MOVLW 0x7
1ACE  64F7     CPFSGT TBLPTRH, ACCESS
1AD0  D003     BRA 0x1AD8
1AD2  0008     TBLRD*
1AD4  50F5     MOVF TABLAT, W, ACCESS
1AD6  D005     BRA 0x1AE2
1AD8  CFF6     MOVFF TBLPTR, FSR0
1ADA  FFE9     NOP
1ADC  CFF7     MOVFF TBLPTRH, FSR0H
1ADE  FFEA     NOP
1AE0  50EF     MOVF INDF0, W, ACCESS
1AE2  6EDF     MOVWF INDF2, ACCESS
1AE4  4A0F     INFSNZ inPipes, F, ACCESS
1AE6  2A10     INCF 0x10, F, ACCESS
1AE8  0100     MOVLB 0x0
1AEA  4B84     INFSNZ pDst, F, BANKED
1AEC  2B85     INCF 0x85, F, BANKED
1826:                      byteToSend--;
1AEE  062C     DECF __pcstackCOMRAM, F, ACCESS
1827:                  }//end while(byte_to_send.Val)
1828:              }//end if(usb_stat.ctrl_trf_mem == _const)
1829:          }//end USBCtrlTrfTxService
1B00  0012     RETURN 0
1830:          
1831:          /******************************************************************************
1832:           * Function:        void USBCtrlTrfRxService(void)
1833:           *
1834:           * PreCondition:    pDst and wCount are setup properly.
1835:           *                  pSrc is always &CtrlTrfData
1836:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1837:           *                  wCount should be set to 0 at the start of each control
1838:           *                  transfer.
1839:           *
1840:           * Input:           None
1841:           *
1842:           * Output:          None
1843:           *
1844:           * Side Effects:    None
1845:           *
1846:           * Overview:        This routine is used for host to device control transfers
1847:           *					(uses OUT transactions).  This function receives the data that arrives
1848:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1849:           *					buffer.  Once the host has sent all the data it was intending
1850:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1851:           *					handler (unless it is NULL), so that it can be used by the
1852:           *					intended target firmware.
1853:           *
1854:           * Note:            None
1855:           *****************************************************************************/
1856:          static void USBCtrlTrfRxService(void)
1857:          {
1858:              uint8_t byteToRead;
1859:              uint8_t i;
1860:          
1861:              //Load byteToRead with the number of bytes the host just sent us in the 
1862:              //last OUT transaction.
1863:              byteToRead = pBDTEntryEP0OutCurrent->CNT;   
1656  EE20     LFSR 2, 0x1
1658  F001     NOP
165A  5017     MOVF pBDTEntryEP0OutCurrent, W, ACCESS
165C  26D9     ADDWF FSR2, F, ACCESS
165E  5018     MOVF 0x18, W, ACCESS
1660  22DA     ADDWFC FSR2H, F, ACCESS
1662  50DF     MOVF INDF2, W, ACCESS
1664  6E2D     MOVWF data, ACCESS
1864:          
1865:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1866:              //of remaining bytes expected to be received from the host, in the control
1867:              //transfer.  First check to see if the host sent us more bytes than the
1868:              //application firmware was expecting to receive.
1869:              if(byteToRead > outPipes[0].wCount.Val)
1666  502D     MOVF data, W, ACCESS
1668  5C05     SUBWF 0x5, W, ACCESS
166A  0E00     MOVLW 0x0
166C  5806     SUBWFB 0x6, W, ACCESS
166E  B0D8     BTFSC STATUS, 0, ACCESS
1670  EF3C     GOTO 0x1678
1672  F00B     NOP
1674  EF3E     GOTO 0x167C
1676  F00B     NOP
1678  EF40     GOTO 0x1680
167A  F00B     NOP
1870:              {
1871:                  byteToRead = outPipes[0].wCount.Val;
167C  C005     MOVFF 0x5, data
167E  F02D     NOP
1872:              }	
1873:              //Reduce the number of remaining bytes by the number we just received.
1874:              outPipes[0].wCount.Val -= byteToRead;
1680  502D     MOVF data, W, ACCESS
1682  5E05     SUBWF 0x5, F, ACCESS
1684  0E00     MOVLW 0x0
1686  5A06     SUBWFB 0x6, F, ACCESS
1875:          
1876:              //Copy the OUT DATAx packet bytes that we just received from the host,
1877:              //into the user application buffer space.
1878:              for(i=0;i<byteToRead;i++)
1688  0E00     MOVLW 0x0
168A  6E2C     MOVWF __pcstackCOMRAM, ACCESS
168C  EF57     GOTO 0x16AE
168E  F00B     NOP
1879:              {
1880:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
1690  0E38     MOVLW 0x38
1692  242C     ADDWF __pcstackCOMRAM, W, ACCESS
1694  6ED9     MOVWF FSR2, ACCESS
1696  6ADA     CLRF FSR2H, ACCESS
1698  0E04     MOVLW 0x4
169A  22DA     ADDWFC FSR2H, F, ACCESS
169C  C001     MOVFF outPipes, FSR1
169E  FFE1     NOP
16A0  C002     MOVFF 0x2, FSR1H
16A2  FFE2     NOP
16A4  CFDF     MOVFF INDF2, INDF1
16A6  FFE7     NOP
16A8  4A01     INFSNZ outPipes, F, ACCESS
16AA  2A02     INCF 0x2, F, ACCESS
1881:              }//end while(byteToRead.Val)
16AC  2A2C     INCF __pcstackCOMRAM, F, ACCESS
16AE  502D     MOVF data, W, ACCESS
16B0  5C2C     SUBWF __pcstackCOMRAM, W, ACCESS
16B2  A0D8     BTFSS STATUS, 0, ACCESS
16B4  EF5E     GOTO 0x16BC
16B6  F00B     NOP
16B8  EF60     GOTO 0x16C0
16BA  F00B     NOP
16BC  EF48     GOTO 0x1690
16BE  F00B     NOP
1882:          
1883:              //If there is more data to receive, prepare EP0 OUT so that it can receive 
1884:          	//the next packet in the sequence.
1885:              if(outPipes[0].wCount.Val > 0)
16C0  5005     MOVF 0x5, W, ACCESS
16C2  1006     IORWF 0x6, W, ACCESS
16C4  B4D8     BTFSC STATUS, 2, ACCESS
16C6  EF67     GOTO 0x16CE
16C8  F00B     NOP
16CA  EF69     GOTO 0x16D2
16CC  F00B     NOP
16CE  EFA2     GOTO 0x1744
16D0  F00B     NOP
1886:              {
1887:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
16D2  EE20     LFSR 2, 0x1
16D4  F001     NOP
16D6  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
16D8  26D9     ADDWF FSR2, F, ACCESS
16DA  5016     MOVF 0x16, W, ACCESS
16DC  22DA     ADDWFC FSR2H, F, ACCESS
16DE  0E08     MOVLW 0x8
16E0  6EDF     MOVWF INDF2, ACCESS
1888:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
16E2  EE20     LFSR 2, 0x2
16E4  F002     NOP
16E6  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
16E8  26D9     ADDWF FSR2, F, ACCESS
16EA  5016     MOVF 0x16, W, ACCESS
16EC  22DA     ADDWFC FSR2H, F, ACCESS
16EE  0E38     MOVLW 0x38
16F0  6EDE     MOVWF POSTINC2, ACCESS
16F2  0E04     MOVLW 0x4
16F4  6EDD     MOVWF POSTDEC2, ACCESS
1889:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
16F6  C017     MOVFF pBDTEntryEP0OutCurrent, FSR2
16F8  FFD9     NOP
16FA  C018     MOVFF 0x18, FSR2H
16FC  FFDA     NOP
16FE  BCDF     BTFSC INDF2, 6, ACCESS
1700  EF84     GOTO 0x1708
1702  F00B     NOP
1704  EF86     GOTO 0x170C
1706  F00B     NOP
1708  EF94     GOTO 0x1728
170A  F00B     NOP
1890:                  {
1891:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
170C  C015     MOVFF pBDTEntryEP0OutNext, FSR2
170E  FFD9     NOP
1710  C016     MOVFF 0x16, FSR2H
1712  FFDA     NOP
1714  0E48     MOVLW 0x48
1716  6EDF     MOVWF INDF2, ACCESS
1892:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1718  C015     MOVFF pBDTEntryEP0OutNext, FSR2
171A  FFD9     NOP
171C  C016     MOVFF 0x16, FSR2H
171E  FFDA     NOP
1720  0E00     MOVLW 0x0
1722  8EDB     BSF PLUSW2, 7, ACCESS
1893:                  }
1724  EFCB     GOTO 0x1796
1726  F00B     NOP
1894:                  else
1895:                  {
1896:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
1728  C015     MOVFF pBDTEntryEP0OutNext, FSR2
172A  FFD9     NOP
172C  C016     MOVFF 0x16, FSR2H
172E  FFDA     NOP
1730  0E08     MOVLW 0x8
1732  6EDF     MOVWF INDF2, ACCESS
1897:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1734  C015     MOVFF pBDTEntryEP0OutNext, FSR2
1736  FFD9     NOP
1738  C016     MOVFF 0x16, FSR2H
173A  FFDA     NOP
173C  0E00     MOVLW 0x0
173E  8EDB     BSF PLUSW2, 7, ACCESS
1740  EFCB     GOTO 0x1796
1742  F00B     NOP
1898:                  }
1899:              }
1900:              else
1901:              {
1902:          	    //We have received all OUT packets that we were expecting to
1903:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1904:          		//the next SETUP transaction that may arrive.
1905:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1744  EE20     LFSR 2, 0x1
1746  F001     NOP
1748  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
174A  26D9     ADDWF FSR2, F, ACCESS
174C  5016     MOVF 0x16, W, ACCESS
174E  22DA     ADDWFC FSR2H, F, ACCESS
1750  0E08     MOVLW 0x8
1752  6EDF     MOVWF INDF2, ACCESS
1906:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1754  EE20     LFSR 2, 0x2
1756  F002     NOP
1758  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
175A  26D9     ADDWF FSR2, F, ACCESS
175C  5016     MOVF 0x16, W, ACCESS
175E  22DA     ADDWFC FSR2H, F, ACCESS
1760  0E30     MOVLW 0x30
1762  6EDE     MOVWF POSTINC2, ACCESS
1764  0E04     MOVLW 0x4
1766  6EDD     MOVWF POSTDEC2, ACCESS
1907:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1908:                  //control transfers.  However, set BSTALL in case the host tries to send
1909:                  //more data than it claims it was going to send.
1910:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
1768  C015     MOVFF pBDTEntryEP0OutNext, FSR2
176A  FFD9     NOP
176C  C016     MOVFF 0x16, FSR2H
176E  FFDA     NOP
1770  0E04     MOVLW 0x4
1772  6EDF     MOVWF INDF2, ACCESS
1911:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1774  C015     MOVFF pBDTEntryEP0OutNext, FSR2
1776  FFD9     NOP
1778  C016     MOVFF 0x16, FSR2H
177A  FFDA     NOP
177C  0E00     MOVLW 0x0
177E  8EDB     BSF PLUSW2, 7, ACCESS
1912:          
1913:          		//All data bytes for the host to device control write (OUT) have now been
1914:          		//received successfully.
1915:          		//Go ahead and call the user specified callback function, to use/consume
1916:          		//the control transfer data (ex: if the "void (*function)" parameter 
1917:          		//was non-NULL when USBEP0Receive() was called).
1918:                  if(outPipes[0].pFunc != NULL)
1919:                  {
1920:                      #if defined(__XC8)
1921:                          //Special pragmas to suppress an expected/harmless warning
1922:                          //message when building with the XC8 compiler
1923:                          #pragma warning push
1924:                          #pragma warning disable 1088
1925:                          outPipes[0].pFunc();    //Call the user's callback function
1926:                          #pragma warning pop
1927:                      #else
1928:                          outPipes[0].pFunc();    //Call the user's callback function
1929:                      #endif
1930:                  }
1931:                  outPipes[0].info.bits.busy = 0;    
1780  9E04     BCF 0x4, 7, ACCESS
1932:          
1933:                  //Ready to arm status stage IN transaction now, if the application
1934:                  //firmware has completed processing the request.  If it is still busy
1935:                  //and needs more time to finish handling the request, then the user
1936:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1937:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1938:                  //this case, it is the application's firmware responsibility to call 
1939:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1940:                  //Note: The application firmware must process the request and call
1941:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1942:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1943:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1944:                  //more details.
1945:                  if(USBDeferStatusStagePacket == false)
1782  501E     MOVF USBDeferStatusStagePacket, W, ACCESS
1784  A4D8     BTFSS STATUS, 2, ACCESS
1786  EFC7     GOTO 0x178E
1788  F00B     NOP
178A  EFC9     GOTO 0x1792
178C  F00B     NOP
178E  EFCB     GOTO 0x1796
1790  F00B     NOP
1946:                  {
1947:                      USBCtrlEPAllowStatusStage();
1792  EC05     CALL 0x1E0A, 0
1794  F00F     NOP
1948:                  }            
1949:              }    
1950:          
1951:          }//end USBCtrlTrfRxService
1796  0012     RETURN 0
1952:          
1953:          
1954:          /********************************************************************
1955:           * Function:        void USBStdSetCfgHandler(void)
1956:           *
1957:           * PreCondition:    None
1958:           *
1959:           * Input:           None
1960:           *
1961:           * Output:          None
1962:           *
1963:           * Side Effects:    None
1964:           *
1965:           * Overview:        This routine first disables all endpoints by
1966:           *                  clearing UEP registers. It then configures
1967:           *                  (initializes) endpoints by calling the callback
1968:           *                  function USBCBInitEP().
1969:           *
1970:           * Note:            None
1971:           *******************************************************************/
1972:          static void USBStdSetCfgHandler(void)
1973:          {
1974:              uint8_t i;
1975:          
1976:              // This will generate a zero length packet
1977:              inPipes[0].info.bits.busy = 1;            
1EFA  8E12     BSF 0x12, 7, ACCESS
1978:          
1979:              //Clear all of the endpoint control registers
1980:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
1EFC  0E6B     MOVLW 0x6B
1EFE  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1F00  0E0F     MOVLW 0xF
1F02  6E2D     MOVWF data, ACCESS
1F04  0E00     MOVLW 0x0
1F06  6E2F     MOVWF len, ACCESS
1F08  0E00     MOVLW 0x0
1F0A  6E2E     MOVWF p, ACCESS
1F0C  0E00     MOVLW 0x0
1F0E  6E31     MOVWF EPNum, ACCESS
1F10  0E02     MOVLW 0x2
1F12  6E30     MOVWF n, ACCESS
1F14  ECD3     CALL 0xFA6, 0
1F16  F007     NOP
1981:          
1982:              //Clear all of the BDT entries
1983:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
1F18  0E00     MOVLW 0x0
1F1A  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1F1C  0E04     MOVLW 0x4
1F1E  6E2D     MOVWF data, ACCESS
1F20  0E00     MOVLW 0x0
1F22  6E2F     MOVWF len, ACCESS
1F24  0E00     MOVLW 0x0
1F26  6E2E     MOVWF p, ACCESS
1F28  0E00     MOVLW 0x0
1F2A  6E31     MOVWF EPNum, ACCESS
1F2C  0E30     MOVLW 0x30
1F2E  6E30     MOVWF n, ACCESS
1F30  ECD3     CALL 0xFA6, 0
1F32  F007     NOP
1984:          
1985:              // Assert reset request to all of the Ping Pong buffer pointers
1986:              USBPingPongBufferReset = 1;                                   
1F34  8C60     BSF UCON, 6, ACCESS
1987:          
1988:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1989:          	//the EVEN buffer being the next one that will be used), since we are also 
1990:          	//doing a hardware ping pong pointer reset above.
1991:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
1F36  0E00     MOVLW 0x0
1F38  6E40     MOVWF i, ACCESS
1992:          	{
1993:          		ep_data_in[i].Val = 0u;
1F3A  0E7B     MOVLW 0x7B
1F3C  2440     ADDWF i, W, ACCESS
1F3E  6ED9     MOVWF FSR2, ACCESS
1F40  6ADA     CLRF FSR2H, ACCESS
1F42  0E00     MOVLW 0x0
1F44  22DA     ADDWFC FSR2H, F, ACCESS
1F46  0E00     MOVLW 0x0
1F48  6EDF     MOVWF INDF2, ACCESS
1994:                  ep_data_out[i].Val = 0u;
1F4A  0E78     MOVLW 0x78
1F4C  2440     ADDWF i, W, ACCESS
1F4E  6ED9     MOVWF FSR2, ACCESS
1F50  6ADA     CLRF FSR2H, ACCESS
1F52  0E00     MOVLW 0x0
1F54  22DA     ADDWFC FSR2H, F, ACCESS
1F56  0E00     MOVLW 0x0
1F58  6EDF     MOVWF INDF2, ACCESS
1995:          	}
1F5A  2A40     INCF i, F, ACCESS
1F5C  0E02     MOVLW 0x2
1F5E  6440     CPFSGT i, ACCESS
1F60  EFB4     GOTO 0x1F68
1F62  F00F     NOP
1F64  EFB6     GOTO 0x1F6C
1F66  F00F     NOP
1F68  EF9D     GOTO 0x1F3A
1F6A  F00F     NOP
1996:          
1997:              //clear the alternate interface settings
1998:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
1F6C  0EDB     MOVLW 0xDB
1F6E  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1F70  0E00     MOVLW 0x0
1F72  6E2D     MOVWF data, ACCESS
1F74  0E00     MOVLW 0x0
1F76  6E2F     MOVWF len, ACCESS
1F78  0E00     MOVLW 0x0
1F7A  6E2E     MOVWF p, ACCESS
1F7C  0E00     MOVLW 0x0
1F7E  6E31     MOVWF EPNum, ACCESS
1F80  0E02     MOVLW 0x2
1F82  6E30     MOVWF n, ACCESS
1F84  ECD3     CALL 0xFA6, 0
1F86  F007     NOP
1999:          
2000:              //Stop trying to reset ping pong buffer pointers
2001:              USBPingPongBufferReset = 0;
1F88  9C60     BCF UCON, 6, ACCESS
2002:          
2003:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
1F8A  0E08     MOVLW 0x8
1F8C  6E09     MOVWF pBDTEntryIn, ACCESS
1F8E  0E04     MOVLW 0x4
1F90  6E0A     MOVWF 0xA, ACCESS
2004:          
2005:          	//Set the next out to the current out packet
2006:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
1F92  0E00     MOVLW 0x0
1F94  6E17     MOVWF pBDTEntryEP0OutCurrent, ACCESS
1F96  0E04     MOVLW 0x4
1F98  6E18     MOVWF 0x18, ACCESS
2007:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
1F9A  C017     MOVFF pBDTEntryEP0OutCurrent, pBDTEntryEP0OutNext
1F9C  F015     NOP
1F9E  C018     MOVFF 0x18, 0x16
1FA0  F016     NOP
2008:          
2009:              //set the current configuration
2010:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
1FA2  C432     MOVFF 0x432, USBActiveConfiguration
1FA4  F02B     NOP
2011:          
2012:              //if the configuration value == 0
2013:              if(USBActiveConfiguration == 0)
1FA6  502B     MOVF USBActiveConfiguration, W, ACCESS
1FA8  A4D8     BTFSS STATUS, 2, ACCESS
1FAA  EFD9     GOTO 0x1FB2
1FAC  F00F     NOP
1FAE  EFDB     GOTO 0x1FB6
1FB0  F00F     NOP
1FB2  EFDF     GOTO 0x1FBE
1FB4  F00F     NOP
2014:              {
2015:                  //Go back to the addressed state
2016:                  USBDeviceState = ADDRESS_STATE;
1FB6  0E10     MOVLW 0x10
1FB8  6E29     MOVWF USBDeviceState, ACCESS
2017:              }
1FBA  EFEF     GOTO 0x1FDE
1FBC  F00F     NOP
2018:              else
2019:              {
2020:                  //initialize the required endpoints
2021:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
1FBE  0E00     MOVLW 0x0
1FC0  6E39     MOVWF 0x39, ACCESS
1FC2  0E01     MOVLW 0x1
1FC4  6E38     MOVWF USBDeviceInit, ACCESS
1FC6  0E2B     MOVLW 0x2B
1FC8  6E3A     MOVWF pdata, ACCESS
1FCA  0E00     MOVLW 0x0
1FCC  6E3B     MOVWF 0x3B, ACCESS
1FCE  0E00     MOVLW 0x0
1FD0  6E3D     MOVWF 0x3D, ACCESS
1FD2  0E01     MOVLW 0x1
1FD4  6E3C     MOVWF size, ACCESS
1FD6  EC41     CALL 0x2282, 0
1FD8  F011     NOP
2022:          
2023:                  //Otherwise go to the configured state.  Update the state variable last,
2024:                  //after performing all of the set configuration related initialization
2025:                  //tasks.
2026:                  USBDeviceState = CONFIGURED_STATE;		
1FDA  0E20     MOVLW 0x20
1FDC  6E29     MOVWF USBDeviceState, ACCESS
2027:              }//end if(SetupPkt.bConfigurationValue == 0)
2028:          }//end USBStdSetCfgHandler
1FDE  0012     RETURN 0
2029:          
2030:          
2031:          /********************************************************************
2032:           * Function:        void USBStdGetDscHandler(void)
2033:           *
2034:           * PreCondition:    None
2035:           *
2036:           * Input:           None
2037:           *
2038:           * Output:          None
2039:           *
2040:           * Side Effects:    None
2041:           *
2042:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2043:           *                  request.
2044:           *
2045:           * Note:            None
2046:           *******************************************************************/
2047:          static void USBStdGetDscHandler(void)
2048:          {
2049:              if(SetupPkt.bmRequestType == 0x80)
111C  0E80     MOVLW 0x80
111E  0104     MOVLB 0x4
1120  1930     XORWF n, W, BANKED
1122  A4D8     BTFSS STATUS, 2, ACCESS
1124  EF96     GOTO 0x112C
1126  F008     NOP
1128  EF98     GOTO 0x1130
112A  F008     NOP
112C  EF3D     GOTO 0x127A
112E  F009     NOP
2050:              {
2051:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
1130  0EC0     MOVLW 0xC0
1132  6E12     MOVWF 0x12, ACCESS
2052:          
2053:                  switch(SetupPkt.bDescriptorType)
1134  EF24     GOTO 0x1248
1136  F009     NOP
2054:                  {
2055:                      case USB_DESCRIPTOR_DEVICE:
2056:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2057:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2058:                          #else
2059:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
1138  0E9A     MOVLW 0x9A
113A  6E0F     MOVWF inPipes, ACCESS
113C  0E08     MOVLW 0x8
113E  6E10     MOVWF 0x10, ACCESS
2060:                          #endif
2061:                          inPipes[0].wCount.Val = sizeof(device_dsc);
1140  0E00     MOVLW 0x0
1142  6E14     MOVWF 0x14, ACCESS
1144  0E12     MOVLW 0x12
1146  6E13     MOVWF 0x13, ACCESS
2062:                          break;
1148  EF3D     GOTO 0x127A
114A  F009     NOP
2063:                      case USB_DESCRIPTOR_CONFIGURATION:
2064:                          //First perform error case check, to make sure the host is requesting a 
2065:                          //legal descriptor index.  If the request index is illegal, don't do 
2066:                          //anything (so that the default STALL response will be sent).
2067:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
114C  5132     MOVF handle, W, BANKED
114E  A4D8     BTFSS STATUS, 2, ACCESS
1150  EFAC     GOTO 0x1158
1152  F008     NOP
1154  EFAE     GOTO 0x115C
1156  F008     NOP
1158  EFEC     GOTO 0x11D8
115A  F008     NOP
2068:                          {
2069:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2070:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2071:                              #else
2072:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
115C  5132     MOVF handle, W, BANKED
115E  0D02     MULLW 0x2
1160  0E07     MOVLW 0x7
1162  24F3     ADDWF PROD, W, ACCESS
1164  6EF6     MOVWF TBLPTR, ACCESS
1166  0E08     MOVLW 0x8
1168  20F4     ADDWFC PRODH, W, ACCESS
116A  6EF7     MOVWF TBLPTRH, ACCESS
116C  0009     TBLRD*+
116E  CFF5     MOVFF TABLAT, inPipes
1170  F00F     NOP
1172  000A     TBLRD*-
1174  CFF5     MOVFF TABLAT, 0x10
1176  F010     NOP
2073:                              #endif
2074:          
2075:                              //This must be loaded using byte addressing.  The source pointer
2076:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2077:                              //  in an address error on the dereference.
2078:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
1178  0E02     MOVLW 0x2
117A  240F     ADDWF inPipes, W, ACCESS
117C  6E2C     MOVWF __pcstackCOMRAM, ACCESS
117E  0E00     MOVLW 0x0
1180  2010     ADDWFC 0x10, W, ACCESS
1182  6E2D     MOVWF data, ACCESS
1184  C02C     MOVFF __pcstackCOMRAM, TBLPTR
1186  FFF6     NOP
1188  C02D     MOVFF data, TBLPTRH
118A  FFF7     NOP
118C  6AF8     CLRF TBLPTRU, ACCESS
118E  0E07     MOVLW 0x7
1190  64F7     CPFSGT TBLPTRH, ACCESS
1192  D003     BRA 0x119A
1194  0008     TBLRD*
1196  50F5     MOVF TABLAT, W, ACCESS
1198  D005     BRA 0x11A4
119A  CFF6     MOVFF TBLPTR, FSR0
119C  FFE9     NOP
119E  CFF7     MOVFF TBLPTRH, FSR0H
11A0  FFEA     NOP
11A2  50EF     MOVF INDF0, W, ACCESS
11A4  6E13     MOVWF 0x13, ACCESS
2079:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
11A6  0E03     MOVLW 0x3
11A8  240F     ADDWF inPipes, W, ACCESS
11AA  6E2C     MOVWF __pcstackCOMRAM, ACCESS
11AC  0E00     MOVLW 0x0
11AE  2010     ADDWFC 0x10, W, ACCESS
11B0  6E2D     MOVWF data, ACCESS
11B2  C02C     MOVFF __pcstackCOMRAM, TBLPTR
11B4  FFF6     NOP
11B6  C02D     MOVFF data, TBLPTRH
11B8  FFF7     NOP
11BA  6AF8     CLRF TBLPTRU, ACCESS
11BC  0E07     MOVLW 0x7
11BE  64F7     CPFSGT TBLPTRH, ACCESS
11C0  D003     BRA 0x11C8
11C2  0008     TBLRD*
11C4  50F5     MOVF TABLAT, W, ACCESS
11C6  D005     BRA 0x11D2
11C8  CFF6     MOVFF TBLPTR, FSR0
11CA  FFE9     NOP
11CC  CFF7     MOVFF TBLPTRH, FSR0H
11CE  FFEA     NOP
11D0  50EF     MOVF INDF0, W, ACCESS
11D2  6E14     MOVWF 0x14, ACCESS
2080:                          }
11D4  EF3D     GOTO 0x127A
11D6  F009     NOP
2081:          				else
2082:          				{
2083:          					inPipes[0].info.Val = 0;
11D8  0E00     MOVLW 0x0
11DA  6E12     MOVWF 0x12, ACCESS
11DC  EF3D     GOTO 0x127A
11DE  F009     NOP
2084:          				}
2085:                          break;
2086:                      case USB_DESCRIPTOR_STRING:
2087:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2088:                          //  later it is now mandatory.  This should be defined in usb_device_config.h and should
2089:                          //  indicate the number of string descriptors.
2090:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
11E0  0E03     MOVLW 0x3
11E2  6132     CPFSLT handle, BANKED
11E4  EFF6     GOTO 0x11EC
11E6  F008     NOP
11E8  EFF8     GOTO 0x11F0
11EA  F008     NOP
11EC  EF1C     GOTO 0x1238
11EE  F009     NOP
2091:                          {
2092:                              //Get a pointer to the String descriptor requested
2093:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
11F0  5132     MOVF handle, W, BANKED
11F2  0D02     MULLW 0x2
11F4  0E01     MOVLW 0x1
11F6  24F3     ADDWF PROD, W, ACCESS
11F8  6EF6     MOVWF TBLPTR, ACCESS
11FA  0E08     MOVLW 0x8
11FC  20F4     ADDWFC PRODH, W, ACCESS
11FE  6EF7     MOVWF TBLPTRH, ACCESS
1200  0009     TBLRD*+
1202  CFF5     MOVFF TABLAT, inPipes
1204  F00F     NOP
1206  000A     TBLRD*-
1208  CFF5     MOVFF TABLAT, 0x10
120A  F010     NOP
2094:                              // Set data count
2095:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
120C  C00F     MOVFF inPipes, TBLPTR
120E  FFF6     NOP
1210  C010     MOVFF 0x10, TBLPTRH
1212  FFF7     NOP
1214  6AF8     CLRF TBLPTRU, ACCESS
1216  0E07     MOVLW 0x7
1218  64F7     CPFSGT TBLPTRH, ACCESS
121A  D003     BRA 0x1222
121C  0008     TBLRD*
121E  50F5     MOVF TABLAT, W, ACCESS
1220  D005     BRA 0x122C
1222  CFF6     MOVFF TBLPTR, FSR0
1224  FFE9     NOP
1226  CFF7     MOVFF TBLPTRH, FSR0H
1228  FFEA     NOP
122A  50EF     MOVF INDF0, W, ACCESS
122C  6E2C     MOVWF __pcstackCOMRAM, ACCESS
122E  502C     MOVF __pcstackCOMRAM, W, ACCESS
1230  6E13     MOVWF 0x13, ACCESS
1232  6A14     CLRF 0x14, ACCESS
2096:                          }
1234  EF3D     GOTO 0x127A
1236  F009     NOP
2097:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2098:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2099:                          {
2100:                              //Get a pointer to the special MS OS string descriptor requested
2101:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2102:                              // Set data count
2103:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2104:                          }    
2105:                          #endif
2106:                          else
2107:                          {
2108:                              inPipes[0].info.Val = 0;
1238  0E00     MOVLW 0x0
123A  6E12     MOVWF 0x12, ACCESS
123C  EF3D     GOTO 0x127A
123E  F009     NOP
2109:                          }
2110:                          break;
2111:                      default:
2112:                          inPipes[0].info.Val = 0;
1240  0E00     MOVLW 0x0
1242  6E12     MOVWF 0x12, ACCESS
2113:                          break;
1244  EF3D     GOTO 0x127A
1246  F009     NOP
2114:                  }//end switch
1248  5133     MOVF 0x33, W, BANKED
124A  6E2C     MOVWF __pcstackCOMRAM, ACCESS
124C  6A2D     CLRF data, ACCESS
124E  502D     MOVF data, W, ACCESS
1250  0A00     XORLW 0x0
1252  B4D8     BTFSC STATUS, 2, ACCESS
1254  EF2E     GOTO 0x125C
1256  F009     NOP
1258  EF20     GOTO 0x1240
125A  F009     NOP
125C  502C     MOVF __pcstackCOMRAM, W, ACCESS
125E  0A01     XORLW 0x1
1260  B4D8     BTFSC STATUS, 2, ACCESS
1262  EF9C     GOTO 0x1138
1264  F008     NOP
1266  0A03     XORLW 0x3
1268  B4D8     BTFSC STATUS, 2, ACCESS
126A  EFA6     GOTO 0x114C
126C  F008     NOP
126E  0A01     XORLW 0x1
1270  B4D8     BTFSC STATUS, 2, ACCESS
1272  EFF0     GOTO 0x11E0
1274  F008     NOP
1276  EF20     GOTO 0x1240
1278  F009     NOP
2115:              }//end if
2116:          }//end USBStdGetDscHandler
127A  0012     RETURN 0
2117:          
2118:          /********************************************************************
2119:           * Function:        void USBStdGetStatusHandler(void)
2120:           *
2121:           * PreCondition:    None
2122:           *
2123:           * Input:           None
2124:           *
2125:           * Output:          None
2126:           *
2127:           * Side Effects:    None
2128:           *
2129:           * Overview:        This routine handles the standard GET_STATUS request
2130:           *
2131:           * Note:            None
2132:           *******************************************************************/
2133:          static void USBStdGetStatusHandler(void)
2134:          {
2135:              CtrlTrfData[0] = 0;                 // Initialize content
1C06  0E00     MOVLW 0x0
1C08  0104     MOVLB 0x4
1C0A  6F38     MOVWF USBDeviceInit, BANKED
2136:              CtrlTrfData[1] = 0;
1C0C  0E00     MOVLW 0x0
1C0E  6F39     MOVWF 0x39, BANKED
2137:          
2138:              switch(SetupPkt.Recipient)
1C10  EF5B     GOTO 0x1CB6
1C12  F00E     NOP
2139:              {
2140:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2141:                      inPipes[0].info.bits.busy = 1;
1C14  8E12     BSF 0x12, 7, ACCESS
2142:                      /*
2143:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2144:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2145:                       */
2146:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2147:                      {
2148:                          CtrlTrfData[0]|=0x01;
2149:                      }
2150:          
2151:                      if(RemoteWakeup == true)
1C16  0423     DECF RemoteWakeup, W, ACCESS
1C18  A4D8     BTFSS STATUS, 2, ACCESS
1C1A  EF11     GOTO 0x1C22
1C1C  F00E     NOP
1C1E  EF13     GOTO 0x1C26
1C20  F00E     NOP
1C22  EF75     GOTO 0x1CEA
1C24  F00E     NOP
2152:                      {
2153:                          CtrlTrfData[0]|=0x02;
1C26  8338     BSF USBDeviceInit, 1, BANKED
1C28  EF75     GOTO 0x1CEA
1C2A  F00E     NOP
2154:                      }
2155:                      break;
2156:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2157:                      inPipes[0].info.bits.busy = 1;     // No data to update
1C2C  8E12     BSF 0x12, 7, ACCESS
2158:                      break;
1C2E  EF75     GOTO 0x1CEA
1C30  F00E     NOP
2159:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2160:                      inPipes[0].info.bits.busy = 1;
1C32  8E12     BSF 0x12, 7, ACCESS
2161:                      /*
2162:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2163:                       */
2164:                      {
2165:                          BDT_ENTRY *p;
2166:          
2167:                          if(SetupPkt.EPDir == 0)
1C34  BF34     BTFSC ep, 7, BANKED
1C36  EF1F     GOTO 0x1C3E
1C38  F00E     NOP
1C3A  EF21     GOTO 0x1C42
1C3C  F00E     NOP
1C3E  EF32     GOTO 0x1C64
1C40  F00E     NOP
2168:                          {
2169:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
1C42  5134     MOVF ep, W, BANKED
1C44  0B0F     ANDLW 0xF
1C46  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1C48  502C     MOVF __pcstackCOMRAM, W, ACCESS
1C4A  0D02     MULLW 0x2
1C4C  0E6A     MOVLW 0x6A
1C4E  24F3     ADDWF PROD, W, ACCESS
1C50  6ED9     MOVWF FSR2, ACCESS
1C52  0E00     MOVLW 0x0
1C54  20F4     ADDWFC PRODH, W, ACCESS
1C56  6EDA     MOVWF FSR2H, ACCESS
1C58  CFDE     MOVFF POSTINC2, p
1C5A  F02E     NOP
1C5C  CFDD     MOVFF POSTDEC2, len
1C5E  F02F     NOP
2170:                          }
1C60  EF41     GOTO 0x1C82
1C62  F00E     NOP
2171:                          else
2172:                          {
2173:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
1C64  5134     MOVF ep, W, BANKED
1C66  0B0F     ANDLW 0xF
1C68  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1C6A  502C     MOVF __pcstackCOMRAM, W, ACCESS
1C6C  0D02     MULLW 0x2
1C6E  0E09     MOVLW 0x9
1C70  24F3     ADDWF PROD, W, ACCESS
1C72  6ED9     MOVWF FSR2, ACCESS
1C74  0E00     MOVLW 0x0
1C76  20F4     ADDWFC PRODH, W, ACCESS
1C78  6EDA     MOVWF FSR2H, ACCESS
1C7A  CFDE     MOVFF POSTINC2, p
1C7C  F02E     NOP
1C7E  CFDD     MOVFF POSTDEC2, len
1C80  F02F     NOP
2174:                          }
2175:          
2176:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
1C82  C02E     MOVFF p, FSR2
1C84  FFD9     NOP
1C86  C02F     MOVFF len, FSR2H
1C88  FFDA     NOP
1C8A  AEDF     BTFSS INDF2, 7, ACCESS
1C8C  EF4A     GOTO 0x1C94
1C8E  F00E     NOP
1C90  EF4C     GOTO 0x1C98
1C92  F00E     NOP
1C94  EF75     GOTO 0x1CEA
1C96  F00E     NOP
1C98  C02E     MOVFF p, FSR2
1C9A  FFD9     NOP
1C9C  C02F     MOVFF len, FSR2H
1C9E  FFDA     NOP
1CA0  A4DF     BTFSS INDF2, 2, ACCESS
1CA2  EF55     GOTO 0x1CAA
1CA4  F00E     NOP
1CA6  EF57     GOTO 0x1CAE
1CA8  F00E     NOP
1CAA  EF75     GOTO 0x1CEA
1CAC  F00E     NOP
2177:                              CtrlTrfData[0]=0x01;    // Set bit0
1CAE  0E01     MOVLW 0x1
1CB0  6F38     MOVWF USBDeviceInit, BANKED
1CB2  EF75     GOTO 0x1CEA
1CB4  F00E     NOP
2178:                          break;
2179:                      }
2180:              }//end switch
1CB6  5130     MOVF n, W, BANKED
1CB8  0B1F     ANDLW 0x1F
1CBA  6E2C     MOVWF __pcstackCOMRAM, ACCESS
1CBC  6A2D     CLRF data, ACCESS
1CBE  502D     MOVF data, W, ACCESS
1CC0  0A00     XORLW 0x0
1CC2  B4D8     BTFSC STATUS, 2, ACCESS
1CC4  EF66     GOTO 0x1CCC
1CC6  F00E     NOP
1CC8  EF75     GOTO 0x1CEA
1CCA  F00E     NOP
1CCC  502C     MOVF __pcstackCOMRAM, W, ACCESS
1CCE  0A00     XORLW 0x0
1CD0  B4D8     BTFSC STATUS, 2, ACCESS
1CD2  EF0A     GOTO 0x1C14
1CD4  F00E     NOP
1CD6  0A01     XORLW 0x1
1CD8  B4D8     BTFSC STATUS, 2, ACCESS
1CDA  EF16     GOTO 0x1C2C
1CDC  F00E     NOP
1CDE  0A03     XORLW 0x3
1CE0  B4D8     BTFSC STATUS, 2, ACCESS
1CE2  EF19     GOTO 0x1C32
1CE4  F00E     NOP
1CE6  EF75     GOTO 0x1CEA
1CE8  F00E     NOP
2181:          
2182:              if(inPipes[0].info.bits.busy == 1)
1CEA  AE12     BTFSS 0x12, 7, ACCESS
1CEC  EF7A     GOTO 0x1CF4
1CEE  F00E     NOP
1CF0  EF7C     GOTO 0x1CF8
1CF2  F00E     NOP
1CF4  EF83     GOTO 0x1D06
1CF6  F00E     NOP
2183:              {
2184:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
1CF8  0E38     MOVLW 0x38
1CFA  6E0F     MOVWF inPipes, ACCESS
1CFC  0E04     MOVLW 0x4
1CFE  6E10     MOVWF 0x10, ACCESS
2185:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
1D00  8012     BSF 0x12, 0, ACCESS
2186:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
1D02  0E02     MOVLW 0x2
1D04  6E13     MOVWF 0x13, ACCESS
2187:              }//end if(...)
2188:          }//end USBStdGetStatusHandler
1D06  0012     RETURN 0
2189:          
2190:          /********************************************************************
2191:           * Function:        void USBStallHandler(void)
2192:           *
2193:           * PreCondition:    None
2194:           *
2195:           * Input:           None
2196:           *
2197:           * Output:          None
2198:           *
2199:           * Side Effects:    
2200:           *
2201:           * Overview:        This function handles the event of a STALL 
2202:           *                  occurring on the bus
2203:           *
2204:           * Note:            None
2205:           *******************************************************************/
2206:          static void USBStallHandler(void)
2207:          {
2208:              /*
2209:               * Does not really have to do anything here,
2210:               * even for the control endpoint.
2211:               * All BDs of Endpoint 0 are owned by SIE right now,
2212:               * but once a Setup Transaction is received, the ownership
2213:               * for EP0_OUT will be returned to CPU.
2214:               * When the Setup Transaction is serviced, the ownership
2215:               * for EP0_IN will then be forced back to CPU by firmware.
2216:               */
2217:          
2218:              if(U1EP0bits.EPSTALL == 1)
23E2  A06A     BTFSS UEP0, 0, ACCESS
23E4  EFF6     GOTO 0x23EC
23E6  F011     NOP
23E8  EFF8     GOTO 0x23F0
23EA  F011     NOP
23EC  EF1F     GOTO 0x243E
23EE  F012     NOP
2219:              {
2220:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2221:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
23F0  C017     MOVFF pBDTEntryEP0OutCurrent, FSR2
23F2  FFD9     NOP
23F4  C018     MOVFF 0x18, FSR2H
23F6  FFDA     NOP
23F8  0E80     MOVLW 0x80
23FA  18DE     XORWF POSTINC2, W, ACCESS
23FC  A4D8     BTFSS STATUS, 2, ACCESS
23FE  EF03     GOTO 0x2406
2400  F012     NOP
2402  EF05     GOTO 0x240A
2404  F012     NOP
2406  EF1E     GOTO 0x243C
2408  F012     NOP
240A  C009     MOVFF pBDTEntryIn, FSR2
240C  FFD9     NOP
240E  C00A     MOVFF 0xA, FSR2H
2410  FFDA     NOP
2412  0E84     MOVLW 0x84
2414  18DE     XORWF POSTINC2, W, ACCESS
2416  A4D8     BTFSS STATUS, 2, ACCESS
2418  EF10     GOTO 0x2420
241A  F012     NOP
241C  EF12     GOTO 0x2424
241E  F012     NOP
2420  EF1E     GOTO 0x243C
2422  F012     NOP
2222:                  {
2223:                      // Set ep0Bo to stall also
2224:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
2424  C017     MOVFF pBDTEntryEP0OutCurrent, FSR2
2426  FFD9     NOP
2428  C018     MOVFF 0x18, FSR2H
242A  FFDA     NOP
242C  0E0C     MOVLW 0xC
242E  6EDF     MOVWF INDF2, ACCESS
2225:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
2430  C017     MOVFF pBDTEntryEP0OutCurrent, FSR2
2432  FFD9     NOP
2434  C018     MOVFF 0x18, FSR2H
2436  FFDA     NOP
2438  0E00     MOVLW 0x0
243A  8EDB     BSF PLUSW2, 7, ACCESS
2226:                  }//end if
2227:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
243C  906A     BCF UEP0, 0, ACCESS
2228:              }//end if
2229:          
2230:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
243E  9A65     BCF UIR, 5, ACCESS
2231:          }
2440  0012     RETURN 0
2232:          
2233:          /********************************************************************
2234:           * Function:        void USBSuspend(void)
2235:           *
2236:           * PreCondition:    None
2237:           *
2238:           * Input:           None
2239:           *
2240:           * Output:          None
2241:           *
2242:           * Side Effects:    
2243:           *
2244:           * Overview:        This function handles if the host tries to 
2245:           *                  suspend the device
2246:           *
2247:           * Note:            None
2248:           *******************************************************************/
2249:          static void USBSuspend(void)
2250:          {
2251:              /*
2252:               * NOTE: Do not clear UIRbits.ACTVIF here!
2253:               * Reason:
2254:               * ACTVIF is only generated once an IDLEIF has been generated.
2255:               * This is a 1:1 ratio interrupt generation.
2256:               * For every IDLEIF, there will be only one ACTVIF regardless of
2257:               * the number of subsequent bus transitions.
2258:               *
2259:               * If the ACTIF is cleared here, a problem could occur when:
2260:               * [       IDLE       ][bus activity ->
2261:               * <--- 3 ms ----->     ^
2262:               *                ^     ACTVIF=1
2263:               *                IDLEIF=1
2264:               *  #           #           #           #   (#=Program polling flags)
2265:               *                          ^
2266:               *                          This polling loop will see both
2267:               *                          IDLEIF=1 and ACTVIF=1.
2268:               *                          However, the program services IDLEIF first
2269:               *                          because ACTIVIE=0.
2270:               *                          If this routine clears the only ACTIVIF,
2271:               *                          then it can never get out of the suspend
2272:               *                          mode.
2273:               */
2274:              USBActivityIE = 1;                     // Enable bus activity interrupt
2604  8464     BSF UIE, 2, ACCESS
2275:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
2606  9865     BCF UIR, 4, ACCESS
2276:          
2277:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2278:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
2608  8260     BSF UCON, 1, ACCESS
2279:                                                          // mode, SIE clock inactive
2280:              #endif
2281:              USBBusIsSuspended = true;
260A  0E01     MOVLW 0x1
260C  6E22     MOVWF USBBusIsSuspended, ACCESS
2282:              USBTicksSinceSuspendEnd = 0;
260E  0E00     MOVLW 0x0
2610  0100     MOVLB 0x0
2612  6F88     MOVWF USBTicksSinceSuspendEnd, BANKED
2283:           
2284:              /*
2285:               * At this point the PIC can go into sleep,idle, or
2286:               * switch to a slower clock, etc.  This should be done in the
2287:               * USBCBSuspend() if necessary.
2288:               */
2289:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
2614  0E00     MOVLW 0x0
2616  6E39     MOVWF 0x39, ACCESS
2618  0E75     MOVLW 0x75
261A  6E38     MOVWF USBDeviceInit, ACCESS
261C  0E00     MOVLW 0x0
261E  6E3A     MOVWF pdata, ACCESS
2620  0E00     MOVLW 0x0
2622  6E3B     MOVWF 0x3B, ACCESS
2624  0E00     MOVLW 0x0
2626  6E3D     MOVWF 0x3D, ACCESS
2628  0E00     MOVLW 0x0
262A  6E3C     MOVWF size, ACCESS
262C  EC41     CALL 0x2282, 0
262E  F011     NOP
2290:          }
2630  0012     RETURN 0
2291:          
2292:          /********************************************************************
2293:           * Function:        void USBWakeFromSuspend(void)
2294:           *
2295:           * PreCondition:    None
2296:           *
2297:           * Input:           None
2298:           *
2299:           * Output:          None
2300:           *
2301:           * Side Effects:    None
2302:           *
2303:           * Overview:
2304:           *
2305:           * Note:            None
2306:           *******************************************************************/
2307:          static void USBWakeFromSuspend(void)
2308:          {
2309:              USBBusIsSuspended = false;
2520  0E00     MOVLW 0x0
2522  6E22     MOVWF USBBusIsSuspended, ACCESS
2310:          
2311:              /*
2312:               * If using clock switching, the place to restore the original
2313:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2314:               */
2315:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
2524  0E00     MOVLW 0x0
2526  6E39     MOVWF 0x39, ACCESS
2528  0E74     MOVLW 0x74
252A  6E38     MOVWF USBDeviceInit, ACCESS
252C  0E00     MOVLW 0x0
252E  6E3A     MOVWF pdata, ACCESS
2530  0E00     MOVLW 0x0
2532  6E3B     MOVWF 0x3B, ACCESS
2534  0E00     MOVLW 0x0
2536  6E3D     MOVWF 0x3D, ACCESS
2538  0E00     MOVLW 0x0
253A  6E3C     MOVWF size, ACCESS
253C  EC41     CALL 0x2282, 0
253E  F011     NOP
2316:          
2317:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2318:                  //To avoid improperly clocking the USB module, make sure the oscillator
2319:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2320:                  //Make sure the correct oscillator settings are selected in the 
2321:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2322:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
2540  9260     BCF UCON, 1, ACCESS
2323:                                          // mode.
2324:              #endif
2325:          
2326:          
2327:              USBActivityIE = 0;
2542  9464     BCF UIE, 2, ACCESS
2328:          
2329:              /********************************************************************
2330:              Bug Fix: Feb 26, 2007 v2.1
2331:              *********************************************************************
2332:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2333:              up from Suspend or while the USB module is suspended. A few clock cycles
2334:              are required to synchronize the internal hardware state machine before
2335:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2336:              before the internal hardware is synchronized may not have an effect on
2337:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2338:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2339:              module may not be immediately operational while waiting for the 96 MHz
2340:              PLL to lock.
2341:              ********************************************************************/
2342:          
2343:              // UIRbits.ACTVIF = 0;                      // Removed
2344:              #if defined(__18CXX) || defined(__XC8)
2345:              while(USBActivityIF)
2544  EFA5     GOTO 0x254A
2546  F012     NOP
254A  B465     BTFSC UIR, 2, ACCESS
254C  EFAA     GOTO 0x2554
254E  F012     NOP
2550  EFAC     GOTO 0x2558
2552  F012     NOP
2554  EFA4     GOTO 0x2548
2556  F012     NOP
2346:              #endif
2347:              {
2348:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
2548  9465     BCF UIR, 2, ACCESS
2349:              }  // Added
2350:          
2351:              USBTicksSinceSuspendEnd = 0;
2558  0E00     MOVLW 0x0
255A  0100     MOVLB 0x0
255C  6F88     MOVWF USBTicksSinceSuspendEnd, BANKED
2352:          
2353:          }//end USBWakeFromSuspend
255E  0012     RETURN 0
2354:          
2355:          /********************************************************************
2356:           * Function:        void USBCtrlEPService(void)
2357:           *
2358:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2359:           *
2360:           * Input:           None
2361:           *
2362:           * Output:          None
2363:           *
2364:           * Side Effects:    None
2365:           *
2366:           * Overview:        USBCtrlEPService checks for three transaction
2367:           *                  types that it knows how to service and services
2368:           *                  them:
2369:           *                  1. EP0 SETUP
2370:           *                  2. EP0 OUT
2371:           *                  3. EP0 IN
2372:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2373:           *
2374:           * Note:            None
2375:           *******************************************************************/
2376:          static void USBCtrlEPService(void)
2377:          {
2378:              //If we get to here, that means a successful transaction has just occurred 
2379:              //on EP0.  This means "progress" has occurred in the currently pending 
2380:              //control transfer, so we should re-initialize our timeout counter.
2381:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2382:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
1FE0  0E2D     MOVLW 0x2D
1FE2  6E1F     MOVWF USBStatusStageTimeoutCounter, ACCESS
2383:              #endif
2384:          	
2385:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2386:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
1FE4  C02A     MOVFF USTATcopy, 0x49
1FE6  F049     NOP
1FE8  0EFD     MOVLW 0xFD
1FEA  1649     ANDWF 0x49, F, ACCESS
1FEC  A4D8     BTFSS STATUS, 2, ACCESS
1FEE  EFFB     GOTO 0x1FF6
1FF0  F00F     NOP
1FF2  EFFD     GOTO 0x1FFA
1FF4  F00F     NOP
1FF6  EF3F     GOTO 0x207E
1FF8  F010     NOP
2387:              {
2388:          		//Point to the EP0 OUT buffer of the buffer that arrived
2389:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2390:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
1FFA  C02A     MOVFF USTATcopy, 0x49
1FFC  F049     NOP
1FFE  90D8     BCF STATUS, 0, ACCESS
2000  3249     RRCF 0x49, F, ACCESS
2002  0E3F     MOVLW 0x3F
2004  1649     ANDWF 0x49, F, ACCESS
2006  5049     MOVF 0x49, W, ACCESS
2008  0D04     MULLW 0x4
200A  0E00     MOVLW 0x0
200C  24F3     ADDWF PROD, W, ACCESS
200E  6E17     MOVWF pBDTEntryEP0OutCurrent, ACCESS
2010  0E04     MOVLW 0x4
2012  20F4     ADDWFC PRODH, W, ACCESS
2014  6E18     MOVWF 0x18, ACCESS
2391:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2392:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2393:                  #else
2394:                      #error "unimplemented"
2395:                  #endif
2396:          
2397:          		//Set the next out to the current out packet
2398:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
2016  C017     MOVFF pBDTEntryEP0OutCurrent, pBDTEntryEP0OutNext
2018  F015     NOP
201A  C018     MOVFF 0x18, 0x16
201C  F016     NOP
2399:          		//Toggle it to the next ping pong buffer (if applicable)
2400:                  pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
201E  0E04     MOVLW 0x4
2020  1815     XORWF pBDTEntryEP0OutNext, W, ACCESS
2022  6E15     MOVWF pBDTEntryEP0OutNext, ACCESS
2024  5016     MOVF 0x16, W, ACCESS
2026  6E16     MOVWF 0x16, ACCESS
2401:          
2402:          		//If the current EP0 OUT buffer has a SETUP packet
2403:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
2028  C017     MOVFF pBDTEntryEP0OutCurrent, FSR2
202A  FFD9     NOP
202C  C018     MOVFF 0x18, FSR2H
202E  FFDA     NOP
2030  30DF     RRCF INDF2, W, ACCESS
2032  32E8     RRCF WREG, F, ACCESS
2034  0B0F     ANDLW 0xF
2036  0A0D     XORLW 0xD
2038  A4D8     BTFSS STATUS, 2, ACCESS
203A  EF21     GOTO 0x2042
203C  F010     NOP
203E  EF23     GOTO 0x2046
2040  F010     NOP
2042  EF3B     GOTO 0x2076
2044  F010     NOP
2404:                  {
2405:          	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2406:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2407:          	        //before the transaction.  Therefore, we should copy the data to the 
2408:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2409:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
2046  0E30     MOVLW 0x30
2048  6E2C     MOVWF __pcstackCOMRAM, ACCESS
204A  0E04     MOVLW 0x4
204C  6E2D     MOVWF data, ACCESS
204E  EE20     LFSR 2, 0x2
2050  F002     NOP
2052  5017     MOVF pBDTEntryEP0OutCurrent, W, ACCESS
2054  26D9     ADDWF FSR2, F, ACCESS
2056  5018     MOVF 0x18, W, ACCESS
2058  22DA     ADDWFC FSR2H, F, ACCESS
205A  CFDE     MOVFF POSTINC2, p
205C  F02E     NOP
205E  CFDD     MOVFF POSTDEC2, len
2060  F02F     NOP
2062  0E00     MOVLW 0x0
2064  6E31     MOVWF EPNum, ACCESS
2066  0E08     MOVLW 0x8
2068  6E30     MOVWF n, ACCESS
206A  EC21     CALL 0x2442, 0
206C  F012     NOP
2410:          
2411:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2412:                      USBCtrlTrfSetupHandler();
206E  ECF9     CALL 0x21F2, 0
2070  F010     NOP
2413:                  }
2072  EF4B     GOTO 0x2096
2074  F010     NOP
2414:                  else
2415:                  {
2416:          			//Handle the DATA transfer
2417:                      USBCtrlTrfOutHandler();
2076  EC85     CALL 0x230A, 0
2078  F011     NOP
207A  EF4B     GOTO 0x2096
207C  F010     NOP
2418:                  }
2419:              }
2420:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
207E  502A     MOVF USTATcopy, W, ACCESS
2080  0BFD     ANDLW 0xFD
2082  0A04     XORLW 0x4
2084  A4D8     BTFSS STATUS, 2, ACCESS
2086  EF47     GOTO 0x208E
2088  F010     NOP
208A  EF49     GOTO 0x2092
208C  F010     NOP
208E  EF4B     GOTO 0x2096
2090  F010     NOP
2421:              {
2422:          		//Otherwise the transmission was and EP0 IN
2423:          		//  so take care of the IN transfer
2424:                  USBCtrlTrfInHandler();
2092  EC81     CALL 0x1B02, 0
2094  F00D     NOP
2425:              }
2426:          
2427:          }//end USBCtrlEPService
2096  0012     RETURN 0
2428:          
2429:          /********************************************************************
2430:           * Function:        void USBCtrlTrfSetupHandler(void)
2431:           *
2432:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2433:           *
2434:           * Input:           None
2435:           *
2436:           * Output:          None
2437:           *
2438:           * Side Effects:    None
2439:           *
2440:           * Overview:        This routine is a task dispatcher and has 3 stages.
2441:           *                  1. It initializes the control transfer state machine.
2442:           *                  2. It calls on each of the module that may know how to
2443:           *                     service the Setup Request from the host.
2444:           *                     Module Example: USBD, HID, CDC, MSD, ...
2445:           *                     A callback function, USBCBCheckOtherReq(),
2446:           *                     is required to call other module handlers.
2447:           *                  3. Once each of the modules has had a chance to check if
2448:           *                     it is responsible for servicing the request, stage 3
2449:           *                     then checks direction of the transfer to determine how
2450:           *                     to prepare EP0 for the control transfer.
2451:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2452:           *
2453:           * Note:            Microchip USB Firmware has three different states for
2454:           *                  the control transfer state machine:
2455:           *                  1. WAIT_SETUP
2456:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2457:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2458:           *                  Refer to firmware manual to find out how one state
2459:           *                  is transitioned to another.
2460:           *
2461:           *                  A Control Transfer is composed of many USB transactions.
2462:           *                  When transferring data over multiple transactions,
2463:           *                  it is important to keep track of data source, data
2464:           *                  destination, and data count. These three parameters are
2465:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2466:           *                  note if the data source is from const or RAM.
2467:           *
2468:           *******************************************************************/
2469:          static void USBCtrlTrfSetupHandler(void)
2470:          {
2471:              //--------------------------------------------------------------------------
2472:              //1. Re-initialize state tracking variables related to control transfers.
2473:              //--------------------------------------------------------------------------
2474:              shortPacketStatus = SHORT_PKT_NOT_USED;  
21F2  0E00     MOVLW 0x0
21F4  6E25     MOVWF shortPacketStatus, ACCESS
2475:              USBDeferStatusStagePacket = false;
21F6  0E00     MOVLW 0x0
21F8  6E1E     MOVWF USBDeferStatusStagePacket, ACCESS
2476:              USBDeferINDataStagePackets = false;
21FA  0E00     MOVLW 0x0
21FC  6E1B     MOVWF USBDeferINDataStagePackets, ACCESS
2477:              USBDeferOUTDataStagePackets = false;
21FE  0E00     MOVLW 0x0
2200  0100     MOVLB 0x0
2202  6F89     MOVWF USBDeferOUTDataStagePackets, BANKED
2478:              BothEP0OutUOWNsSet = false;
2204  0E00     MOVLW 0x0
2206  6E20     MOVWF BothEP0OutUOWNsSet, ACCESS
2479:              controlTransferState = WAIT_SETUP;
2208  0E00     MOVLW 0x0
220A  6E24     MOVWF controlTransferState, ACCESS
2480:          
2481:              //Abandon any previous control transfers that might have been using EP0.
2482:              //Ordinarily, nothing actually needs abandoning, since the previous control
2483:              //transfer would have completed successfully prior to the host sending the next
2484:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2485:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2486:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2487:              //by the class request handler that will be called next.
2488:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);  
220C  C009     MOVFF pBDTEntryIn, FSR2
220E  FFD9     NOP
2210  C00A     MOVFF 0xA, FSR2H
2212  FFDA     NOP
2214  0E7F     MOVLW 0x7F
2216  16DF     ANDWF INDF2, F, ACCESS
2489:              
2490:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
2218  0E04     MOVLW 0x4
221A  1809     XORWF pBDTEntryIn, W, ACCESS
221C  6E09     MOVWF pBDTEntryIn, ACCESS
221E  500A     MOVF 0xA, W, ACCESS
2220  6E0A     MOVWF 0xA, ACCESS
2491:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
2222  C009     MOVFF pBDTEntryIn, FSR2
2224  FFD9     NOP
2226  C00A     MOVFF 0xA, FSR2H
2228  FFDA     NOP
222A  0E7F     MOVLW 0x7F
222C  16DF     ANDWF INDF2, F, ACCESS
2492:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
222E  0E04     MOVLW 0x4
2230  1809     XORWF pBDTEntryIn, W, ACCESS
2232  6E09     MOVWF pBDTEntryIn, ACCESS
2234  500A     MOVF 0xA, W, ACCESS
2236  6E0A     MOVWF 0xA, ACCESS
2493:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
2238  C015     MOVFF pBDTEntryEP0OutNext, FSR2
223A  FFD9     NOP
223C  C016     MOVFF 0x16, FSR2H
223E  FFDA     NOP
2240  0E7F     MOVLW 0x7F
2242  16DF     ANDWF INDF2, F, ACCESS
2494:          
2495:              inPipes[0].info.Val = 0;
2244  0E00     MOVLW 0x0
2246  6E12     MOVWF 0x12, ACCESS
2496:              inPipes[0].wCount.Val = 0;
2248  0E00     MOVLW 0x0
224A  6E14     MOVWF 0x14, ACCESS
224C  0E00     MOVLW 0x0
224E  6E13     MOVWF 0x13, ACCESS
2497:              outPipes[0].info.Val = 0;
2250  0E00     MOVLW 0x0
2252  6E04     MOVWF 0x4, ACCESS
2498:              outPipes[0].wCount.Val = 0;
2254  0E00     MOVLW 0x0
2256  6E06     MOVWF 0x6, ACCESS
2258  0E00     MOVLW 0x0
225A  6E05     MOVWF 0x5, ACCESS
2499:              
2500:          
2501:              //--------------------------------------------------------------------------
2502:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2503:              //--------------------------------------------------------------------------
2504:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
225C  EC6B     CALL 0x18D6, 0
225E  F00C     NOP
2505:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
2260  0E00     MOVLW 0x0
2262  6E39     MOVWF 0x39, ACCESS
2264  0E03     MOVLW 0x3
2266  6E38     MOVWF USBDeviceInit, ACCESS
2268  0E00     MOVLW 0x0
226A  6E3A     MOVWF pdata, ACCESS
226C  0E00     MOVLW 0x0
226E  6E3B     MOVWF 0x3B, ACCESS
2270  0E00     MOVLW 0x0
2272  6E3D     MOVWF 0x3D, ACCESS
2274  0E00     MOVLW 0x0
2276  6E3C     MOVWF size, ACCESS
2278  EC41     CALL 0x2282, 0
227A  F011     NOP
2506:          
2507:          
2508:              //--------------------------------------------------------------------------
2509:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2510:              //   progress.  If one of the above handlers (in step 2) knew how to process
2511:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2512:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2513:              //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2514:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2515:              //   process the request.  In this case, the default behavior will be to
2516:              //   perform protocol STALL on EP0.
2517:              //-------------------------------------------------------------------------- 
2518:              USBCtrlEPServiceComplete();
227C  EC8A     CALL 0x1514, 0
227E  F00A     NOP
2519:          }//end USBCtrlTrfSetupHandler
2280  0012     RETURN 0
2520:          
2521:          
2522:          /******************************************************************************
2523:           * Function:        void USBCtrlTrfOutHandler(void)
2524:           *
2525:           * PreCondition:    None
2526:           *
2527:           * Input:           None
2528:           *
2529:           * Output:          None
2530:           *
2531:           * Side Effects:    None
2532:           *
2533:           * Overview:        This routine handles an OUT transaction according to
2534:           *                  which control transfer state is currently active.
2535:           *
2536:           * Note:            Note that if the the control transfer was from
2537:           *                  host to device, the session owner should be notified
2538:           *                  at the end of each OUT transaction to service the
2539:           *                  received data.
2540:           *
2541:           *****************************************************************************/
2542:          static void USBCtrlTrfOutHandler(void)
2543:          {
2544:              if(controlTransferState == CTRL_TRF_RX)
230A  0E02     MOVLW 0x2
230C  1824     XORWF controlTransferState, W, ACCESS
230E  A4D8     BTFSS STATUS, 2, ACCESS
2310  EF8C     GOTO 0x2318
2312  F011     NOP
2314  EF8E     GOTO 0x231C
2316  F011     NOP
2318  EF92     GOTO 0x2324
231A  F011     NOP
2545:              {
2546:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
231C  EC2B     CALL 0x1656, 0
231E  F00B     NOP
2547:              }
2320  EFBE     GOTO 0x237C
2322  F011     NOP
2548:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2549:              {
2550:                  //If the status stage is complete, this means we are done with the 
2551:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2552:                  controlTransferState = WAIT_SETUP;
2324  0E00     MOVLW 0x0
2326  6E24     MOVWF controlTransferState, ACCESS
2553:          
2554:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2555:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2556:                  //and the last control transfer was of direction: device to host, see
2557:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2558:                  //to do anything to the BDT.
2559:                  if(BothEP0OutUOWNsSet == false)
2328  5020     MOVF BothEP0OutUOWNsSet, W, ACCESS
232A  A4D8     BTFSS STATUS, 2, ACCESS
232C  EF9A     GOTO 0x2334
232E  F011     NOP
2330  EF9C     GOTO 0x2338
2332  F011     NOP
2334  EFBC     GOTO 0x2378
2336  F011     NOP
2560:                  {
2561:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
2338  EE20     LFSR 2, 0x1
233A  F001     NOP
233C  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
233E  26D9     ADDWF FSR2, F, ACCESS
2340  5016     MOVF 0x16, W, ACCESS
2342  22DA     ADDWFC FSR2H, F, ACCESS
2344  0E08     MOVLW 0x8
2346  6EDF     MOVWF INDF2, ACCESS
2562:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
2348  EE20     LFSR 2, 0x2
234A  F002     NOP
234C  5015     MOVF pBDTEntryEP0OutNext, W, ACCESS
234E  26D9     ADDWF FSR2, F, ACCESS
2350  5016     MOVF 0x16, W, ACCESS
2352  22DA     ADDWFC FSR2H, F, ACCESS
2354  0E30     MOVLW 0x30
2356  6EDE     MOVWF POSTINC2, ACCESS
2358  0E04     MOVLW 0x4
235A  6EDD     MOVWF POSTDEC2, ACCESS
2563:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
235C  C015     MOVFF pBDTEntryEP0OutNext, FSR2
235E  FFD9     NOP
2360  C016     MOVFF 0x16, FSR2H
2362  FFDA     NOP
2364  0E0C     MOVLW 0xC
2366  6EDF     MOVWF INDF2, ACCESS
2564:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
2368  C015     MOVFF pBDTEntryEP0OutNext, FSR2
236A  FFD9     NOP
236C  C016     MOVFF 0x16, FSR2H
236E  FFDA     NOP
2370  0E00     MOVLW 0x0
2372  8EDB     BSF PLUSW2, 7, ACCESS
2565:                  }
2374  EFBE     GOTO 0x237C
2376  F011     NOP
2566:                  else
2567:                  {
2568:                          BothEP0OutUOWNsSet = false;
2378  0E00     MOVLW 0x0
237A  6E20     MOVWF BothEP0OutUOWNsSet, ACCESS
2569:                  }
2570:              }
2571:          }
237C  0012     RETURN 0
2572:          
2573:          /******************************************************************************
2574:           * Function:        void USBCtrlTrfInHandler(void)
2575:           *
2576:           * PreCondition:    None
2577:           *
2578:           * Input:           None
2579:           *
2580:           * Output:          None
2581:           *
2582:           * Side Effects:    None
2583:           *
2584:           * Overview:        This routine handles an IN transaction according to
2585:           *                  which control transfer state is currently active.
2586:           *
2587:           * Note:            A Set Address Request must not change the actual address
2588:           *                  of the device until the completion of the control
2589:           *                  transfer. The end of the control transfer for Set Address
2590:           *                  Request is an IN transaction. Therefore it is necessary
2591:           *                  to service this unique situation when the condition is
2592:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2593:           *                  usb9.h and its function is to specifically service this
2594:           *                  event.
2595:           *****************************************************************************/
2596:          static void USBCtrlTrfInHandler(void)
2597:          {
2598:              uint8_t lastDTS;
2599:          
2600:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
1B02  C009     MOVFF pBDTEntryIn, FSR2
1B04  FFD9     NOP
1B06  C00A     MOVFF 0xA, FSR2H
1B08  FFDA     NOP
1B0A  0E00     MOVLW 0x0
1B0C  BCDF     BTFSC INDF2, 6, ACCESS
1B0E  0E01     MOVLW 0x1
1B10  6E2D     MOVWF data, ACCESS
2601:          
2602:              //switch to the next ping pong buffer
2603:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
1B12  0E04     MOVLW 0x4
1B14  1809     XORWF pBDTEntryIn, W, ACCESS
1B16  6E09     MOVWF pBDTEntryIn, ACCESS
1B18  500A     MOVF 0xA, W, ACCESS
1B1A  6E0A     MOVWF 0xA, ACCESS
2604:          
2605:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2606:              //now, since the IN status stage of the (set address) control transfer has 
2607:              //evidently completed successfully.
2608:              if(USBDeviceState == ADR_PENDING_STATE)
1B1C  0E08     MOVLW 0x8
1B1E  1829     XORWF USBDeviceState, W, ACCESS
1B20  A4D8     BTFSS STATUS, 2, ACCESS
1B22  EF95     GOTO 0x1B2A
1B24  F00D     NOP
1B26  EF97     GOTO 0x1B2E
1B28  F00D     NOP
1B2A  EFA9     GOTO 0x1B52
1B2C  F00D     NOP
2609:              {
2610:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
1B2E  0104     MOVLB 0x4
1B30  5132     MOVF handle, W, BANKED
1B32  0B7F     ANDLW 0x7F
1B34  6E63     MOVWF UADDR, ACCESS
2611:                  if(U1ADDR != 0u)
1B36  5063     MOVF UADDR, W, ACCESS
1B38  B4D8     BTFSC STATUS, 2, ACCESS
1B3A  EFA1     GOTO 0x1B42
1B3C  F00D     NOP
1B3E  EFA3     GOTO 0x1B46
1B40  F00D     NOP
1B42  EFA7     GOTO 0x1B4E
1B44  F00D     NOP
2612:                  {
2613:                      USBDeviceState=ADDRESS_STATE;
1B46  0E10     MOVLW 0x10
1B48  6E29     MOVWF USBDeviceState, ACCESS
2614:                  }
1B4A  EFA9     GOTO 0x1B52
1B4C  F00D     NOP
2615:                  else
2616:                  {
2617:                      USBDeviceState=DEFAULT_STATE;
1B4E  0E04     MOVLW 0x4
1B50  6E29     MOVWF USBDeviceState, ACCESS
2618:                  }
2619:              }//end if
2620:          
2621:          
2622:              if(controlTransferState == CTRL_TRF_TX)
1B52  0424     DECF controlTransferState, W, ACCESS
1B54  A4D8     BTFSS STATUS, 2, ACCESS
1B56  EFAF     GOTO 0x1B5E
1B58  F00D     NOP
1B5A  EFB1     GOTO 0x1B62
1B5C  F00D     NOP
1B5E  EFF8     GOTO 0x1BF0
1B60  F00D     NOP
2623:              {
2624:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
1B62  EE20     LFSR 2, 0x2
1B64  F002     NOP
1B66  5009     MOVF pBDTEntryIn, W, ACCESS
1B68  26D9     ADDWF FSR2, F, ACCESS
1B6A  500A     MOVF 0xA, W, ACCESS
1B6C  22DA     ADDWFC FSR2H, F, ACCESS
1B6E  0E38     MOVLW 0x38
1B70  6EDE     MOVWF POSTINC2, ACCESS
1B72  0E04     MOVLW 0x4
1B74  6EDD     MOVWF POSTDEC2, ACCESS
2625:                  USBCtrlTrfTxService();
1B76  ECF9     CALL 0x19F2, 0
1B78  F00C     NOP
2626:          
2627:                  //Check if we have already sent a short packet.  If so, configure
2628:                  //the endpoint to STALL in response to any further IN tokens (in the
2629:                  //case that the host erroneously tries to receive more data than it
2630:                  //should).
2631:                  if(shortPacketStatus == SHORT_PKT_SENT)
1B7A  0E02     MOVLW 0x2
1B7C  1825     XORWF shortPacketStatus, W, ACCESS
1B7E  A4D8     BTFSS STATUS, 2, ACCESS
1B80  EFC4     GOTO 0x1B88
1B82  F00D     NOP
1B84  EFC6     GOTO 0x1B8C
1B86  F00D     NOP
1B88  EFD4     GOTO 0x1BA8
1B8A  F00D     NOP
2632:                  {
2633:                      // If a short packet has been sent, don't want to send any more,
2634:                      // stall next time if host is still trying to read.
2635:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
1B8C  C009     MOVFF pBDTEntryIn, FSR2
1B8E  FFD9     NOP
1B90  C00A     MOVFF 0xA, FSR2H
1B92  FFDA     NOP
1B94  0E04     MOVLW 0x4
1B96  6EDF     MOVWF INDF2, ACCESS
2636:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
1B98  C009     MOVFF pBDTEntryIn, FSR2
1B9A  FFD9     NOP
1B9C  C00A     MOVFF 0xA, FSR2H
1B9E  FFDA     NOP
1BA0  0E00     MOVLW 0x0
1BA2  8EDB     BSF PLUSW2, 7, ACCESS
2637:                  }
1BA4  EF02     GOTO 0x1C04
1BA6  F00E     NOP
2638:                  else
2639:                  {
2640:                      if(lastDTS == 0)
1BA8  502D     MOVF data, W, ACCESS
1BAA  A4D8     BTFSS STATUS, 2, ACCESS
1BAC  EFDA     GOTO 0x1BB4
1BAE  F00D     NOP
1BB0  EFDC     GOTO 0x1BB8
1BB2  F00D     NOP
1BB4  EFEA     GOTO 0x1BD4
1BB6  F00D     NOP
2641:                      {
2642:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
1BB8  C009     MOVFF pBDTEntryIn, FSR2
1BBA  FFD9     NOP
1BBC  C00A     MOVFF 0xA, FSR2H
1BBE  FFDA     NOP
1BC0  0E48     MOVLW 0x48
1BC2  6EDF     MOVWF INDF2, ACCESS
2643:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
1BC4  C009     MOVFF pBDTEntryIn, FSR2
1BC6  FFD9     NOP
1BC8  C00A     MOVFF 0xA, FSR2H
1BCA  FFDA     NOP
1BCC  0E00     MOVLW 0x0
1BCE  8EDB     BSF PLUSW2, 7, ACCESS
2644:                      }
1BD0  EF02     GOTO 0x1C04
1BD2  F00E     NOP
2645:                      else
2646:                      {
2647:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
1BD4  C009     MOVFF pBDTEntryIn, FSR2
1BD6  FFD9     NOP
1BD8  C00A     MOVFF 0xA, FSR2H
1BDA  FFDA     NOP
1BDC  0E08     MOVLW 0x8
1BDE  6EDF     MOVWF INDF2, ACCESS
2648:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
1BE0  C009     MOVFF pBDTEntryIn, FSR2
1BE2  FFD9     NOP
1BE4  C00A     MOVFF 0xA, FSR2H
1BE6  FFDA     NOP
1BE8  0E00     MOVLW 0x0
1BEA  8EDB     BSF PLUSW2, 7, ACCESS
1BEC  EF02     GOTO 0x1C04
1BEE  F00E     NOP
2649:                      }
2650:                  }//end if(...)else
2651:              }
2652:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2653:          	{
2654:                  //if someone is still expecting data from the control transfer
2655:                  //  then make sure to terminate that request and let them know that
2656:                  //  they are done
2657:                  if(outPipes[0].info.bits.busy == 1)
1BF0  AE04     BTFSS 0x4, 7, ACCESS
1BF2  EFFD     GOTO 0x1BFA
1BF4  F00D     NOP
1BF6  EFFF     GOTO 0x1BFE
1BF8  F00D     NOP
1BFA  EF00     GOTO 0x1C00
1BFC  F00E     NOP
2658:                  {
2659:                      if(outPipes[0].pFunc != NULL)
2660:                      {
2661:                          outPipes[0].pFunc();
2662:                      }
2663:                      outPipes[0].info.bits.busy = 0;
1BFE  9E04     BCF 0x4, 7, ACCESS
2664:                  }
2665:              	
2666:                  controlTransferState = WAIT_SETUP;
1C00  0E00     MOVLW 0x0
1C02  6E24     MOVWF controlTransferState, ACCESS
2667:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2668:                  //got processed by the USBCtrlTrfRxService() handler.
2669:          	}	
2670:          
2671:          }
1C04  0012     RETURN 0
2672:          
2673:          
2674:          /********************************************************************
2675:           * Function:        void USBCheckStdRequest(void)
2676:           *
2677:           * PreCondition:    None
2678:           *
2679:           * Input:           None
2680:           *
2681:           * Output:          None
2682:           *
2683:           * Side Effects:    None
2684:           *
2685:           * Overview:        This routine checks the setup data packet to see
2686:           *                  if it knows how to handle it
2687:           *
2688:           * Note:            None
2689:           *******************************************************************/
2690:          static void USBCheckStdRequest(void)
2691:          {
2692:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
18D6  0104     MOVLB 0x4
18D8  3930     SWAPF n, W, BANKED
18DA  32E8     RRCF WREG, F, ACCESS
18DC  0B03     ANDLW 0x3
18DE  0900     IORLW 0x0
18E0  B4D8     BTFSC STATUS, 2, ACCESS
18E2  EF75     GOTO 0x18EA
18E4  F00C     NOP
18E6  EF77     GOTO 0x18EE
18E8  F00C     NOP
18EA  EFBF     GOTO 0x197E
18EC  F00C     NOP
18EE  EFF8     GOTO 0x19F0
18F0  F00C     NOP
2693:          
2694:              switch(SetupPkt.bRequest)
2695:              {
2696:                  case USB_REQUEST_SET_ADDRESS:
2697:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
18F2  8E12     BSF 0x12, 7, ACCESS
2698:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
18F4  0E08     MOVLW 0x8
18F6  6E29     MOVWF USBDeviceState, ACCESS
2699:                      /* See USBCtrlTrfInHandler() for the next step */
2700:                      break;
18F8  EFF8     GOTO 0x19F0
18FA  F00C     NOP
2701:                  case USB_REQUEST_GET_DESCRIPTOR:
2702:                      USBStdGetDscHandler();
18FC  EC8E     CALL 0x111C, 0
18FE  F008     NOP
2703:                      break;
1900  EFF8     GOTO 0x19F0
1902  F00C     NOP
2704:                  case USB_REQUEST_SET_CONFIGURATION:
2705:                      USBStdSetCfgHandler();
1904  EC7D     CALL 0x1EFA, 0
1906  F00F     NOP
2706:                      break;
1908  EFF8     GOTO 0x19F0
190A  F00C     NOP
2707:                  case USB_REQUEST_GET_CONFIGURATION:
2708:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
190C  0E2B     MOVLW 0x2B
190E  6E0F     MOVWF inPipes, ACCESS
1910  0E00     MOVLW 0x0
1912  6E10     MOVWF 0x10, ACCESS
2709:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
1914  8012     BSF 0x12, 0, ACCESS
2710:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
1916  0E01     MOVLW 0x1
1918  6E13     MOVWF 0x13, ACCESS
2711:                      inPipes[0].info.bits.busy = 1;
191A  8E12     BSF 0x12, 7, ACCESS
2712:                      break;
191C  EFF8     GOTO 0x19F0
191E  F00C     NOP
2713:                  case USB_REQUEST_GET_STATUS:
2714:                      USBStdGetStatusHandler();
1920  EC03     CALL 0x1C06, 0
1922  F00E     NOP
2715:                      break;
1924  EFF8     GOTO 0x19F0
1926  F00C     NOP
2716:                  case USB_REQUEST_CLEAR_FEATURE:
2717:                  case USB_REQUEST_SET_FEATURE:
2718:                      USBStdFeatureReqHandler();
1928  EC59     CALL 0x8B2, 0
192A  F004     NOP
2719:                      break;
192C  EFF8     GOTO 0x19F0
192E  F00C     NOP
2720:                  case USB_REQUEST_GET_INTERFACE:
2721:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
1930  0EDB     MOVLW 0xDB
1932  2534     ADDWF ep, W, BANKED
1934  6E0F     MOVWF inPipes, ACCESS
1936  6A10     CLRF 0x10, ACCESS
1938  0E00     MOVLW 0x0
193A  2210     ADDWFC 0x10, F, ACCESS
2722:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
193C  8012     BSF 0x12, 0, ACCESS
2723:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
193E  0E01     MOVLW 0x1
1940  6E13     MOVWF 0x13, ACCESS
2724:                      inPipes[0].info.bits.busy = 1;
1942  8E12     BSF 0x12, 7, ACCESS
2725:                      break;
1944  EFF8     GOTO 0x19F0
1946  F00C     NOP
2726:                  case USB_REQUEST_SET_INTERFACE:
2727:                      inPipes[0].info.bits.busy = 1;
1948  8E12     BSF 0x12, 7, ACCESS
2728:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
194A  0EDB     MOVLW 0xDB
194C  2534     ADDWF ep, W, BANKED
194E  6ED9     MOVWF FSR2, ACCESS
1950  6ADA     CLRF FSR2H, ACCESS
1952  0E00     MOVLW 0x0
1954  22DA     ADDWFC FSR2H, F, ACCESS
1956  C432     MOVFF 0x432, INDF2
1958  FFDF     NOP
2729:                      break;
195A  EFF8     GOTO 0x19F0
195C  F00C     NOP
2730:                  case USB_REQUEST_SET_DESCRIPTOR:
2731:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
195E  0E00     MOVLW 0x0
1960  6E39     MOVWF 0x39, ACCESS
1962  0E02     MOVLW 0x2
1964  6E38     MOVWF USBDeviceInit, ACCESS
1966  0E00     MOVLW 0x0
1968  6E3A     MOVWF pdata, ACCESS
196A  0E00     MOVLW 0x0
196C  6E3B     MOVWF 0x3B, ACCESS
196E  0E00     MOVLW 0x0
1970  6E3D     MOVWF 0x3D, ACCESS
1972  0E00     MOVLW 0x0
1974  6E3C     MOVWF size, ACCESS
1976  EC41     CALL 0x2282, 0
1978  F011     NOP
2732:                      break;
197A  EFF8     GOTO 0x19F0
197C  F00C     NOP
2733:                  case USB_REQUEST_SYNCH_FRAME:
2734:                  default:
2735:                      break;
2736:              }//end switch
197E  5131     MOVF EPNum, W, BANKED
1980  6E47     MOVWF 0x47, ACCESS
1982  6A48     CLRF 0x48, ACCESS
1984  5048     MOVF 0x48, W, ACCESS
1986  0A00     XORLW 0x0
1988  B4D8     BTFSC STATUS, 2, ACCESS
198A  EFC9     GOTO 0x1992
198C  F00C     NOP
198E  EFF8     GOTO 0x19F0
1990  F00C     NOP
1992  5047     MOVF 0x47, W, ACCESS
1994  0A00     XORLW 0x0
1996  B4D8     BTFSC STATUS, 2, ACCESS
1998  EF90     GOTO 0x1920
199A  F00C     NOP
199C  0A01     XORLW 0x1
199E  B4D8     BTFSC STATUS, 2, ACCESS
19A0  EF94     GOTO 0x1928
19A2  F00C     NOP
19A4  0A02     XORLW 0x2
19A6  B4D8     BTFSC STATUS, 2, ACCESS
19A8  EF94     GOTO 0x1928
19AA  F00C     NOP
19AC  0A06     XORLW 0x6
19AE  B4D8     BTFSC STATUS, 2, ACCESS
19B0  EF79     GOTO 0x18F2
19B2  F00C     NOP
19B4  0A03     XORLW 0x3
19B6  B4D8     BTFSC STATUS, 2, ACCESS
19B8  EF7E     GOTO 0x18FC
19BA  F00C     NOP
19BC  0A01     XORLW 0x1
19BE  B4D8     BTFSC STATUS, 2, ACCESS
19C0  EFAF     GOTO 0x195E
19C2  F00C     NOP
19C4  0A0F     XORLW 0xF
19C6  B4D8     BTFSC STATUS, 2, ACCESS
19C8  EF86     GOTO 0x190C
19CA  F00C     NOP
19CC  0A01     XORLW 0x1
19CE  B4D8     BTFSC STATUS, 2, ACCESS
19D0  EF82     GOTO 0x1904
19D2  F00C     NOP
19D4  0A03     XORLW 0x3
19D6  B4D8     BTFSC STATUS, 2, ACCESS
19D8  EF98     GOTO 0x1930
19DA  F00C     NOP
19DC  0A01     XORLW 0x1
19DE  B4D8     BTFSC STATUS, 2, ACCESS
19E0  EFA4     GOTO 0x1948
19E2  F00C     NOP
19E4  0A07     XORLW 0x7
19E6  B4D8     BTFSC STATUS, 2, ACCESS
19E8  EFF8     GOTO 0x19F0
19EA  F00C     NOP
19EC  EFF8     GOTO 0x19F0
19EE  F00C     NOP
2737:          }//end USBCheckStdRequest
19F0  0012     RETURN 0
2738:          
2739:          /********************************************************************
2740:           * Function:        void USBStdFeatureReqHandler(void)
2741:           *
2742:           * PreCondition:    None
2743:           *
2744:           * Input:           None
2745:           *
2746:           * Output:          Can alter BDT entries.  Can also modify USB stack
2747:           *                  Maintained variables.
2748:           *
2749:           * Side Effects:    None
2750:           *
2751:           * Overview:        This routine handles the standard SET & CLEAR
2752:           *                  FEATURES requests
2753:           *
2754:           * Note:            This is a private function, intended for internal 
2755:           *                  use by the USB stack, when processing SET/CLEAR
2756:           *                  feature requests.  
2757:           *******************************************************************/
2758:          static void USBStdFeatureReqHandler(void)
2759:          {
2760:              BDT_ENTRY *p;
2761:              EP_STATUS current_ep_data;
2762:              #if defined(__C32__)
2763:                  uint32_t* pUEP;
2764:              #else
2765:                  unsigned char* pUEP;             
2766:              #endif
2767:              
2768:          
2769:              #ifdef	USB_SUPPORT_OTG
2770:              //Check for USB On-The-Go (OTG) specific requests
2771:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2772:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2773:              {  
2774:                  inPipes[0].info.bits.busy = 1;
2775:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2776:                      USBOTGEnableHnp();
2777:                  else
2778:                      USBOTGDisableHnp();
2779:              }
2780:          
2781:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2782:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2783:              {
2784:                  inPipes[0].info.bits.busy = 1;
2785:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2786:                      USBOTGEnableSupportHnp();
2787:                  else
2788:                      USBOTGDisableSupportHnp();
2789:              }
2790:          
2791:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2792:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2793:              {
2794:                  inPipes[0].info.bits.busy = 1;
2795:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2796:                      USBOTGEnableAltHnp();
2797:                  else
2798:                      USBOTGDisableAltHnp();
2799:              }
2800:              #endif   //#ifdef USB_SUPPORT_OTG 
2801:          
2802:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2803:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
08B2  0104     MOVLB 0x4
08B4  0532     DECF handle, W, BANKED
08B6  A4D8     BTFSS STATUS, 2, ACCESS
08B8  EF60     GOTO 0x8C0
08BA  F004     NOP
08BC  EF62     GOTO 0x8C4
08BE  F004     NOP
08C0  EF7C     GOTO 0x8F8
08C2  F004     NOP
08C4  5130     MOVF n, W, BANKED
08C6  0B1F     ANDLW 0x1F
08C8  0900     IORLW 0x0
08CA  A4D8     BTFSS STATUS, 2, ACCESS
08CC  EF6A     GOTO 0x8D4
08CE  F004     NOP
08D0  EF6C     GOTO 0x8D8
08D2  F004     NOP
08D4  EF7C     GOTO 0x8F8
08D6  F004     NOP
2804:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2805:              {
2806:                  inPipes[0].info.bits.busy = 1;
08D8  8E12     BSF 0x12, 7, ACCESS
2807:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
08DA  0E03     MOVLW 0x3
08DC  1931     XORWF EPNum, W, BANKED
08DE  A4D8     BTFSS STATUS, 2, ACCESS
08E0  EF74     GOTO 0x8E8
08E2  F004     NOP
08E4  EF76     GOTO 0x8EC
08E6  F004     NOP
08E8  EF7A     GOTO 0x8F4
08EA  F004     NOP
2808:                      RemoteWakeup = true;
08EC  0E01     MOVLW 0x1
08EE  6E23     MOVWF RemoteWakeup, ACCESS
08F0  EF7C     GOTO 0x8F8
08F2  F004     NOP
2809:                  else
2810:                      RemoteWakeup = false;
08F4  0E00     MOVLW 0x0
08F6  6E23     MOVWF RemoteWakeup, ACCESS
2811:              }//end if
2812:          
2813:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2814:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
08F8  5132     MOVF handle, W, BANKED
08FA  A4D8     BTFSS STATUS, 2, ACCESS
08FC  EF82     GOTO 0x904
08FE  F004     NOP
0900  EF84     GOTO 0x908
0902  F004     NOP
0904  EF02     GOTO 0xC04
0906  F006     NOP
0908  5130     MOVF n, W, BANKED
090A  0B1F     ANDLW 0x1F
090C  0A02     XORLW 0x2
090E  A4D8     BTFSS STATUS, 2, ACCESS
0910  EF8C     GOTO 0x918
0912  F004     NOP
0914  EF8E     GOTO 0x91C
0916  F004     NOP
0918  EF02     GOTO 0xC04
091A  F006     NOP
091C  5134     MOVF ep, W, BANKED
091E  0B0F     ANDLW 0xF
0920  0900     IORLW 0x0
0922  B4D8     BTFSC STATUS, 2, ACCESS
0924  EF96     GOTO 0x92C
0926  F004     NOP
0928  EF98     GOTO 0x930
092A  F004     NOP
092C  EF02     GOTO 0xC04
092E  F006     NOP
0930  5134     MOVF ep, W, BANKED
0932  0B0F     ANDLW 0xF
0934  6E40     MOVWF i, ACCESS
0936  0E03     MOVLW 0x3
0938  6040     CPFSLT i, ACCESS
093A  EFA1     GOTO 0x942
093C  F004     NOP
093E  EFA3     GOTO 0x946
0940  F004     NOP
0942  EF02     GOTO 0xC04
0944  F006     NOP
0946  0E20     MOVLW 0x20
0948  1829     XORWF USBDeviceState, W, ACCESS
094A  A4D8     BTFSS STATUS, 2, ACCESS
094C  EFAA     GOTO 0x954
094E  F004     NOP
0950  EFAC     GOTO 0x958
0952  F004     NOP
0954  EF02     GOTO 0xC04
0956  F006     NOP
2815:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2816:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2817:                 (USBDeviceState == CONFIGURED_STATE))
2818:              {
2819:          		//The request was valid.  Take control of the control transfer and
2820:          		//perform the host requested action.
2821:          		inPipes[0].info.bits.busy = 1;
0958  8E12     BSF 0x12, 7, ACCESS
2822:          
2823:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2824:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
095A  BF34     BTFSC ep, 7, BANKED
095C  EFB2     GOTO 0x964
095E  F004     NOP
0960  EFB4     GOTO 0x968
0962  F004     NOP
0964  EFD1     GOTO 0x9A2
0966  F004     NOP
2825:                  {
2826:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0968  5134     MOVF ep, W, BANKED
096A  0B0F     ANDLW 0xF
096C  6E40     MOVWF i, ACCESS
096E  5040     MOVF i, W, ACCESS
0970  0D02     MULLW 0x2
0972  0E6A     MOVLW 0x6A
0974  24F3     ADDWF PROD, W, ACCESS
0976  6ED9     MOVWF FSR2, ACCESS
0978  0E00     MOVLW 0x0
097A  20F4     ADDWFC PRODH, W, ACCESS
097C  6EDA     MOVWF FSR2H, ACCESS
097E  CFDE     MOVFF POSTINC2, p
0980  F045     NOP
0982  CFDD     MOVFF POSTDEC2, 0x46
0984  F046     NOP
2827:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0986  5134     MOVF ep, W, BANKED
0988  0B0F     ANDLW 0xF
098A  6E40     MOVWF i, ACCESS
098C  6A41     CLRF 0x41, ACCESS
098E  0E78     MOVLW 0x78
0990  2440     ADDWF i, W, ACCESS
0992  6ED9     MOVWF FSR2, ACCESS
0994  0E00     MOVLW 0x0
0996  2041     ADDWFC 0x41, W, ACCESS
0998  6EDA     MOVWF FSR2H, ACCESS
099A  50DF     MOVF INDF2, W, ACCESS
099C  6E44     MOVWF current_ep_data, ACCESS
2828:                  }
099E  EFEC     GOTO 0x9D8
09A0  F004     NOP
2829:                  else
2830:                  {
2831:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
09A2  5134     MOVF ep, W, BANKED
09A4  0B0F     ANDLW 0xF
09A6  6E40     MOVWF i, ACCESS
09A8  5040     MOVF i, W, ACCESS
09AA  0D02     MULLW 0x2
09AC  0E09     MOVLW 0x9
09AE  24F3     ADDWF PROD, W, ACCESS
09B0  6ED9     MOVWF FSR2, ACCESS
09B2  0E00     MOVLW 0x0
09B4  20F4     ADDWFC PRODH, W, ACCESS
09B6  6EDA     MOVWF FSR2H, ACCESS
09B8  CFDE     MOVFF POSTINC2, p
09BA  F045     NOP
09BC  CFDD     MOVFF POSTDEC2, 0x46
09BE  F046     NOP
2832:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
09C0  5134     MOVF ep, W, BANKED
09C2  0B0F     ANDLW 0xF
09C4  6E40     MOVWF i, ACCESS
09C6  6A41     CLRF 0x41, ACCESS
09C8  0E7B     MOVLW 0x7B
09CA  2440     ADDWF i, W, ACCESS
09CC  6ED9     MOVWF FSR2, ACCESS
09CE  0E00     MOVLW 0x0
09D0  2041     ADDWFC 0x41, W, ACCESS
09D2  6EDA     MOVWF FSR2H, ACCESS
09D4  50DF     MOVF INDF2, W, ACCESS
09D6  6E44     MOVWF current_ep_data, ACCESS
2833:                  }
2834:          
2835:                  //If ping pong buffering is enabled on the requested endpoint, need 
2836:                  //to point to the one that is the active BDT entry which the SIE will 
2837:                  //use for the next attempted transaction on that EP number.
2838:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2839:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
09D8  B044     BTFSC current_ep_data, 0, ACCESS
09DA  EFF1     GOTO 0x9E2
09DC  F004     NOP
09DE  EFF3     GOTO 0x9E6
09E0  F004     NOP
09E2  EFFB     GOTO 0x9F6
09E4  F004     NOP
2840:                      {
2841:                          p = (BDT_ENTRY*)(((uintptr_t)p) & (~USB_NEXT_PING_PONG));
09E6  0EFB     MOVLW 0xFB
09E8  1445     ANDWF p, W, ACCESS
09EA  6E45     MOVWF p, ACCESS
09EC  0EFF     MOVLW 0xFF
09EE  1446     ANDWF 0x46, W, ACCESS
09F0  6E46     MOVWF 0x46, ACCESS
2842:                      }
09F2  EF00     GOTO 0xA00
09F4  F005     NOP
2843:                      else //else must have been odd
2844:                      {
2845:                          p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
09F6  0E04     MOVLW 0x4
09F8  1045     IORWF p, W, ACCESS
09FA  6E45     MOVWF p, ACCESS
09FC  5046     MOVF 0x46, W, ACCESS
09FE  6E46     MOVWF 0x46, ACCESS
2846:                      }
2847:                  #endif
2848:                  
2849:                  //Update the BDT pointers with the new, next entry based on the feature
2850:                  //  request
2851:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0A00  BF34     BTFSC ep, 7, BANKED
0A02  EF05     GOTO 0xA0A
0A04  F005     NOP
0A06  EF07     GOTO 0xA0E
0A08  F005     NOP
0A0A  EF18     GOTO 0xA30
0A0C  F005     NOP
2852:                  {
2853:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
0A0E  5134     MOVF ep, W, BANKED
0A10  0B0F     ANDLW 0xF
0A12  6E40     MOVWF i, ACCESS
0A14  5040     MOVF i, W, ACCESS
0A16  0D02     MULLW 0x2
0A18  0E6A     MOVLW 0x6A
0A1A  24F3     ADDWF PROD, W, ACCESS
0A1C  6ED9     MOVWF FSR2, ACCESS
0A1E  0E00     MOVLW 0x0
0A20  20F4     ADDWFC PRODH, W, ACCESS
0A22  6EDA     MOVWF FSR2H, ACCESS
0A24  C045     MOVFF p, POSTINC2
0A26  FFDE     NOP
0A28  C046     MOVFF 0x46, POSTDEC2
0A2A  FFDD     NOP
2854:                  }
0A2C  EF27     GOTO 0xA4E
0A2E  F005     NOP
2855:                  else
2856:                  {
2857:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
0A30  5134     MOVF ep, W, BANKED
0A32  0B0F     ANDLW 0xF
0A34  6E40     MOVWF i, ACCESS
0A36  5040     MOVF i, W, ACCESS
0A38  0D02     MULLW 0x2
0A3A  0E09     MOVLW 0x9
0A3C  24F3     ADDWF PROD, W, ACCESS
0A3E  6ED9     MOVWF FSR2, ACCESS
0A40  0E00     MOVLW 0x0
0A42  20F4     ADDWFC PRODH, W, ACCESS
0A44  6EDA     MOVWF FSR2H, ACCESS
0A46  C045     MOVFF p, POSTINC2
0A48  FFDE     NOP
0A4A  C046     MOVFF 0x46, POSTDEC2
0A4C  FFDD     NOP
2858:                  }
2859:          
2860:          		//Check if it was a SET_FEATURE endpoint halt request
2861:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0A4E  0E03     MOVLW 0x3
0A50  1931     XORWF EPNum, W, BANKED
0A52  A4D8     BTFSS STATUS, 2, ACCESS
0A54  EF2E     GOTO 0xA5C
0A56  F005     NOP
0A58  EF30     GOTO 0xA60
0A5A  F005     NOP
0A5C  EF6A     GOTO 0xAD4
0A5E  F005     NOP
2862:                  {
2863:                      if(p->STAT.UOWN == 1)
0A60  C045     MOVFF p, FSR2
0A62  FFD9     NOP
0A64  C046     MOVFF 0x46, FSR2H
0A66  FFDA     NOP
0A68  AEDF     BTFSS INDF2, 7, ACCESS
0A6A  EF39     GOTO 0xA72
0A6C  F005     NOP
0A6E  EF3B     GOTO 0xA76
0A70  F005     NOP
0A72  EF5C     GOTO 0xAB8
0A74  F005     NOP
2864:                      {
2865:                          //Mark that we are terminating this transfer and that the user
2866:                          //  needs to be notified later
2867:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
0A76  BF34     BTFSC ep, 7, BANKED
0A78  EF40     GOTO 0xA80
0A7A  F005     NOP
0A7C  EF42     GOTO 0xA84
0A7E  F005     NOP
0A80  EF50     GOTO 0xAA0
0A82  F005     NOP
2868:                          {
2869:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0A84  5134     MOVF ep, W, BANKED
0A86  0B0F     ANDLW 0xF
0A88  6E40     MOVWF i, ACCESS
0A8A  6A41     CLRF 0x41, ACCESS
0A8C  0E78     MOVLW 0x78
0A8E  2440     ADDWF i, W, ACCESS
0A90  6ED9     MOVWF FSR2, ACCESS
0A92  0E00     MOVLW 0x0
0A94  2041     ADDWFC 0x41, W, ACCESS
0A96  6EDA     MOVWF FSR2H, ACCESS
0A98  0100     MOVLB 0x0
0A9A  82DF     BSF INDF2, 1, ACCESS
2870:                          }
0A9C  EF5C     GOTO 0xAB8
0A9E  F005     NOP
2871:                          else
2872:                          {
2873:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
0AA0  5134     MOVF ep, W, BANKED
0AA2  0B0F     ANDLW 0xF
0AA4  6E40     MOVWF i, ACCESS
0AA6  6A41     CLRF 0x41, ACCESS
0AA8  0E7B     MOVLW 0x7B
0AAA  2440     ADDWF i, W, ACCESS
0AAC  6ED9     MOVWF FSR2, ACCESS
0AAE  0E00     MOVLW 0x0
0AB0  2041     ADDWFC 0x41, W, ACCESS
0AB2  6EDA     MOVWF FSR2H, ACCESS
0AB4  0100     MOVLB 0x0
0AB6  82DF     BSF INDF2, 1, ACCESS
2874:                          }
2875:                      }
2876:          
2877:          			//Then STALL the endpoint
2878:                      p->STAT.Val |= _BSTALL;
0AB8  C045     MOVFF p, FSR2
0ABA  FFD9     NOP
0ABC  C046     MOVFF 0x46, FSR2H
0ABE  FFDA     NOP
0AC0  0E00     MOVLW 0x0
0AC2  84DB     BSF PLUSW2, 2, ACCESS
2879:                      p->STAT.Val |= _USIE;
0AC4  C045     MOVFF p, FSR2
0AC6  FFD9     NOP
0AC8  C046     MOVFF 0x46, FSR2H
0ACA  FFDA     NOP
0ACC  0E00     MOVLW 0x0
0ACE  8EDB     BSF PLUSW2, 7, ACCESS
2880:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0AD0  EF02     GOTO 0xC04
0AD2  F006     NOP
2881:                  else
2882:                  {
2883:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2884:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2885:                          //toggle over the to the non-active BDT
2886:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);  
0AD4  0E04     MOVLW 0x4
0AD6  1845     XORWF p, W, ACCESS
0AD8  6E45     MOVWF p, ACCESS
0ADA  5046     MOVF 0x46, W, ACCESS
0ADC  6E46     MOVWF 0x46, ACCESS
2887:          
2888:                          if(p->STAT.UOWN == 1)
0ADE  C045     MOVFF p, FSR2
0AE0  FFD9     NOP
0AE2  C046     MOVFF 0x46, FSR2H
0AE4  FFDA     NOP
0AE6  AEDF     BTFSS INDF2, 7, ACCESS
0AE8  EF78     GOTO 0xAF0
0AEA  F005     NOP
0AEC  EF7A     GOTO 0xAF4
0AEE  F005     NOP
0AF0  EF96     GOTO 0xB2C
0AF2  F005     NOP
2889:                          {
2890:                              //Clear UOWN and set DTS state so it will be correct the next time
2891:                              //the application firmware uses USBTransferOnePacket() on the EP.
2892:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
0AF4  C045     MOVFF p, FSR2
0AF6  FFD9     NOP
0AF8  C046     MOVFF 0x46, FSR2H
0AFA  FFDA     NOP
0AFC  0E7F     MOVLW 0x7F
0AFE  16DF     ANDWF INDF2, F, ACCESS
2893:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
0B00  C045     MOVFF p, FSR2
0B02  FFD9     NOP
0B04  C046     MOVFF 0x46, FSR2H
0B06  FFDA     NOP
0B08  0E00     MOVLW 0x0
0B0A  8CDB     BSF PLUSW2, 6, ACCESS
2894:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0B0C  0E00     MOVLW 0x0
0B0E  6E39     MOVWF 0x39, ACCESS
0B10  0E05     MOVLW 0x5
0B12  6E38     MOVWF USBDeviceInit, ACCESS
0B14  C045     MOVFF p, pdata
0B16  F03A     NOP
0B18  C046     MOVFF 0x46, 0x3B
0B1A  F03B     NOP
0B1C  0E00     MOVLW 0x0
0B1E  6E3D     MOVWF 0x3D, ACCESS
0B20  0E02     MOVLW 0x2
0B22  6E3C     MOVWF size, ACCESS
0B24  EC41     CALL 0x2282, 0
0B26  F011     NOP
2895:                          }
0B28  EF9C     GOTO 0xB38
0B2A  F005     NOP
2896:                          else
2897:                          {
2898:                              //UOWN already clear, but still need to set DTS to DATA1     
2899:          					p->STAT.Val |= _DAT1;
0B2C  C045     MOVFF p, FSR2
0B2E  FFD9     NOP
0B30  C046     MOVFF 0x46, FSR2H
0B32  FFDA     NOP
0B34  0E00     MOVLW 0x0
0B36  8CDB     BSF PLUSW2, 6, ACCESS
2900:                          }
2901:          
2902:                          //toggle back to the active BDT (the one the SIE is currently looking at
2903:                          //and will use for the next successful transaction to take place on the EP
2904:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
0B38  0E04     MOVLW 0x4
0B3A  1845     XORWF p, W, ACCESS
0B3C  6E45     MOVWF p, ACCESS
0B3E  5046     MOVF 0x46, W, ACCESS
0B40  6E46     MOVWF 0x46, ACCESS
2905:                          
2906:                          //Check if we are currently terminating, or have previously terminated
2907:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2908:                          //set DTS to the proper state, and call the application callback
2909:                          //function.
2910:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
0B42  B244     BTFSC current_ep_data, 1, ACCESS
0B44  EFA6     GOTO 0xB4C
0B46  F005     NOP
0B48  EFA8     GOTO 0xB50
0B4A  F005     NOP
0B4C  EFB3     GOTO 0xB66
0B4E  F005     NOP
0B50  C045     MOVFF p, FSR2
0B52  FFD9     NOP
0B54  C046     MOVFF 0x46, FSR2H
0B56  FFDA     NOP
0B58  AEDF     BTFSS INDF2, 7, ACCESS
0B5A  EFB1     GOTO 0xB62
0B5C  F005     NOP
0B5E  EFB3     GOTO 0xB66
0B60  F005     NOP
0B62  EFEB     GOTO 0xBD6
0B64  F005     NOP
2911:                          {
2912:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0B66  0104     MOVLB 0x4
0B68  BF34     BTFSC ep, 7, BANKED
0B6A  EFB9     GOTO 0xB72
0B6C  F005     NOP
0B6E  EFBB     GOTO 0xB76
0B70  F005     NOP
0B72  EFC9     GOTO 0xB92
0B74  F005     NOP
2913:                              {
2914:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0B76  5134     MOVF ep, W, BANKED
0B78  0B0F     ANDLW 0xF
0B7A  6E40     MOVWF i, ACCESS
0B7C  6A41     CLRF 0x41, ACCESS
0B7E  0E78     MOVLW 0x78
0B80  2440     ADDWF i, W, ACCESS
0B82  6ED9     MOVWF FSR2, ACCESS
0B84  0E00     MOVLW 0x0
0B86  2041     ADDWFC 0x41, W, ACCESS
0B88  6EDA     MOVWF FSR2H, ACCESS
0B8A  0100     MOVLB 0x0
0B8C  92DF     BCF INDF2, 1, ACCESS
2915:                              }
0B8E  EFD5     GOTO 0xBAA
0B90  F005     NOP
2916:                              else
2917:                              {
2918:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
0B92  5134     MOVF ep, W, BANKED
0B94  0B0F     ANDLW 0xF
0B96  6E40     MOVWF i, ACCESS
0B98  6A41     CLRF 0x41, ACCESS
0B9A  0E7B     MOVLW 0x7B
0B9C  2440     ADDWF i, W, ACCESS
0B9E  6ED9     MOVWF FSR2, ACCESS
0BA0  0E00     MOVLW 0x0
0BA2  2041     ADDWFC 0x41, W, ACCESS
0BA4  6EDA     MOVWF FSR2H, ACCESS
0BA6  0100     MOVLB 0x0
0BA8  92DF     BCF INDF2, 1, ACCESS
2919:                              }
2920:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2921:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
0BAA  C045     MOVFF p, FSR2
0BAC  FFD9     NOP
0BAE  C046     MOVFF 0x46, FSR2H
0BB0  FFDA     NOP
0BB2  0E3B     MOVLW 0x3B
0BB4  16DF     ANDWF INDF2, F, ACCESS
2922:                              //Call the application event handler callback function, so it can 
2923:          					//decide if the endpoint should get re-armed again or not.
2924:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0BB6  0E00     MOVLW 0x0
0BB8  6E39     MOVWF 0x39, ACCESS
0BBA  0E05     MOVLW 0x5
0BBC  6E38     MOVWF USBDeviceInit, ACCESS
0BBE  C045     MOVFF p, pdata
0BC0  F03A     NOP
0BC2  C046     MOVFF 0x46, 0x3B
0BC4  F03B     NOP
0BC6  0E00     MOVLW 0x0
0BC8  6E3D     MOVWF 0x3D, ACCESS
0BCA  0E02     MOVLW 0x2
0BCC  6E3C     MOVWF size, ACCESS
0BCE  EC41     CALL 0x2282, 0
0BD0  F011     NOP
2925:                          }
0BD2  EFF1     GOTO 0xBE2
0BD4  F005     NOP
2926:                          else
2927:                          {
2928:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2929:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
0BD6  C045     MOVFF p, FSR2
0BD8  FFD9     NOP
0BDA  C046     MOVFF 0x46, FSR2H
0BDC  FFDA     NOP
0BDE  0E3B     MOVLW 0x3B
0BE0  16DF     ANDWF INDF2, F, ACCESS
2930:                          } 
2931:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2932:                          //Check if we need to call the user transfer terminated event callback function.
2933:                          //We should call the callback, if the endpoint was previously terminated,
2934:                          //or the endpoint is currently armed, and the host is performing clear
2935:                          //endpoint halt, even though the endpoint wasn't stalled.
2936:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2937:                          {
2938:                              //We are going to call the user transfer terminated callback.
2939:                              //Clear the flag so we know we took care of it and don't need
2940:                              //to call it again later.
2941:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2942:                              {
2943:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2944:                              }
2945:                              else
2946:                              {
2947:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2948:                              }
2949:           
2950:                              //Clear UOWN and remove the STALL condition.   
2951:                              //  In this case we also need to set the DTS bit to 1 so that
2952:                              //  it toggles to DATA0 the next time the application firmware
2953:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2954:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2955:                              p->STAT.Val |= _DAT1;
2956:                              //Let the application firmware know a transaction just
2957:                              //got terminated by the host, and that it is now free to
2958:                              //re-arm the endpoint or do other tasks if desired.                                        
2959:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2960:                          }
2961:                          else
2962:                          {
2963:                              //Clear UOWN and remove the STALL condition.   
2964:                              //  In this case we also need to set the DTS bit to 1 so that
2965:                              //  it toggles to DATA0 the next time the application firmware
2966:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2967:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2968:                              p->STAT.Val |= _DAT1;
2969:                          } 
2970:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2971:                      
2972:          			//Get a pointer to the appropriate UEPn register
2973:                      #if defined(__C32__)
2974:                          pUEP = (uint32_t*)(&U1EP0);
2975:                          pUEP += (SetupPkt.EPNum*4);
2976:                      #else
2977:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0BE2  0104     MOVLB 0x4
0BE4  5134     MOVF ep, W, BANKED
0BE6  0B0F     ANDLW 0xF
0BE8  6E40     MOVWF i, ACCESS
0BEA  6A41     CLRF 0x41, ACCESS
0BEC  0E6A     MOVLW 0x6A
0BEE  2440     ADDWF i, W, ACCESS
0BF0  6E42     MOVWF pUEP, ACCESS
0BF2  0E0F     MOVLW 0xF
0BF4  2041     ADDWFC 0x41, W, ACCESS
0BF6  6E43     MOVWF 0x43, ACCESS
2978:                      #endif
2979:          
2980:          			//Clear the STALL bit in the UEP register
2981:                      *pUEP &= ~UEP_STALL;            
0BF8  C042     MOVFF pUEP, FSR2
0BFA  FFD9     NOP
0BFC  C043     MOVFF 0x43, FSR2H
0BFE  FFDA     NOP
0C00  0EFE     MOVLW 0xFE
0C02  16DF     ANDWF INDF2, F, ACCESS
2982:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2983:              }//end if (lots of checks for set/clear endpoint halt)
2984:          }//end USBStdFeatureReqHandler
0C04  0012     RETURN 0
2985:          
2986:          
2987:          
2988:          
2989:          /**************************************************************************
2990:              Function:
2991:                  void USBIncrement1msInternalTimers(void)
2992:          
2993:              Description:
2994:                  This function increments internal 1ms time base counters, which are
2995:                  useful for application code (that can use a 1ms time base/counter), and
2996:                  for certain USB event timing specific purposes.
2997:          
2998:                  In USB full speed applications, the application code does not need to (and should
2999:                  not) explicitly call this function, as the USBDeviceTasks() function will
3000:                  automatically call this function whenever a 1ms time interval has elapsed
3001:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
3002:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
3003:                  in USB_INTERRUPT mode).
3004:          
3005:                  In USB low speed applications, the application firmware is responsible for
3006:                  periodically calling this function at a ~1ms rate.  This can be done using
3007:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
3008:                  If the low speed application code does not call this function, the internal timers
3009:                  will not increment, and the USBGet1msTickCount() API function will not be available.
3010:                  Additionally, certain USB stack operations (like control transfer timeouts)
3011:                  may be unavailable.
3012:          
3013:              Precondition:
3014:                  This function should be called only after USBDeviceInit() has been
3015:                  called (at least once at the start of the application).  Ordinarily,
3016:                  application code should never call this function, unless it is a low speed
3017:                  USB device.
3018:          
3019:              Parameters:
3020:                  None
3021:          
3022:              Return Values:
3023:                  None
3024:          
3025:              Remarks:
3026:                  This function does not need to be called during USB suspend conditions, when
3027:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
3028:            ***************************************************************************/
3029:          void USBIncrement1msInternalTimers(void)
3030:          {
3031:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3032:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3033:              #endif
3034:          
3035:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3036:              //that needs a 1ms time base that is active during USB non-suspended operation.
3037:              USB1msTickCount++;
259E  0E01     MOVLW 0x1
25A0  0100     MOVLB 0x0
25A2  2770     ADDWF USB1msTickCount, F, BANKED
25A4  0E00     MOVLW 0x0
25A6  2371     ADDWFC 0x71, F, BANKED
25A8  2372     ADDWFC 0x72, F, BANKED
25AA  2373     ADDWFC 0x73, F, BANKED
3038:              if(USBIsBusSuspended() == false)
25AC  5022     MOVF USBBusIsSuspended, W, ACCESS
25AE  A4D8     BTFSS STATUS, 2, ACCESS
25B0  EFDC     GOTO 0x25B8
25B2  F012     NOP
25B4  EFDE     GOTO 0x25BC
25B6  F012     NOP
25B8  EFE8     GOTO 0x25D0
25BA  F012     NOP
3039:              {
3040:                  USBTicksSinceSuspendEnd++;
25BC  2B88     INCF USBTicksSinceSuspendEnd, F, BANKED
3041:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3042:                  if(USBTicksSinceSuspendEnd == 0)
25BE  5188     MOVF USBTicksSinceSuspendEnd, W, BANKED
25C0  A4D8     BTFSS STATUS, 2, ACCESS
25C2  EFE5     GOTO 0x25CA
25C4  F012     NOP
25C6  EFE7     GOTO 0x25CE
25C8  F012     NOP
25CA  EFE8     GOTO 0x25D0
25CC  F012     NOP
3043:                  {
3044:                      USBTicksSinceSuspendEnd = 255;
25CE  6988     SETF USBTicksSinceSuspendEnd, BANKED
3045:                  }
3046:              }
3047:          }
25D0  0012     RETURN 0
3048:          
3049:          
3050:          
3051:          
3052:          /**************************************************************************
3053:              Function:
3054:                  uint32_t USBGet1msTickCount(void)
3055:          
3056:              Description:
3057:                  This function retrieves a 32-bit unsigned integer that normally increments by
3058:                  one every one millisecond.  The count value starts from zero when the
3059:                  USBDeviceInit() function is first called.  See the remarks section for
3060:                  details on special circumstances where the tick count will not increment.
3061:          
3062:              Precondition:
3063:                  This function should be called only after USBDeviceInit() has been
3064:                  called (at least once at the start of the application).
3065:          
3066:              Parameters:
3067:                  None
3068:          
3069:              Return Values:
3070:                  uint32_t representing the approximate millisecond count, since the time the
3071:                  USBDeviceInit() function was first called.
3072:          
3073:              Remarks:
3074:                  On 8-bit USB full speed devices, the internal counter is incremented on
3075:                  every SOF packet detected.  Therefore, it will not increment during suspend
3076:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3077:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3078:                  on 16-bit devices, the count continue to increment during USB suspend or
3079:                  detach events, so long as the application code has not put the microcontroller
3080:                  to sleep during these events, and the application firmware is regularly
3081:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3082:                  USB_INTERRUPT mode operation).
3083:          
3084:                  In USB low speed applications, the host does not broadcast SOF packets to
3085:                  the device, so the application firmware becomes responsible for calling
3086:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3087:                  timer interrupt handler), or else the returned value from this function will
3088:                  not increment.
3089:                  
3090:                  Prior to calling USBDeviceInit() for the first time the returned value will
3091:                  be unpredictable.
3092:          
3093:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3094:                  code without risk of retrieving a partially updated 32-bit number.
3095:          
3096:                  However, this value only increments when the USBDeviceTasks() function is allowed
3097:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3098:                  function.  If however USB_POLLING mode is used, one must not block on this
3099:                  function without also calling USBDeviceTasks() continuously for the blocking
3100:                  duration (since the USB stack must still be allowed to execute, and the USB
3101:                  stack is also responsible for updating the tick counter internally).
3102:          
3103:                  If the application is operating in USB_POLLING mode, this function should
3104:                  only be called from the main loop context, and not from an interrupt handler,
3105:                  as the returned value could be incorrect, if the main loop context code was in
3106:                  the process of updating the internal count at the moment of the interrupt event.
3107:             ***************************************************************************/
3108:          uint32_t USBGet1msTickCount(void)
3109:          {
3110:              #if defined (USB_INTERRUPT)
3111:                  uint32_t localContextValue;
3112:          
3113:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3114:                  //value.  This ensures that the complete 32-bit value got read without
3115:                  //getting interrupted in between bytes.
3116:                  do
3117:                  {
3118:                      localContextValue = USB1msTickCount;
3119:                  }while(localContextValue != USB1msTickCount);
3120:          
3121:                  return localContextValue;    
3122:              
3123:              #else
3124:                  return USB1msTickCount;
3125:              #endif
3126:          }
3127:          
3128:          
3129:          
3130:          
3131:          
3132:          
3133:          /** EOF USBDevice.c *****************************************************/
---  I:/pic_tutorial/projects/usb_tut.X/mcc_generated_files/pin_manager.c  ------------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.4
17:                    Device            :  PIC18F45K50
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.20 and above
21:                    MPLAB             :  MPLAB X 5.40
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x00;
2560  0E00     MOVLW 0x0
2562  6E8D     MOVWF LATE, ACCESS
61:                LATD = 0x00;
2564  0E00     MOVLW 0x0
2566  6E8C     MOVWF LATD, ACCESS
62:                LATA = 0x00;
2568  0E00     MOVLW 0x0
256A  6E89     MOVWF LATA, ACCESS
63:                LATB = 0x00;
256C  0E00     MOVLW 0x0
256E  6E8A     MOVWF LATB, ACCESS
64:                LATC = 0x00;
2570  0E00     MOVLW 0x0
2572  6E8B     MOVWF LATC, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x07;
2574  0E07     MOVLW 0x7
2576  6E96     MOVWF TRISE, ACCESS
70:                TRISA = 0xFF;
2578  6892     SETF TRISA, ACCESS
71:                TRISB = 0xFF;
257A  6893     SETF TRISB, ACCESS
72:                TRISC = 0xC7;
257C  0EC7     MOVLW 0xC7
257E  6E94     MOVWF TRISC, ACCESS
73:                TRISD = 0xFF;
2580  6895     SETF TRISD, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0xFF;
2582  010F     MOVLB 0xF
2584  695E     SETF 0x5E, BANKED
79:                ANSELC = 0xC4;
2586  0EC4     MOVLW 0xC4
2588  6F5D     MOVWF 0x5D, BANKED
80:                ANSELB = 0x3F;
258A  0E3F     MOVLW 0x3F
258C  6F5C     MOVWF 0x5C, BANKED
81:                ANSELE = 0x07;
258E  0E07     MOVLW 0x7
2590  6F5F     MOVWF 0x5F, BANKED
82:                ANSELA = 0x2F;
2592  0E2F     MOVLW 0x2F
2594  6F5B     MOVWF 0x5B, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUB = 0x00;
2596  0E00     MOVLW 0x0
2598  6E85     MOVWF WPUB, ACCESS
88:                INTCON2bits.nRBPU = 1;
259A  8EF1     BSF INTCON2, 7, ACCESS
89:            
90:            
91:            
92:            
93:            
94:            
95:               
96:                
97:            }
259C  0012     RETURN 0
98:              
99:            void PIN_MANAGER_IOC(void)
100:           {   
101:           	// Clear global Interrupt-On-Change flag
102:               INTCONbits.IOCIF = 0;
103:           }
104:           
105:           /**
106:            End of File
107:           */
---  I:/pic_tutorial/projects/usb_tut.X/mcc_generated_files/mcc.c  --------------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.4
17:                    Device            :  PIC18F45K50
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.20 and above or later
21:                    MPLAB             :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:            
53:                INTERRUPT_Initialize();
2652  EC3A     CALL 0x2674, 0
2654  F013     NOP
54:                PIN_MANAGER_Initialize();
2656  ECB0     CALL 0x2560, 0
2658  F012     NOP
55:                OSCILLATOR_Initialize();
265A  EC19     CALL 0x2632, 0
265C  F013     NOP
56:                USBDeviceInit();
265E  EC3E     CALL 0x127C, 0
2660  F009     NOP
57:                USBDeviceAttach();
2662  EC6F     CALL 0x24DE, 0
2664  F012     NOP
58:            }
2666  0012     RETURN 0
59:            
60:            void OSCILLATOR_Initialize(void)
61:            {
62:                // SCS FOSC; IDLEN disabled; IRCF 250KHz; 
63:                OSCCON = 0x10;
2632  0E10     MOVLW 0x10
2634  6ED3     MOVWF OSCCON, ACCESS
64:                // INTSRC INTRC_31_25KHz; PLLEN disabled; PRISD disabled; SOSCGO disabled; 
65:                OSCCON2 = 0x00;
2636  0E00     MOVLW 0x0
2638  6ED2     MOVWF OSCCON2, ACCESS
66:                // SPLLMULT 3xPLL; TUN 0; 
67:                OSCTUNE = 0x80;
263A  0E80     MOVLW 0x80
263C  6E9B     MOVWF OSCTUNE, ACCESS
68:                // ACTSRC SOSC; ACTUD enabled; ACTEN disabled; 
69:                ACTCON = 0x00;
263E  0E00     MOVLW 0x0
2640  6EB5     MOVWF ACTCON, ACCESS
70:                // Wait for PLL to stabilize
71:                while(PLLRDY == 0)
72:                {
73:                }
2642  AED2     BTFSS OSCCON2, 7, ACCESS
2644  EF26     GOTO 0x264C
2646  F013     NOP
2648  EF28     GOTO 0x2650
264A  F013     NOP
264C  EF21     GOTO 0x2642
264E  F013     NOP
74:            }
2650  0012     RETURN 0
75:            
76:            
77:            /**
78:             End of File
79:            */
---  I:/pic_tutorial/projects/usb_tut.X/mcc_generated_files/interrupt_manager.c  ------------------------
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.4
19:                    Device            :  PIC18F45K50
20:                    Driver Version    :  2.03
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.20 and above or later
23:                    MPLAB 	          :  MPLAB X 5.40
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
53:            {
54:                // Disable Interrupt Priority Vectors (16CXXX Compatibility Mode)
55:                RCONbits.IPEN = 0;
2674  9ED0     BCF RCON, 7, ACCESS
56:            }
2676  0012     RETURN 0
57:            
58:            void __interrupt() INTERRUPT_InterruptManager (void)
0008  8257     BSF btemp, 1, ACCESS
000A  CFE9     MOVFF FSR0, 0x4B
000C  F04B     NOP
000E  CFEA     MOVFF FSR0H, 0x4C
0010  F04C     NOP
0012  CFE1     MOVFF FSR1, 0x4D
0014  F04D     NOP
0016  CFE2     MOVFF FSR1H, 0x4E
0018  F04E     NOP
001A  CFD9     MOVFF FSR2, 0x4F
001C  F04F     NOP
001E  CFDA     MOVFF FSR2H, 0x50
0020  F050     NOP
0022  CFF3     MOVFF PROD, 0x51
0024  F051     NOP
0026  CFF4     MOVFF PRODH, 0x52
0028  F052     NOP
002A  CFF6     MOVFF TBLPTR, 0x53
002C  F053     NOP
002E  CFF7     MOVFF TBLPTRH, 0x54
0030  F054     NOP
0032  CFF8     MOVFF TBLPTRU, 0x55
0034  F055     NOP
0036  CFF5     MOVFF TABLAT, 0x56
0038  F056     NOP
59:            {
60:                // interrupt handler
61:                if(INTCONbits.PEIE == 1)
003A  ACF2     BTFSS INTCON, 6, ACCESS
003C  EF22     GOTO 0x44
003E  F000     NOP
0040  EF24     GOTO 0x48
0042  F000     NOP
0044  EF34     GOTO 0x68
0046  F000     NOP
62:                {
63:                    if(PIE3bits.USBIE == 1 && PIR3bits.USBIF == 1)
0048  A4A3     BTFSS PIE3, 2, ACCESS
004A  EF29     GOTO 0x52
004C  F000     NOP
004E  EF2B     GOTO 0x56
0050  F000     NOP
0052  EF34     GOTO 0x68
0054  F000     NOP
0056  A4A4     BTFSS PIR3, 2, ACCESS
0058  EF30     GOTO 0x60
005A  F000     NOP
005C  EF32     GOTO 0x64
005E  F000     NOP
0060  EF34     GOTO 0x68
0062  F000     NOP
64:                    {
65:                        USB_USBDeviceTasks();
0064  EC03     CALL 0xC06, 0
0066  F006     NOP
66:                    } 
67:                    else
68:                    {
69:                        //Unhandled Interrupt
70:                    }
71:                }      
72:                else
73:                {
74:                    //Unhandled Interrupt
75:                }
76:            }
0068  C056     MOVFF 0x56, TABLAT
006A  FFF5     NOP
006C  C055     MOVFF 0x55, TBLPTRU
006E  FFF8     NOP
0070  C054     MOVFF 0x54, TBLPTRH
0072  FFF7     NOP
0074  C053     MOVFF 0x53, TBLPTR
0076  FFF6     NOP
0078  C052     MOVFF 0x52, PRODH
007A  FFF4     NOP
007C  C051     MOVFF 0x51, PROD
007E  FFF3     NOP
0080  C050     MOVFF 0x50, FSR2H
0082  FFDA     NOP
0084  C04F     MOVFF 0x4F, FSR2
0086  FFD9     NOP
0088  C04E     MOVFF 0x4E, FSR1H
008A  FFE2     NOP
008C  C04D     MOVFF 0x4D, FSR1
008E  FFE1     NOP
0090  C04C     MOVFF 0x4C, FSR0H
0092  FFEA     NOP
0094  C04B     MOVFF 0x4B, FSR0
0096  FFE9     NOP
0098  9257     BCF btemp, 1, ACCESS
009A  0011     RETFIE 1
77:            /**
78:             End of File
79:            */
---  I:/pic_tutorial/projects/usb_tut.X/main.c  ---------------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.4
17:                    Device            :  PIC18F45K50
18:                    Driver Version    :  2.00
19:            */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:            */
43:            
44:            #include "mcc_generated_files/mcc.h"
45:            
46:            /*
47:                                     Main application
48:             */
49:            void main(void)
50:            {
51:                // Initialize the device
52:                SYSTEM_Initialize();
2668  EC29     CALL 0x2652, 0
266A  F013     NOP
53:            
54:                // If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts
55:                // If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global and Peripheral Interrupts
56:                // Use the following macros to:
57:            
58:                // Enable the Global Interrupts
59:                //INTERRUPT_GlobalInterruptEnable();
60:            
61:                // Disable the Global Interrupts
62:                //INTERRUPT_GlobalInterruptDisable();
63:            
64:                // Enable the Peripheral Interrupts
65:                //INTERRUPT_PeripheralInterruptEnable();
66:            
67:                // Disable the Peripheral Interrupts
68:                //INTERRUPT_PeripheralInterruptDisable();
69:            
70:                while (1)
71:                {
72:                    // Add your application code
73:                }
266C  EF36     GOTO 0x266C
266E  F013     NOP
2670  EF4E     GOTO 0x9C
2672  F000     NOP
74:            }
75:            /**
76:             End of File
77:            */
---  C:/Users/DEVILB~1/AppData/Local/Temp/sojc.s  -------------------------------------------------------
25D2  EE01     LFSR 0, 0x100
25D6  0E40     MOVLW 0x40
25D8  6AEE     CLRF POSTINC0, ACCESS
25DA  06E8     DECF WREG, F, ACCESS
25DC  E1FD     BNZ 0x25D8
25DE  EE00     LFSR 0, 0x60
25E2  0E7D     MOVLW 0x7D
25E4  6AEE     CLRF POSTINC0, ACCESS
25E6  06E8     DECF WREG, F, ACCESS
25E8  E1FD     BNZ 0x25E4
25EA  EE00     LFSR 0, 0x1
25EE  0E2B     MOVLW 0x2B
25F0  6AEE     CLRF POSTINC0, ACCESS
25F2  06E8     DECF WREG, F, ACCESS
25F4  E1FD     BNZ 0x25F0
25F6  9057     BCF btemp, 0, ACCESS
25F8  9257     BCF btemp, 1, ACCESS
25FA  0E00     MOVLW 0x0
25FC  6EF8     MOVWF TBLPTRU, ACCESS
25FE  0100     MOVLB 0x0
2600  EF34     GOTO 0x2668
0008  8257     BSF btemp, 1, ACCESS
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/memset.c  ------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
0E2E  C0DD     MOVFF __pcstackBANK0, s
0E30  F0E7     NOP
0E32  C0DE     MOVFF 0xDE, 0xE8
0E34  F0E8     NOP
0FA6  C02C     MOVFF __pcstackCOMRAM, tmp
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
0E36  0100     MOVLB 0x0
0E38  51E1     MOVF n, W, BANKED
0E3A  11E2     IORWF 0xE2, W, BANKED
0E3C  A4D8     BTFSS STATUS, 2, ACCESS
0E3E  EF23     GOTO 0xE46
0E40  F007     NOP
0E42  EF25     GOTO 0xE4A
0E44  F007     NOP
0E46  EF27     GOTO 0xE4E
0E48  F007     NOP
0E4A  EFD2     GOTO 0xFA4
0E4C  F007     NOP
0FAE  5030     MOVF n, W, ACCESS
0FB0  1031     IORWF EPNum, W, ACCESS
0FB2  A4D8     BTFSS STATUS, 2, ACCESS
0FB4  EFDE     GOTO 0xFBC
0FB6  F007     NOP
0FB8  EFE0     GOTO 0xFC0
0FBA  F007     NOP
0FBC  EFE2     GOTO 0xFC4
0FBE  F007     NOP
0FC0  EF8D     GOTO 0x111A
0FC2  F008     NOP
14:            	s[0] = c;
0E4E  C0E7     MOVFF s, FSR2
0E50  FFD9     NOP
0E52  C0E8     MOVFF 0xE8, FSR2H
0E54  FFDA     NOP
0E56  C0DF     MOVFF c, INDF2
0E58  FFDF     NOP
0FC4  C036     MOVFF tmp, FSR2
0FC6  FFD9     NOP
0FC8  C037     MOVFF ep, FSR2H
0FCA  FFDA     NOP
0FCC  C02E     MOVFF p, INDF2
0FCE  FFDF     NOP
15:            	s[n-1] = c;
0E5A  51E1     MOVF n, W, BANKED
0E5C  25E7     ADDWF s, W, BANKED
0E5E  6FE3     MOVWF 0xE3, BANKED
0E60  51E2     MOVF 0xE2, W, BANKED
0E62  21E8     ADDWFC 0xE8, W, BANKED
0E64  6FE4     MOVWF 0xE4, BANKED
0E66  0EFF     MOVLW 0xFF
0E68  25E3     ADDWF 0xE3, W, BANKED
0E6A  6ED9     MOVWF FSR2, ACCESS
0E6C  0EFF     MOVLW 0xFF
0E6E  21E4     ADDWFC 0xE4, W, BANKED
0E70  6EDA     MOVWF FSR2H, ACCESS
0E72  C0DF     MOVFF c, INDF2
0E74  FFDF     NOP
0FD0  5030     MOVF n, W, ACCESS
0FD2  2436     ADDWF tmp, W, ACCESS
0FD4  6E32     MOVWF handle, ACCESS
0FD6  5031     MOVF EPNum, W, ACCESS
0FD8  2037     ADDWFC ep, W, ACCESS
0FDA  6E33     MOVWF 0x33, ACCESS
0FDC  0EFF     MOVLW 0xFF
0FDE  2432     ADDWF handle, W, ACCESS
0FE0  6ED9     MOVWF FSR2, ACCESS
0FE2  0EFF     MOVLW 0xFF
0FE4  2033     ADDWFC 0x33, W, ACCESS
0FE6  6EDA     MOVWF FSR2H, ACCESS
0FE8  C02E     MOVFF p, INDF2
0FEA  FFDF     NOP
16:            	if (n <= 2) return dest;
0E76  51E2     MOVF 0xE2, W, BANKED
0E78  E107     BNZ 0xE88
0E7A  0E03     MOVLW 0x3
0E7C  5DE1     SUBWF n, W, BANKED
0E7E  B0D8     BTFSC STATUS, 0, ACCESS
0E80  EF44     GOTO 0xE88
0E82  F007     NOP
0E84  EF46     GOTO 0xE8C
0E86  F007     NOP
0E88  EF48     GOTO 0xE90
0E8A  F007     NOP
0E8C  EFD2     GOTO 0xFA4
0E8E  F007     NOP
0FEC  5031     MOVF EPNum, W, ACCESS
0FEE  E107     BNZ 0xFFE
0FF0  0E03     MOVLW 0x3
0FF2  5C30     SUBWF n, W, ACCESS
0FF4  B0D8     BTFSC STATUS, 0, ACCESS
0FF6  EFFF     GOTO 0xFFE
0FF8  F007     NOP
0FFA  EF01     GOTO 0x1002
0FFC  F008     NOP
0FFE  EF03     GOTO 0x1006
1000  F008     NOP
1002  EF8D     GOTO 0x111A
1004  F008     NOP
17:            	s[1] = c;
0E90  EE20     LFSR 2, 0x1
0E92  F001     NOP
0E94  51E7     MOVF s, W, BANKED
0E96  26D9     ADDWF FSR2, F, ACCESS
0E98  51E8     MOVF 0xE8, W, BANKED
0E9A  22DA     ADDWFC FSR2H, F, ACCESS
0E9C  C0DF     MOVFF c, INDF2
0E9E  FFDF     NOP
1006  EE20     LFSR 2, 0x1
1008  F001     NOP
100A  5036     MOVF tmp, W, ACCESS
100C  26D9     ADDWF FSR2, F, ACCESS
100E  5037     MOVF ep, W, ACCESS
1010  22DA     ADDWFC FSR2H, F, ACCESS
1012  C02E     MOVFF p, INDF2
1014  FFDF     NOP
18:            	s[2] = c;
0EA0  EE20     LFSR 2, 0x2
0EA2  F002     NOP
0EA4  51E7     MOVF s, W, BANKED
0EA6  26D9     ADDWF FSR2, F, ACCESS
0EA8  51E8     MOVF 0xE8, W, BANKED
0EAA  22DA     ADDWFC FSR2H, F, ACCESS
0EAC  C0DF     MOVFF c, INDF2
0EAE  FFDF     NOP
1016  EE20     LFSR 2, 0x2
1018  F002     NOP
101A  5036     MOVF tmp, W, ACCESS
101C  26D9     ADDWF FSR2, F, ACCESS
101E  5037     MOVF ep, W, ACCESS
1020  22DA     ADDWFC FSR2H, F, ACCESS
1022  C02E     MOVFF p, INDF2
1024  FFDF     NOP
19:            	s[n-2] = c;
0EB0  51E1     MOVF n, W, BANKED
0EB2  25E7     ADDWF s, W, BANKED
0EB4  6FE3     MOVWF 0xE3, BANKED
0EB6  51E2     MOVF 0xE2, W, BANKED
0EB8  21E8     ADDWFC 0xE8, W, BANKED
0EBA  6FE4     MOVWF 0xE4, BANKED
0EBC  0EFE     MOVLW 0xFE
0EBE  25E3     ADDWF 0xE3, W, BANKED
0EC0  6ED9     MOVWF FSR2, ACCESS
0EC2  0EFF     MOVLW 0xFF
0EC4  21E4     ADDWFC 0xE4, W, BANKED
0EC6  6EDA     MOVWF FSR2H, ACCESS
0EC8  C0DF     MOVFF c, INDF2
0ECA  FFDF     NOP
1026  5030     MOVF n, W, ACCESS
1028  2436     ADDWF tmp, W, ACCESS
102A  6E32     MOVWF handle, ACCESS
102C  5031     MOVF EPNum, W, ACCESS
102E  2037     ADDWFC ep, W, ACCESS
1030  6E33     MOVWF 0x33, ACCESS
1032  0EFE     MOVLW 0xFE
1034  2432     ADDWF handle, W, ACCESS
1036  6ED9     MOVWF FSR2, ACCESS
1038  0EFF     MOVLW 0xFF
103A  2033     ADDWFC 0x33, W, ACCESS
103C  6EDA     MOVWF FSR2H, ACCESS
103E  C02E     MOVFF p, INDF2
1040  FFDF     NOP
20:            	s[n-3] = c;
0ECC  51E1     MOVF n, W, BANKED
0ECE  25E7     ADDWF s, W, BANKED
0ED0  6FE3     MOVWF 0xE3, BANKED
0ED2  51E2     MOVF 0xE2, W, BANKED
0ED4  21E8     ADDWFC 0xE8, W, BANKED
0ED6  6FE4     MOVWF 0xE4, BANKED
0ED8  0EFD     MOVLW 0xFD
0EDA  25E3     ADDWF 0xE3, W, BANKED
0EDC  6ED9     MOVWF FSR2, ACCESS
0EDE  0EFF     MOVLW 0xFF
0EE0  21E4     ADDWFC 0xE4, W, BANKED
0EE2  6EDA     MOVWF FSR2H, ACCESS
0EE4  C0DF     MOVFF c, INDF2
0EE6  FFDF     NOP
1042  5030     MOVF n, W, ACCESS
1044  2436     ADDWF tmp, W, ACCESS
1046  6E32     MOVWF handle, ACCESS
1048  5031     MOVF EPNum, W, ACCESS
104A  2037     ADDWFC ep, W, ACCESS
104C  6E33     MOVWF 0x33, ACCESS
104E  0EFD     MOVLW 0xFD
1050  2432     ADDWF handle, W, ACCESS
1052  6ED9     MOVWF FSR2, ACCESS
1054  0EFF     MOVLW 0xFF
1056  2033     ADDWFC 0x33, W, ACCESS
1058  6EDA     MOVWF FSR2H, ACCESS
105A  C02E     MOVFF p, INDF2
105C  FFDF     NOP
21:            	if (n <= 6) return dest;
0EE8  51E2     MOVF 0xE2, W, BANKED
0EEA  E107     BNZ 0xEFA
0EEC  0E07     MOVLW 0x7
0EEE  5DE1     SUBWF n, W, BANKED
0EF0  B0D8     BTFSC STATUS, 0, ACCESS
0EF2  EF7D     GOTO 0xEFA
0EF4  F007     NOP
0EF6  EF7F     GOTO 0xEFE
0EF8  F007     NOP
0EFA  EF81     GOTO 0xF02
0EFC  F007     NOP
0EFE  EFD2     GOTO 0xFA4
0F00  F007     NOP
105E  5031     MOVF EPNum, W, ACCESS
1060  E107     BNZ 0x1070
1062  0E07     MOVLW 0x7
1064  5C30     SUBWF n, W, ACCESS
1066  B0D8     BTFSC STATUS, 0, ACCESS
1068  EF38     GOTO 0x1070
106A  F008     NOP
106C  EF3A     GOTO 0x1074
106E  F008     NOP
1070  EF3C     GOTO 0x1078
1072  F008     NOP
1074  EF8D     GOTO 0x111A
1076  F008     NOP
22:            	s[3] = c;
0F02  EE20     LFSR 2, 0x3
0F04  F003     NOP
0F06  51E7     MOVF s, W, BANKED
0F08  26D9     ADDWF FSR2, F, ACCESS
0F0A  51E8     MOVF 0xE8, W, BANKED
0F0C  22DA     ADDWFC FSR2H, F, ACCESS
0F0E  C0DF     MOVFF c, INDF2
0F10  FFDF     NOP
1078  EE20     LFSR 2, 0x3
107A  F003     NOP
107C  5036     MOVF tmp, W, ACCESS
107E  26D9     ADDWF FSR2, F, ACCESS
1080  5037     MOVF ep, W, ACCESS
1082  22DA     ADDWFC FSR2H, F, ACCESS
1084  C02E     MOVFF p, INDF2
1086  FFDF     NOP
23:            	s[n-4] = c;
0F12  51E1     MOVF n, W, BANKED
0F14  25E7     ADDWF s, W, BANKED
0F16  6FE3     MOVWF 0xE3, BANKED
0F18  51E2     MOVF 0xE2, W, BANKED
0F1A  21E8     ADDWFC 0xE8, W, BANKED
0F1C  6FE4     MOVWF 0xE4, BANKED
0F1E  0EFC     MOVLW 0xFC
0F20  25E3     ADDWF 0xE3, W, BANKED
0F22  6ED9     MOVWF FSR2, ACCESS
0F24  0EFF     MOVLW 0xFF
0F26  21E4     ADDWFC 0xE4, W, BANKED
0F28  6EDA     MOVWF FSR2H, ACCESS
0F2A  C0DF     MOVFF c, INDF2
0F2C  FFDF     NOP
1088  5030     MOVF n, W, ACCESS
108A  2436     ADDWF tmp, W, ACCESS
108C  6E32     MOVWF handle, ACCESS
108E  5031     MOVF EPNum, W, ACCESS
1090  2037     ADDWFC ep, W, ACCESS
1092  6E33     MOVWF 0x33, ACCESS
1094  0EFC     MOVLW 0xFC
1096  2432     ADDWF handle, W, ACCESS
1098  6ED9     MOVWF FSR2, ACCESS
109A  0EFF     MOVLW 0xFF
109C  2033     ADDWFC 0x33, W, ACCESS
109E  6EDA     MOVWF FSR2H, ACCESS
10A0  C02E     MOVFF p, INDF2
10A2  FFDF     NOP
24:            	if (n <= 8) return dest;
0F2E  51E2     MOVF 0xE2, W, BANKED
0F30  E107     BNZ 0xF40
0F32  0E09     MOVLW 0x9
0F34  5DE1     SUBWF n, W, BANKED
0F36  B0D8     BTFSC STATUS, 0, ACCESS
0F38  EFA0     GOTO 0xF40
0F3A  F007     NOP
0F3C  EFA2     GOTO 0xF44
0F3E  F007     NOP
0F40  EFA4     GOTO 0xF48
0F42  F007     NOP
0F44  EFD2     GOTO 0xFA4
0F46  F007     NOP
10A4  5031     MOVF EPNum, W, ACCESS
10A6  E107     BNZ 0x10B6
10A8  0E09     MOVLW 0x9
10AA  5C30     SUBWF n, W, ACCESS
10AC  B0D8     BTFSC STATUS, 0, ACCESS
10AE  EF5B     GOTO 0x10B6
10B0  F008     NOP
10B2  EF5D     GOTO 0x10BA
10B4  F008     NOP
10B6  EF5F     GOTO 0x10BE
10B8  F008     NOP
10BA  EF8D     GOTO 0x111A
10BC  F008     NOP
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
0F48  C0E7     MOVFF s, 0xE3
0F4A  F0E3     NOP
0F4C  C0E8     MOVFF 0xE8, 0xE4
0F4E  F0E4     NOP
0F50  1FE3     COMF 0xE3, F, BANKED
0F52  1FE4     COMF 0xE4, F, BANKED
0F54  4BE3     INFSNZ 0xE3, F, BANKED
0F56  2BE4     INCF 0xE4, F, BANKED
0F58  0E03     MOVLW 0x3
0F5A  15E3     ANDWF 0xE3, W, BANKED
0F5C  6FE5     MOVWF k, BANKED
0F5E  6BE6     CLRF 0xE6, BANKED
10BE  C036     MOVFF tmp, handle
10C0  F032     NOP
10C2  C037     MOVFF ep, 0x33
10C4  F033     NOP
10C6  1E32     COMF handle, F, ACCESS
10C8  1E33     COMF 0x33, F, ACCESS
10CA  4A32     INFSNZ handle, F, ACCESS
10CC  2A33     INCF 0x33, F, ACCESS
10CE  0E03     MOVLW 0x3
10D0  1432     ANDWF handle, W, ACCESS
10D2  6E34     MOVWF ep, ACCESS
10D4  6A35     CLRF handle, ACCESS
32:            	s += k;
0F60  51E5     MOVF k, W, BANKED
0F62  27E7     ADDWF s, F, BANKED
0F64  51E6     MOVF 0xE6, W, BANKED
0F66  23E8     ADDWFC 0xE8, F, BANKED
10D6  5034     MOVF ep, W, ACCESS
10D8  2636     ADDWF tmp, F, ACCESS
10DA  5035     MOVF handle, W, ACCESS
10DC  2237     ADDWFC ep, F, ACCESS
33:            	n -= k;
0F68  51E5     MOVF k, W, BANKED
0F6A  5FE1     SUBWF n, F, BANKED
0F6C  51E6     MOVF 0xE6, W, BANKED
0F6E  5BE2     SUBWFB 0xE2, F, BANKED
10DE  5034     MOVF ep, W, ACCESS
10E0  5E30     SUBWF n, F, ACCESS
10E2  5035     MOVF handle, W, ACCESS
10E4  5A31     SUBWFB EPNum, F, ACCESS
34:            	n &= -4;
0F70  0EFC     MOVLW 0xFC
0F72  17E1     ANDWF n, F, BANKED
0F74  0EFF     MOVLW 0xFF
0F76  17E2     ANDWF 0xE2, F, BANKED
10E6  0EFC     MOVLW 0xFC
10E8  1630     ANDWF n, F, ACCESS
10EA  0EFF     MOVLW 0xFF
10EC  1631     ANDWF EPNum, F, ACCESS
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = c;
0F78  EFC9     GOTO 0xF92
0F7A  F007     NOP
0F7C  C0E7     MOVFF s, FSR2
0F7E  FFD9     NOP
0F80  C0E8     MOVFF 0xE8, FSR2H
0F82  FFDA     NOP
0F84  C0DF     MOVFF c, INDF2
0F86  FFDF     NOP
0F88  07E1     DECF n, F, BANKED
0F8A  A0D8     BTFSS STATUS, 0, ACCESS
0F8C  07E2     DECF 0xE2, F, BANKED
0F8E  4BE7     INFSNZ s, F, BANKED
0F90  2BE8     INCF 0xE8, F, BANKED
0F92  51E1     MOVF n, W, BANKED
0F94  11E2     IORWF 0xE2, W, BANKED
0F96  A4D8     BTFSS STATUS, 2, ACCESS
0F98  EFD0     GOTO 0xFA0
0F9A  F007     NOP
0F9C  EFD2     GOTO 0xFA4
0F9E  F007     NOP
0FA0  EFBE     GOTO 0xF7C
0FA2  F007     NOP
10EE  EF84     GOTO 0x1108
10F0  F008     NOP
10F2  C036     MOVFF tmp, FSR2
10F4  FFD9     NOP
10F6  C037     MOVFF ep, FSR2H
10F8  FFDA     NOP
10FA  C02E     MOVFF p, INDF2
10FC  FFDF     NOP
10FE  0630     DECF n, F, ACCESS
1100  A0D8     BTFSS STATUS, 0, ACCESS
1102  0631     DECF EPNum, F, ACCESS
1104  4A36     INFSNZ tmp, F, ACCESS
1106  2A37     INCF ep, F, ACCESS
1108  5030     MOVF n, W, ACCESS
110A  1031     IORWF EPNum, W, ACCESS
110C  A4D8     BTFSS STATUS, 2, ACCESS
110E  EF8B     GOTO 0x1116
1110  F008     NOP
1112  EF8D     GOTO 0x111A
1114  F008     NOP
1116  EF79     GOTO 0x10F2
1118  F008     NOP
87:            #endif
88:            
89:            	return dest;
90:            }
0FA4  0012     RETURN 0
111A  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/memcpy.c  ------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
2442  C02E     MOVFF p, ep
2444  F034     NOP
2446  C02F     MOVFF len, handle
2448  F035     NOP
12:            	d = d1;
244A  C02C     MOVFF __pcstackCOMRAM, handle
244C  F032     NOP
244E  C02D     MOVFF data, 0x33
2450  F033     NOP
13:            	while(n--) {
2452  EF3B     GOTO 0x2476
2454  F012     NOP
2476  0630     DECF n, F, ACCESS
2478  A0D8     BTFSS STATUS, 0, ACCESS
247A  0631     DECF EPNum, F, ACCESS
247C  2830     INCF n, W, ACCESS
247E  E106     BNZ 0x248C
2480  2831     INCF EPNum, W, ACCESS
2482  A4D8     BTFSS STATUS, 2, ACCESS
2484  EF46     GOTO 0x248C
2486  F012     NOP
2488  EF48     GOTO 0x2490
248A  F012     NOP
248C  EF2B     GOTO 0x2456
248E  F012     NOP
14:            		tmp = *s++;
2456  C034     MOVFF ep, FSR2
2458  FFD9     NOP
245A  C035     MOVFF handle, FSR2H
245C  FFDA     NOP
245E  50DF     MOVF INDF2, W, ACCESS
2460  6E36     MOVWF tmp, ACCESS
2462  4A34     INFSNZ ep, F, ACCESS
2464  2A35     INCF handle, F, ACCESS
15:            		*d++ = tmp;
2466  C032     MOVFF handle, FSR2
2468  FFD9     NOP
246A  C033     MOVFF 0x33, FSR2H
246C  FFDA     NOP
246E  C036     MOVFF tmp, INDF2
2470  FFDF     NOP
2472  4A32     INFSNZ handle, F, ACCESS
2474  2A33     INCF 0x33, F, ACCESS
16:            	}
17:            	return d1;
18:            }
2490  0012     RETURN 0
19:            
